# Staging and Publishing Toolsets - Implementation Plan

> **Boyd's Law of Iteration**: Speed of iteration beats quality of iteration. This plan breaks down the project into small, atomic components that can be individually verified.

## Overview

This document outlines the implementation plan for adding staging and release capabilities to Gram toolsets, based on the [RFC: Staging and Releasing Toolset Versions](https://www.notion.so/speakeasyapi/RFC-Staging-and-Releasing-Toolset-Versions-28e726c497cc800dbbabc7a7caf58a4c).

## Current State Analysis

### What Exists Today
- ✅ Toolsets with in-place updates (name, description, etc.)
- ✅ `toolset_versions` table with tool_urns and resource_urns
- ✅ Tool variations system (but edited in-place)
- ✅ Deployments system capturing source state
- ❌ No staging/live distinction
- ❌ No releases system
- ❌ No versioned variations
- ❌ No versioned toolset metadata

### What Needs to Change
1. Add staging toolset support (parent_toolset_id)
2. Add releases system
3. Version tool variations (currently in-place edits)
4. Version toolset metadata (currently in-place edits)
5. Add editing mode toggle (iteration vs staging)
6. Add UI for staging/live toggle and releases

## Technical Architecture

### Release State Model

A complete toolset release is identified by:

```
ReleaseID
├── SourceStateID
│   ├── DeploymentID (HTTP + Function tools)
│   └── SystemSourceID (Prompt templates)
├── ToolsetVersionID
│   └── ToolsetID (versioned metadata)
└── VariationsState
    ├── GlobalVariationsVersionID
    └── ToolsetVariationsVersionID
```

### Key Design Decisions

**Decision 1: Staging as Duplicates**
- Staging toolsets are real toolset records with `parent_toolset_id`
- Presentation as single entity is a UI concern
- Enables full feature parity by default

**Decision 2: Two-Track Versioning**
- **Iteration Mode**: No releases, changes are immediate
- **Staging Mode**: Creates releases on publish
- Backend must serve both types

**Decision 3: Releases at Toolset Level**
- Each toolset can have its own releases
- Project-level state (deployments, global variations) affects all toolsets
- Rollback is constrained to toolset-specific state

**Decision 4: Functions Staging Deferred**
- Initial implementation: deploying new function = all toolsets using it get the update
- Future: version-specific function routing per toolset

## Implementation Phases

### Phase 1: Database Schema Foundation (Weeks 1-2)

#### 1.1 Add Staging Toolset Support
**Goal**: Enable toolsets to reference a parent toolset

**Schema Changes**:
```sql
-- Add to toolsets table
ALTER TABLE toolsets
ADD COLUMN parent_toolset_id uuid,
ADD COLUMN editing_mode TEXT NOT NULL DEFAULT 'iteration' CHECK (editing_mode IN ('iteration', 'staging')),
ADD CONSTRAINT toolsets_parent_toolset_id_fkey
  FOREIGN KEY (parent_toolset_id)
  REFERENCES toolsets (id)
  ON DELETE CASCADE;

-- Index for finding staging toolsets
CREATE INDEX toolsets_parent_toolset_id_idx
ON toolsets (parent_toolset_id)
WHERE parent_toolset_id IS NOT NULL;
```

**Verification**:
- [ ] Run migration on local DB
- [ ] Create test toolset with parent_toolset_id
- [ ] Verify cascade delete works

#### 1.2 Create Releases Infrastructure
**Goal**: Add tables to track releases

**Schema Changes**:
```sql
-- Main releases table
CREATE TABLE IF NOT EXISTS toolset_releases (
  id uuid NOT NULL DEFAULT generate_uuidv7(),
  toolset_id uuid NOT NULL,

  -- The complete state captured at release time
  source_state_id uuid NOT NULL,
  toolset_version_id uuid NOT NULL,
  global_variations_version_id uuid,
  toolset_variations_version_id uuid,

  -- Optional metadata
  release_number BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
  notes TEXT,
  released_by_user_id TEXT NOT NULL,

  created_at timestamptz NOT NULL DEFAULT clock_timestamp(),

  CONSTRAINT toolset_releases_pkey PRIMARY KEY (id),
  CONSTRAINT toolset_releases_toolset_id_fkey
    FOREIGN KEY (toolset_id)
    REFERENCES toolsets (id)
    ON DELETE CASCADE,
  CONSTRAINT toolset_releases_toolset_version_id_fkey
    FOREIGN KEY (toolset_version_id)
    REFERENCES toolset_versions (id)
    ON DELETE RESTRICT
);

CREATE INDEX toolset_releases_toolset_id_idx
ON toolset_releases (toolset_id, created_at DESC);

-- Track which release is "live" for each toolset
ALTER TABLE toolsets
ADD COLUMN current_release_id uuid,
ADD CONSTRAINT toolsets_current_release_id_fkey
  FOREIGN KEY (current_release_id)
  REFERENCES toolset_releases (id)
  ON DELETE SET NULL;
```

**Verification**:
- [ ] Run migration
- [ ] Insert test release record
- [ ] Verify foreign key constraints
- [ ] Test cascade behavior

#### 1.3 Add Source State Tracking
**Goal**: Create identifiers for capturing source state

**Schema Changes**:
```sql
-- System sources (prompt templates, etc.)
CREATE TABLE IF NOT EXISTS system_source_states (
  id uuid NOT NULL DEFAULT generate_uuidv7(),
  project_id uuid NOT NULL,

  prompt_template_ids uuid[] NOT NULL DEFAULT ARRAY[]::uuid[],

  created_at timestamptz NOT NULL DEFAULT clock_timestamp(),

  CONSTRAINT system_source_states_pkey PRIMARY KEY (id),
  CONSTRAINT system_source_states_project_id_fkey
    FOREIGN KEY (project_id)
    REFERENCES projects (id)
    ON DELETE CASCADE
);

-- Complete source state (deployment + system sources)
CREATE TABLE IF NOT EXISTS source_states (
  id uuid NOT NULL DEFAULT generate_uuidv7(),
  project_id uuid NOT NULL,

  deployment_id uuid NOT NULL,
  system_source_state_id uuid NOT NULL,

  created_at timestamptz NOT NULL DEFAULT clock_timestamp(),

  CONSTRAINT source_states_pkey PRIMARY KEY (id),
  CONSTRAINT source_states_project_id_fkey
    FOREIGN KEY (project_id)
    REFERENCES projects (id)
    ON DELETE CASCADE,
  CONSTRAINT source_states_deployment_id_fkey
    FOREIGN KEY (deployment_id)
    REFERENCES deployments (id)
    ON DELETE RESTRICT,
  CONSTRAINT source_states_system_source_state_id_fkey
    FOREIGN KEY (system_source_state_id)
    REFERENCES system_source_states (id)
    ON DELETE RESTRICT
);

CREATE UNIQUE INDEX source_states_deployment_system_key
ON source_states (deployment_id, system_source_state_id);

-- Add reference to releases
ALTER TABLE toolset_releases
ADD CONSTRAINT toolset_releases_source_state_id_fkey
  FOREIGN KEY (source_state_id)
  REFERENCES source_states (id)
  ON DELETE RESTRICT;
```

**Verification**:
- [ ] Run migration
- [ ] Create test source states
- [ ] Verify unique constraints work

#### 1.4 Version Tool Variations
**Goal**: Enable variations to be versioned instead of edited in-place

**Schema Changes**:
```sql
-- Version the variation groups themselves
CREATE TABLE IF NOT EXISTS tool_variations_group_versions (
  id uuid NOT NULL DEFAULT generate_uuidv7(),
  group_id uuid NOT NULL,
  version BIGINT NOT NULL,

  -- Which specific variation IDs are in this version
  variation_ids uuid[] NOT NULL DEFAULT ARRAY[]::uuid[],

  predecessor_id uuid,

  created_at timestamptz NOT NULL DEFAULT clock_timestamp(),

  CONSTRAINT tool_variations_group_versions_pkey PRIMARY KEY (id),
  CONSTRAINT tool_variations_group_versions_group_id_fkey
    FOREIGN KEY (group_id)
    REFERENCES tool_variations_groups (id)
    ON DELETE CASCADE,
  CONSTRAINT tool_variations_group_versions_predecessor_id_fkey
    FOREIGN KEY (predecessor_id)
    REFERENCES tool_variations_group_versions (id)
    ON DELETE SET NULL,
  CONSTRAINT tool_variations_group_versions_group_version_key
    UNIQUE (group_id, version)
);

CREATE INDEX tool_variations_group_versions_group_id_version_idx
ON tool_variations_group_versions (group_id, version DESC);

-- Add predecessor_id to variations for versioning
ALTER TABLE tool_variations
ADD COLUMN predecessor_id uuid,
ADD COLUMN version BIGINT NOT NULL DEFAULT 1,
ADD CONSTRAINT tool_variations_predecessor_id_fkey
  FOREIGN KEY (predecessor_id)
  REFERENCES tool_variations (id)
  ON DELETE SET NULL;

-- Update unique constraint to work with versions
DROP INDEX IF EXISTS tool_variations_scoped_src_tool_urn_key;
CREATE UNIQUE INDEX tool_variations_scoped_src_tool_urn_version_key
ON tool_variations (group_id, src_tool_urn, predecessor_id)
NULLS NOT DISTINCT
WHERE deleted IS FALSE;

-- Add references to releases
ALTER TABLE toolset_releases
ADD CONSTRAINT toolset_releases_global_variations_version_id_fkey
  FOREIGN KEY (global_variations_version_id)
  REFERENCES tool_variations_group_versions (id)
  ON DELETE RESTRICT,
ADD CONSTRAINT toolset_releases_toolset_variations_version_id_fkey
  FOREIGN KEY (toolset_variations_version_id)
  REFERENCES tool_variations_group_versions (id)
  ON DELETE RESTRICT;
```

**Verification**:
- [ ] Run migration
- [ ] Create test variation with predecessor
- [ ] Create group version
- [ ] Verify version history

#### 1.5 Version Toolset Metadata
**Goal**: Version the toolset record itself (name, description, etc.)

**Schema Changes**:
```sql
-- Add versioning fields to toolsets
ALTER TABLE toolsets
ADD COLUMN predecessor_id uuid,
ADD COLUMN version BIGINT NOT NULL DEFAULT 1,
ADD COLUMN history_id uuid NOT NULL DEFAULT generate_uuidv7(),
ADD CONSTRAINT toolsets_predecessor_id_fkey
  FOREIGN KEY (predecessor_id)
  REFERENCES toolsets (id)
  ON DELETE SET NULL;

-- Track latest version by history_id
CREATE INDEX toolsets_history_id_version_idx
ON toolsets (history_id, version DESC)
WHERE deleted IS FALSE;

-- Update slug uniqueness to work with versions
DROP INDEX IF EXISTS toolsets_project_id_slug_key;
CREATE UNIQUE INDEX toolsets_project_id_slug_version_key
ON toolsets (project_id, slug, predecessor_id)
NULLS NOT DISTINCT
WHERE deleted IS FALSE AND parent_toolset_id IS NULL;
```

**Verification**:
- [ ] Run migration
- [ ] Create toolset with version 1
- [ ] Update to create version 2 with predecessor
- [ ] Verify history tracking

### Phase 2: Backend Services (Weeks 3-4)

#### 2.1 Releases Service
**Goal**: Create service to manage releases

**Files to Create**:
- `server/internal/releases/repo/queries.sql`
- `server/internal/releases/repo/models.go` (generated)
- `server/internal/releases/service.go`

**Key Functions**:
```go
// CreateRelease captures the current state and creates a release
func (s *Service) CreateRelease(ctx context.Context, toolsetID uuid.UUID, notes string) (*Release, error)

// GetRelease retrieves a specific release
func (s *Service) GetRelease(ctx context.Context, releaseID uuid.UUID) (*Release, error)

// ListReleases gets all releases for a toolset
func (s *Service) ListReleases(ctx context.Context, toolsetID uuid.UUID) ([]*Release, error)

// RollbackToRelease sets a release as the current live version
func (s *Service) RollbackToRelease(ctx context.Context, releaseID uuid.UUID) error
```

**Verification**:
- [ ] Unit tests for each function
- [ ] Integration test: create release → get release → verify state
- [ ] Integration test: create multiple releases → list → verify order

#### 2.2 Staging Toolset Management
**Goal**: Add functions to manage staging/live relationships

**Updates to `server/internal/toolsets/service.go`**:

```go
// CreateStagingVersion creates a staging copy of a toolset
func (s *Service) CreateStagingVersion(ctx context.Context, toolsetSlug string) (*Toolset, error)

// GetStagingVersion returns the staging version if it exists
func (s *Service) GetStagingVersion(ctx context.Context, toolsetSlug string) (*Toolset, error)

// PublishStagingVersion creates a release and updates the live version
func (s *Service) PublishStagingVersion(ctx context.Context, toolsetSlug string) (*Release, error)

// DiscardStagingVersion deletes the staging version
func (s *Service) DiscardStagingVersion(ctx context.Context, toolsetSlug string) error

// SwitchEditingMode toggles between iteration and staging mode
func (s *Service) SwitchEditingMode(ctx context.Context, toolsetSlug string, mode string) error
```

**Verification**:
- [ ] Unit tests with mock DB
- [ ] Integration test: create staging → modify → publish → verify live updated
- [ ] Integration test: create staging → discard → verify deleted

#### 2.3 Variation Versioning Service
**Goal**: Update variations service to create versions instead of in-place edits

**Updates to `server/internal/toolsets/variations.go`** (or new file):

```go
// CreateVariationVersion creates a new version of a variation
func (s *Service) CreateVariationVersion(ctx context.Context, variationID uuid.UUID, updates *VariationUpdates) (*Variation, error)

// GetVariationAtVersion retrieves a specific version
func (s *Service) GetVariationAtVersion(ctx context.Context, variationID uuid.UUID, version int64) (*Variation, error)

// CreateGroupVersion snapshots the current state of all variations in a group
func (s *Service) CreateGroupVersion(ctx context.Context, groupID uuid.UUID) (*GroupVersion, error)
```

**Verification**:
- [ ] Unit tests
- [ ] Integration test: update variation → verify new version created
- [ ] Integration test: get old version → verify unchanged

#### 2.4 State Capture Service
**Goal**: Utilities to capture the complete state for a release

**New file: `server/internal/releases/state.go`**:

```go
// CaptureSourceState creates a source_state record for the current project state
func CaptureSourceState(ctx context.Context, db *pgxpool.Pool, projectID uuid.UUID) (uuid.UUID, error)

// CaptureToolsetState creates a toolset_version record for the current toolset state
func CaptureToolsetState(ctx context.Context, db *pgxpool.Pool, toolsetID uuid.UUID) (uuid.UUID, error)

// CaptureVariationsState creates group version records for global and toolset variations
func CaptureVariationsState(ctx context.Context, db *pgxpool.Pool, projectID, toolsetID uuid.UUID) (globalVersionID, toolsetVersionID uuid.UUID, err error)
```

**Verification**:
- [ ] Unit tests with fixtures
- [ ] Integration test: capture state → verify all IDs captured correctly
- [ ] Integration test: modify system → capture again → verify different IDs

### Phase 3: API Endpoints (Week 5)

#### 3.1 Goa Design Updates
**Goal**: Define API surface for releases and staging

**Update `server/design/toolsets/design.go`**:

```go
Method("createStagingVersion", func() {
    Description("Create a staging copy of a toolset for testing changes")
    Payload(func() {
        Required("slug")
        Attribute("slug", Slug)
        // ... auth
    })
    Result(shared.Toolset)
})

Method("publishStagingVersion", func() {
    Description("Publish the staging version as a new release")
    Payload(func() {
        Required("slug")
        Attribute("slug", Slug)
        Attribute("notes", String, "Optional release notes")
        // ... auth
    })
    Result(shared.Release)
})

Method("listReleases", func() {
    Description("List all releases for a toolset")
    Payload(func() {
        Required("slug")
        Attribute("slug", Slug)
        // ... auth
    })
    Result(ListReleasesResult)
})

Method("getReleaseDetails", func() {
    Description("Get detailed information about a specific release")
    Payload(func() {
        Required("release_id")
        Attribute("release_id", String)
        // ... auth
    })
    Result(shared.Release)
})

Method("rollbackToRelease", func() {
    Description("Roll back to a previous release")
    Payload(func() {
        Required("release_id")
        Attribute("release_id", String)
        // ... auth
    })
    Result(shared.Toolset)
})

Method("switchEditingMode", func() {
    Description("Switch between iteration and staging mode")
    Payload(func() {
        Required("slug", "mode")
        Attribute("slug", Slug)
        Attribute("mode", String, "Either 'iteration' or 'staging'")
        // ... auth
    })
    Result(shared.Toolset)
})
```

**New types in `server/design/shared/toolset.go`**:

```go
var Release = Type("Release", func() {
    Attribute("id", String)
    Attribute("toolset_id", String)
    Attribute("release_number", Int64)
    Attribute("notes", String)
    Attribute("released_by", String)
    Attribute("created_at", String)
    // ... state IDs
    Required("id", "toolset_id", "release_number", "created_at")
})
```

**Verification**:
- [ ] Run `mise gen:goa-server`
- [ ] Verify generated types and endpoints
- [ ] Check for compilation errors

#### 3.2 Wire Up Endpoints
**Goal**: Connect Goa endpoints to service implementations

**Update `server/internal/toolsets/impl.go`**:

```go
func (s *Service) CreateStagingVersion(ctx context.Context, payload *gen.CreateStagingVersionPayload) (*types.Toolset, error) {
    // Auth checks
    // Call service method
    // Return formatted response
}

func (s *Service) PublishStagingVersion(ctx context.Context, payload *gen.PublishStagingVersionPayload) (*types.Release, error) {
    // Auth checks
    // Call releases service
    // Invalidate cache
    // Return release details
}

// ... etc for other endpoints
```

**Verification**:
- [ ] Compile successfully
- [ ] Manual test with curl/Postman
- [ ] Check error handling

### Phase 4: Frontend Integration (Weeks 6-7)

#### 4.1 API Client Generation
**Goal**: Generate TypeScript clients for new endpoints

**Commands**:
```bash
mise gen:goa-server
# Client generation happens automatically
```

**Verification**:
- [ ] Check generated client types
- [ ] Verify new hooks available

#### 4.2 Staging Toggle UI
**Goal**: Add UI to switch between staging and live views

**Files to Update**:
- `client/src/pages/Toolset/ToolsetHeader.tsx` - Add staging/live toggle
- `client/src/pages/Toolset/ToolsetSettings.tsx` - Add editing mode switcher

**Components to Create**:
- `StagingLiveTog toggle.tsx` - Switch between viewing staging vs live
- `EditingModeSwitch.tsx` - Switch between iteration and staging mode
- `StagingBanner.tsx` - Visual indicator when viewing staging version

**Verification**:
- [ ] Visual QA in dev
- [ ] Test toggle behavior
- [ ] Verify API calls made correctly

#### 4.3 Release Flow UI
**Goal**: Add UI to create and manage releases

**Components to Create**:
- `PublishChangesDialog.tsx` - Modal to publish staging changes
- `ReleaseHistoryPanel.tsx` - Show past releases
- `ReleaseDetailsView.tsx` - Detailed view of a release
- `RollbackConfirmDialog.tsx` - Confirm rollback action

**Verification**:
- [ ] Visual QA
- [ ] Test publish flow end-to-end
- [ ] Test rollback flow
- [ ] Error handling

### Phase 5: MCP Server Updates (Week 8)

#### 5.1 Update MCP Server to Use Releases
**Goal**: MCP server should serve the "live" release, not just latest toolset

**Files to Update**:
- MCP server configuration loading
- Tool discovery logic

**Changes**:
```go
// When loading toolset for MCP, check for current_release_id
func (s *MCPServer) LoadToolset(ctx context.Context, toolsetSlug string) {
    toolset := getToolset(toolsetSlug)

    if toolset.CurrentReleaseID != nil {
        // Load state from release
        release := getRelease(toolset.CurrentReleaseID)
        return loadToolsetFromRelease(release)
    } else {
        // Iteration mode - load latest
        return loadToolsetLatest(toolset)
    }
}
```

**Verification**:
- [ ] Test MCP server with iteration mode toolset
- [ ] Test MCP server with staging mode toolset
- [ ] Verify correct tools loaded in each case

#### 5.2 Staging Install URLs
**Goal**: Generate separate install URLs for staging versions

**Updates**:
- Install page should detect staging vs live
- Generate URLs like `/install/{slug}/staging` vs `/install/{slug}`

**Verification**:
- [ ] Install staging version in Claude desktop
- [ ] Verify staging tools appear
- [ ] Install live version
- [ ] Verify live tools appear

### Phase 6: Testing & Polish (Week 9)

#### 6.1 Integration Tests
**Goal**: End-to-end test coverage

**Test Scenarios**:
1. **Iteration Mode Flow**:
   - Create toolset (iteration mode)
   - Update toolset
   - Verify changes immediately visible
   - Verify no releases created

2. **Staging Mode Flow**:
   - Create toolset
   - Switch to staging mode
   - Create staging version
   - Modify staging version
   - Publish
   - Verify release created
   - Verify live version updated

3. **Rollback Flow**:
   - Create multiple releases
   - Rollback to older release
   - Verify toolset state restored
   - Verify MCP server serves old state

4. **Variation Versioning**:
   - Update variation
   - Verify new version created
   - Get old version
   - Verify unchanged

**Verification**:
- [ ] All tests pass
- [ ] Coverage >80% on new code

#### 6.2 Migration Path
**Goal**: Ensure existing toolsets work correctly

**Migration Script**:
```go
// Initialize versioning for existing toolsets
func migrateExistingToolsets(ctx context.Context, db *pgxpool.Pool) error {
    // Set history_id for all toolsets
    // Set version = 1 for all
    // Set editing_mode = 'iteration'
    // Create initial toolset_version records if missing
}
```

**Verification**:
- [ ] Test on production snapshot
- [ ] Verify all toolsets accessible
- [ ] Verify no broken foreign keys

#### 6.3 Documentation
**Goal**: Document the feature for users and developers

**Documents to Create**:
- User guide: "Using Staging and Releases"
- Developer docs: "Releases Architecture"
- API docs: New endpoints (auto-generated)
- Migration guide for existing users

**Verification**:
- [ ] Docs reviewed by team
- [ ] Examples tested

### Phase 7: Beta Testing & Rollout (Week 10)

#### 7.1 Feature Flag
**Goal**: Control rollout with feature flag

**Implementation**:
```go
// Check if org has staging feature enabled
func (s *Service) canUseStagingMode(ctx context.Context, orgID string) bool {
    return s.featureFlags.IsEnabled(orgID, "toolset_staging")
}
```

**Verification**:
- [ ] Feature flag works
- [ ] UI hidden for users without flag
- [ ] API rejects requests without flag

#### 7.2 Beta Testing
**Goal**: Internal testing before GA

**Plan**:
1. Enable for Speakeasy internal org
2. Test all flows
3. Monitor for errors
4. Gather feedback
5. Fix issues
6. Enable for select external users

**Verification**:
- [ ] No P0 issues found
- [ ] Positive feedback from testers

## Open Questions

### Q1: Rollback Scope
**Question**: Should rollbacks affect only toolset-level state, or also project-level state (deployments, global variations)?

**Options**:
1. **Toolset-only**: Safer, less confusing, but less powerful
2. **Project-level with warnings**: More powerful, but complex
3. **Hybrid**: Toolset-level rollback with option to rollback project state

**Recommendation**: Start with toolset-only (option 1) for MVP, add project-level in future if needed.

### Q2: Functions Staging
**Question**: How do we handle Gram Functions in staging mode?

**Challenge**: Same function needs to serve different versions to different toolsets.

**Options**:
1. **Defer to v2**: Initial release doesn't support versioned functions - deploying new function version affects all toolsets
2. **Version routing**: Route function calls based on toolset → release → function version
3. **Function cloning**: Copy functions for staging toolsets

**Recommendation**: Option 1 (defer) for MVP. Call this out clearly in docs.

### Q3: Release Naming
**Question**: Should we support semantic versioning or custom names for releases?

**Options**:
1. **Auto-incrementing numbers only** (v1, v2, v3...)
2. **Semantic versioning** (1.0.0, 1.1.0, 2.0.0...)
3. **Custom names** ("Holiday Release", "v1.0-beta")
4. **Hybrid** (auto-increment + optional notes)

**Recommendation**: Option 1 (auto-increment) for MVP, add custom naming later if needed.

## Risk Mitigation

### Risk 1: Breaking Existing Toolsets
**Mitigation**:
- Comprehensive migration testing
- Feature flag rollout
- Keep iteration mode as default
- Rollback plan if issues detected

### Risk 2: Performance Impact
**Concern**: Extra queries to resolve releases
**Mitigation**:
- Cache release state
- Index optimization
- Load testing before rollout

### Risk 3: UI Confusion
**Concern**: Users confused by staging/live distinction
**Mitigation**:
- Clear visual indicators
- Good onboarding UX
- Documentation
- Keep iteration mode default

### Risk 4: Data Consistency
**Concern**: Orphaned records from complex foreign keys
**Mitigation**:
- ON DELETE RESTRICT for critical paths
- Regular integrity checks
- Comprehensive tests

## Success Metrics

- [ ] 0 P0 bugs in production
- [ ] <100ms added latency for MCP calls
- [ ] ≥5 internal teams using staging mode
- [ ] ≥90% user satisfaction from beta testers
- [ ] Zero data integrity issues

## Timeline Summary

| Phase | Weeks | Description |
|-------|-------|-------------|
| Phase 1 | 1-2 | Database schema changes |
| Phase 2 | 3-4 | Backend services |
| Phase 3 | 5 | API endpoints |
| Phase 4 | 6-7 | Frontend integration |
| Phase 5 | 8 | MCP server updates |
| Phase 6 | 9 | Testing & polish |
| Phase 7 | 10 | Beta testing & rollout |

**Total: ~10 weeks for MVP**

## Next Steps

1. Review this plan with team
2. Get approval on open questions
3. Create Linear issues from Phase 1 tasks
4. Begin database schema work
5. Set up feature flag infrastructure

---

*Document Version: 1.0*
*Last Updated: 2025-11-28*
*Author: Implementation Planning*
