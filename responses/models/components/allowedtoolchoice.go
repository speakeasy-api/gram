// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/responses/internal/utils"
)

type AllowedToolChoiceType string

const (
	AllowedToolChoiceTypeAllowedTools AllowedToolChoiceType = "allowed_tools"
)

func (e AllowedToolChoiceType) ToPointer() *AllowedToolChoiceType {
	return &e
}
func (e *AllowedToolChoiceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allowed_tools":
		*e = AllowedToolChoiceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AllowedToolChoiceType: %v", v)
	}
}

type AllowedToolChoiceToolType string

const (
	AllowedToolChoiceToolTypeFunctionToolChoice AllowedToolChoiceToolType = "FunctionToolChoice"
)

type AllowedToolChoiceTool struct {
	FunctionToolChoice *FunctionToolChoice `queryParam:"inline" union:"member"`

	Type AllowedToolChoiceToolType
}

func CreateAllowedToolChoiceToolFunctionToolChoice(functionToolChoice FunctionToolChoice) AllowedToolChoiceTool {
	typ := AllowedToolChoiceToolTypeFunctionToolChoice

	return AllowedToolChoiceTool{
		FunctionToolChoice: &functionToolChoice,
		Type:               typ,
	}
}

func (u *AllowedToolChoiceTool) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var functionToolChoice FunctionToolChoice = FunctionToolChoice{}
	if err := utils.UnmarshalJSON(data, &functionToolChoice, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AllowedToolChoiceToolTypeFunctionToolChoice,
			Value: &functionToolChoice,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AllowedToolChoiceTool", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AllowedToolChoiceTool", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AllowedToolChoiceToolType)
	switch best.Type {
	case AllowedToolChoiceToolTypeFunctionToolChoice:
		u.FunctionToolChoice = best.Value.(*FunctionToolChoice)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AllowedToolChoiceTool", string(data))
}

func (u AllowedToolChoiceTool) MarshalJSON() ([]byte, error) {
	if u.FunctionToolChoice != nil {
		return utils.MarshalJSON(u.FunctionToolChoice, "", true)
	}

	return nil, errors.New("could not marshal union type AllowedToolChoiceTool: all fields are null")
}

type AllowedToolChoice struct {
	Type  *AllowedToolChoiceType  `default:"allowed_tools" json:"type"`
	Tools []AllowedToolChoiceTool `json:"tools"`
	Mode  ToolChoiceValueEnum     `json:"mode"`
}

func (a AllowedToolChoice) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AllowedToolChoice) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AllowedToolChoice) GetType() *AllowedToolChoiceType {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *AllowedToolChoice) GetTools() []AllowedToolChoiceTool {
	if a == nil {
		return []AllowedToolChoiceTool{}
	}
	return a.Tools
}

func (a *AllowedToolChoice) GetMode() ToolChoiceValueEnum {
	if a == nil {
		return ToolChoiceValueEnum("")
	}
	return a.Mode
}
