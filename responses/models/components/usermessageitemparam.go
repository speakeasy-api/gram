// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/responses/internal/utils"
	"github.com/speakeasy-api/gram/responses/optionalnullable"
)

// UserMessageItemParamType - The item type. Always `message`.
type UserMessageItemParamType string

const (
	UserMessageItemParamTypeMessage UserMessageItemParamType = "message"
)

func (e UserMessageItemParamType) ToPointer() *UserMessageItemParamType {
	return &e
}
func (e *UserMessageItemParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "message":
		*e = UserMessageItemParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UserMessageItemParamType: %v", v)
	}
}

// UserMessageItemParamRole - The message role. Always `user`.
type UserMessageItemParamRole string

const (
	UserMessageItemParamRoleUser UserMessageItemParamRole = "user"
)

func (e UserMessageItemParamRole) ToPointer() *UserMessageItemParamRole {
	return &e
}
func (e *UserMessageItemParamRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = UserMessageItemParamRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UserMessageItemParamRole: %v", v)
	}
}

type UserMessageItemParamContent1Type string

const (
	UserMessageItemParamContent1TypeInputTextContentParam           UserMessageItemParamContent1Type = "InputTextContentParam"
	UserMessageItemParamContent1TypeInputImageContentParamAutoParam UserMessageItemParamContent1Type = "InputImageContentParamAutoParam"
	UserMessageItemParamContent1TypeInputFileContentParam           UserMessageItemParamContent1Type = "InputFileContentParam"
)

// UserMessageItemParamContent1 - A piece of message content, such as text, an image, or a file.
type UserMessageItemParamContent1 struct {
	InputTextContentParam           *InputTextContentParam           `queryParam:"inline" union:"member"`
	InputImageContentParamAutoParam *InputImageContentParamAutoParam `queryParam:"inline" union:"member"`
	InputFileContentParam           *InputFileContentParam           `queryParam:"inline" union:"member"`

	Type UserMessageItemParamContent1Type
}

func CreateUserMessageItemParamContent1InputTextContentParam(inputTextContentParam InputTextContentParam) UserMessageItemParamContent1 {
	typ := UserMessageItemParamContent1TypeInputTextContentParam

	return UserMessageItemParamContent1{
		InputTextContentParam: &inputTextContentParam,
		Type:                  typ,
	}
}

func CreateUserMessageItemParamContent1InputImageContentParamAutoParam(inputImageContentParamAutoParam InputImageContentParamAutoParam) UserMessageItemParamContent1 {
	typ := UserMessageItemParamContent1TypeInputImageContentParamAutoParam

	return UserMessageItemParamContent1{
		InputImageContentParamAutoParam: &inputImageContentParamAutoParam,
		Type:                            typ,
	}
}

func CreateUserMessageItemParamContent1InputFileContentParam(inputFileContentParam InputFileContentParam) UserMessageItemParamContent1 {
	typ := UserMessageItemParamContent1TypeInputFileContentParam

	return UserMessageItemParamContent1{
		InputFileContentParam: &inputFileContentParam,
		Type:                  typ,
	}
}

func (u *UserMessageItemParamContent1) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var inputTextContentParam InputTextContentParam = InputTextContentParam{}
	if err := utils.UnmarshalJSON(data, &inputTextContentParam, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UserMessageItemParamContent1TypeInputTextContentParam,
			Value: &inputTextContentParam,
		})
	}

	var inputImageContentParamAutoParam InputImageContentParamAutoParam = InputImageContentParamAutoParam{}
	if err := utils.UnmarshalJSON(data, &inputImageContentParamAutoParam, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UserMessageItemParamContent1TypeInputImageContentParamAutoParam,
			Value: &inputImageContentParamAutoParam,
		})
	}

	var inputFileContentParam InputFileContentParam = InputFileContentParam{}
	if err := utils.UnmarshalJSON(data, &inputFileContentParam, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UserMessageItemParamContent1TypeInputFileContentParam,
			Value: &inputFileContentParam,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UserMessageItemParamContent1", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UserMessageItemParamContent1", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(UserMessageItemParamContent1Type)
	switch best.Type {
	case UserMessageItemParamContent1TypeInputTextContentParam:
		u.InputTextContentParam = best.Value.(*InputTextContentParam)
		return nil
	case UserMessageItemParamContent1TypeInputImageContentParamAutoParam:
		u.InputImageContentParamAutoParam = best.Value.(*InputImageContentParamAutoParam)
		return nil
	case UserMessageItemParamContent1TypeInputFileContentParam:
		u.InputFileContentParam = best.Value.(*InputFileContentParam)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UserMessageItemParamContent1", string(data))
}

func (u UserMessageItemParamContent1) MarshalJSON() ([]byte, error) {
	if u.InputTextContentParam != nil {
		return utils.MarshalJSON(u.InputTextContentParam, "", true)
	}

	if u.InputImageContentParamAutoParam != nil {
		return utils.MarshalJSON(u.InputImageContentParamAutoParam, "", true)
	}

	if u.InputFileContentParam != nil {
		return utils.MarshalJSON(u.InputFileContentParam, "", true)
	}

	return nil, errors.New("could not marshal union type UserMessageItemParamContent1: all fields are null")
}

type UserMessageItemParamContent2Type string

const (
	UserMessageItemParamContent2TypeArrayOfUserMessageItemParamContent1 UserMessageItemParamContent2Type = "arrayOfUserMessageItemParamContent1"
	UserMessageItemParamContent2TypeStr                                 UserMessageItemParamContent2Type = "str"
)

// UserMessageItemParamContent2 - The message content, as an array of content parts.
type UserMessageItemParamContent2 struct {
	ArrayOfUserMessageItemParamContent1 []UserMessageItemParamContent1 `queryParam:"inline" union:"member"`
	Str                                 *string                        `queryParam:"inline" union:"member"`

	Type UserMessageItemParamContent2Type
}

func CreateUserMessageItemParamContent2ArrayOfUserMessageItemParamContent1(arrayOfUserMessageItemParamContent1 []UserMessageItemParamContent1) UserMessageItemParamContent2 {
	typ := UserMessageItemParamContent2TypeArrayOfUserMessageItemParamContent1

	return UserMessageItemParamContent2{
		ArrayOfUserMessageItemParamContent1: arrayOfUserMessageItemParamContent1,
		Type:                                typ,
	}
}

func CreateUserMessageItemParamContent2Str(str string) UserMessageItemParamContent2 {
	typ := UserMessageItemParamContent2TypeStr

	return UserMessageItemParamContent2{
		Str:  &str,
		Type: typ,
	}
}

func (u *UserMessageItemParamContent2) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOfUserMessageItemParamContent1 []UserMessageItemParamContent1 = []UserMessageItemParamContent1{}
	if err := utils.UnmarshalJSON(data, &arrayOfUserMessageItemParamContent1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UserMessageItemParamContent2TypeArrayOfUserMessageItemParamContent1,
			Value: arrayOfUserMessageItemParamContent1,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UserMessageItemParamContent2TypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UserMessageItemParamContent2", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UserMessageItemParamContent2", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(UserMessageItemParamContent2Type)
	switch best.Type {
	case UserMessageItemParamContent2TypeArrayOfUserMessageItemParamContent1:
		u.ArrayOfUserMessageItemParamContent1 = best.Value.([]UserMessageItemParamContent1)
		return nil
	case UserMessageItemParamContent2TypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UserMessageItemParamContent2", string(data))
}

func (u UserMessageItemParamContent2) MarshalJSON() ([]byte, error) {
	if u.ArrayOfUserMessageItemParamContent1 != nil {
		return utils.MarshalJSON(u.ArrayOfUserMessageItemParamContent1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type UserMessageItemParamContent2: all fields are null")
}

type UserMessageItemParam struct {
	ID optionalnullable.OptionalNullable[string] `json:"id,omitzero"`
	// The item type. Always `message`.
	Type *UserMessageItemParamType `default:"message" json:"type"`
	// The message role. Always `user`.
	Role *UserMessageItemParamRole `default:"user" json:"role"`
	// The message content, as an array of content parts.
	Content UserMessageItemParamContent2              `json:"content"`
	Status  optionalnullable.OptionalNullable[string] `json:"status,omitzero"`
}

func (u UserMessageItemParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UserMessageItemParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *UserMessageItemParam) GetID() optionalnullable.OptionalNullable[string] {
	if u == nil {
		return nil
	}
	return u.ID
}

func (u *UserMessageItemParam) GetType() *UserMessageItemParamType {
	if u == nil {
		return nil
	}
	return u.Type
}

func (u *UserMessageItemParam) GetRole() *UserMessageItemParamRole {
	if u == nil {
		return nil
	}
	return u.Role
}

func (u *UserMessageItemParam) GetContent() UserMessageItemParamContent2 {
	if u == nil {
		return UserMessageItemParamContent2{}
	}
	return u.Content
}

func (u *UserMessageItemParam) GetStatus() optionalnullable.OptionalNullable[string] {
	if u == nil {
		return nil
	}
	return u.Status
}
