// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/responses/internal/utils"
)

// Object - The object type, which was always `response`.
type Object string

const (
	ObjectResponse Object = "response"
)

func (e Object) ToPointer() *Object {
	return &e
}
func (e *Object) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "response":
		*e = Object(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Object: %v", v)
	}
}

type ToolChoiceType string

const (
	ToolChoiceTypeFunctionToolChoice  ToolChoiceType = "FunctionToolChoice"
	ToolChoiceTypeToolChoiceValueEnum ToolChoiceType = "ToolChoiceValueEnum"
	ToolChoiceTypeAllowedToolChoice   ToolChoiceType = "AllowedToolChoice"
)

type ToolChoice struct {
	FunctionToolChoice  *FunctionToolChoice  `queryParam:"inline" union:"member"`
	ToolChoiceValueEnum *ToolChoiceValueEnum `queryParam:"inline" union:"member"`
	AllowedToolChoice   *AllowedToolChoice   `queryParam:"inline" union:"member"`

	Type ToolChoiceType
}

func CreateToolChoiceFunctionToolChoice(functionToolChoice FunctionToolChoice) ToolChoice {
	typ := ToolChoiceTypeFunctionToolChoice

	return ToolChoice{
		FunctionToolChoice: &functionToolChoice,
		Type:               typ,
	}
}

func CreateToolChoiceToolChoiceValueEnum(toolChoiceValueEnum ToolChoiceValueEnum) ToolChoice {
	typ := ToolChoiceTypeToolChoiceValueEnum

	return ToolChoice{
		ToolChoiceValueEnum: &toolChoiceValueEnum,
		Type:                typ,
	}
}

func CreateToolChoiceAllowedToolChoice(allowedToolChoice AllowedToolChoice) ToolChoice {
	typ := ToolChoiceTypeAllowedToolChoice

	return ToolChoice{
		AllowedToolChoice: &allowedToolChoice,
		Type:              typ,
	}
}

func (u *ToolChoice) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var functionToolChoice FunctionToolChoice = FunctionToolChoice{}
	if err := utils.UnmarshalJSON(data, &functionToolChoice, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ToolChoiceTypeFunctionToolChoice,
			Value: &functionToolChoice,
		})
	}

	var toolChoiceValueEnum ToolChoiceValueEnum = ToolChoiceValueEnum("")
	if err := utils.UnmarshalJSON(data, &toolChoiceValueEnum, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ToolChoiceTypeToolChoiceValueEnum,
			Value: &toolChoiceValueEnum,
		})
	}

	var allowedToolChoice AllowedToolChoice = AllowedToolChoice{}
	if err := utils.UnmarshalJSON(data, &allowedToolChoice, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ToolChoiceTypeAllowedToolChoice,
			Value: &allowedToolChoice,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ToolChoice", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ToolChoice", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ToolChoiceType)
	switch best.Type {
	case ToolChoiceTypeFunctionToolChoice:
		u.FunctionToolChoice = best.Value.(*FunctionToolChoice)
		return nil
	case ToolChoiceTypeToolChoiceValueEnum:
		u.ToolChoiceValueEnum = best.Value.(*ToolChoiceValueEnum)
		return nil
	case ToolChoiceTypeAllowedToolChoice:
		u.AllowedToolChoice = best.Value.(*AllowedToolChoice)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ToolChoice", string(data))
}

func (u ToolChoice) MarshalJSON() ([]byte, error) {
	if u.FunctionToolChoice != nil {
		return utils.MarshalJSON(u.FunctionToolChoice, "", true)
	}

	if u.ToolChoiceValueEnum != nil {
		return utils.MarshalJSON(u.ToolChoiceValueEnum, "", true)
	}

	if u.AllowedToolChoice != nil {
		return utils.MarshalJSON(u.AllowedToolChoice, "", true)
	}

	return nil, errors.New("could not marshal union type ToolChoice: all fields are null")
}

// ResponseResource - The complete response object that was returned by the Responses API.
type ResponseResource struct {
	// The unique ID of the response that was created.
	ID string `json:"id"`
	// The object type, which was always `response`.
	Object *Object `default:"response" json:"object"`
	// The Unix timestamp (in seconds) for when the response was created.
	CreatedAt   int64  `json:"created_at"`
	CompletedAt *int64 `json:"completed_at"`
	// The status that was set for the response.
	Status            string             `json:"status"`
	IncompleteDetails *IncompleteDetails `json:"incomplete_details"`
	// The model that generated this response.
	Model              string  `json:"model"`
	PreviousResponseID *string `json:"previous_response_id"`
	Instructions       *string `json:"instructions"`
	// The output items that were generated by the model.
	Output []ItemField `json:"output"`
	Error  *Error      `json:"error"`
	// The tools that were available to the model during response generation.
	Tools      []Tool         `json:"tools"`
	ToolChoice ToolChoice     `json:"tool_choice"`
	Truncation TruncationEnum `json:"truncation"`
	// Whether the model was allowed to call multiple tools in parallel.
	ParallelToolCalls bool      `json:"parallel_tool_calls"`
	Text              TextField `json:"text"`
	// The nucleus sampling parameter that was used for this response.
	TopP float64 `json:"top_p"`
	// The presence penalty that was used to penalize new tokens based on whether they appear in the text so far.
	PresencePenalty float64 `json:"presence_penalty"`
	// The frequency penalty that was used to penalize new tokens based on their frequency in the text so far.
	FrequencyPenalty float64 `json:"frequency_penalty"`
	// The number of most likely tokens that were returned at each position, along with their log probabilities.
	TopLogprobs int64 `json:"top_logprobs"`
	// The sampling temperature that was used for this response.
	Temperature     float64    `json:"temperature"`
	Reasoning       *Reasoning `json:"reasoning"`
	Usage           *Usage     `json:"usage"`
	MaxOutputTokens *int64     `json:"max_output_tokens"`
	MaxToolCalls    *int64     `json:"max_tool_calls"`
	// Whether this response was stored so it can be retrieved later.
	Store bool `json:"store"`
	// Whether this request was run in the background.
	Background bool `json:"background"`
	// The service tier that was used for this response.
	ServiceTier string `json:"service_tier"`
	// Developer-defined metadata that was associated with the response.
	Metadata         any     `json:"metadata"`
	SafetyIdentifier *string `json:"safety_identifier"`
	PromptCacheKey   *string `json:"prompt_cache_key"`
}

func (r ResponseResource) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ResponseResource) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ResponseResource) GetID() string {
	if r == nil {
		return ""
	}
	return r.ID
}

func (r *ResponseResource) GetObject() *Object {
	if r == nil {
		return nil
	}
	return r.Object
}

func (r *ResponseResource) GetCreatedAt() int64 {
	if r == nil {
		return 0
	}
	return r.CreatedAt
}

func (r *ResponseResource) GetCompletedAt() *int64 {
	if r == nil {
		return nil
	}
	return r.CompletedAt
}

func (r *ResponseResource) GetStatus() string {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *ResponseResource) GetIncompleteDetails() *IncompleteDetails {
	if r == nil {
		return nil
	}
	return r.IncompleteDetails
}

func (r *ResponseResource) GetModel() string {
	if r == nil {
		return ""
	}
	return r.Model
}

func (r *ResponseResource) GetPreviousResponseID() *string {
	if r == nil {
		return nil
	}
	return r.PreviousResponseID
}

func (r *ResponseResource) GetInstructions() *string {
	if r == nil {
		return nil
	}
	return r.Instructions
}

func (r *ResponseResource) GetOutput() []ItemField {
	if r == nil {
		return []ItemField{}
	}
	return r.Output
}

func (r *ResponseResource) GetError() *Error {
	if r == nil {
		return nil
	}
	return r.Error
}

func (r *ResponseResource) GetTools() []Tool {
	if r == nil {
		return []Tool{}
	}
	return r.Tools
}

func (r *ResponseResource) GetToolChoice() ToolChoice {
	if r == nil {
		return ToolChoice{}
	}
	return r.ToolChoice
}

func (r *ResponseResource) GetTruncation() TruncationEnum {
	if r == nil {
		return TruncationEnum("")
	}
	return r.Truncation
}

func (r *ResponseResource) GetParallelToolCalls() bool {
	if r == nil {
		return false
	}
	return r.ParallelToolCalls
}

func (r *ResponseResource) GetText() TextField {
	if r == nil {
		return TextField{}
	}
	return r.Text
}

func (r *ResponseResource) GetTopP() float64 {
	if r == nil {
		return 0.0
	}
	return r.TopP
}

func (r *ResponseResource) GetPresencePenalty() float64 {
	if r == nil {
		return 0.0
	}
	return r.PresencePenalty
}

func (r *ResponseResource) GetFrequencyPenalty() float64 {
	if r == nil {
		return 0.0
	}
	return r.FrequencyPenalty
}

func (r *ResponseResource) GetTopLogprobs() int64 {
	if r == nil {
		return 0
	}
	return r.TopLogprobs
}

func (r *ResponseResource) GetTemperature() float64 {
	if r == nil {
		return 0.0
	}
	return r.Temperature
}

func (r *ResponseResource) GetReasoning() *Reasoning {
	if r == nil {
		return nil
	}
	return r.Reasoning
}

func (r *ResponseResource) GetUsage() *Usage {
	if r == nil {
		return nil
	}
	return r.Usage
}

func (r *ResponseResource) GetMaxOutputTokens() *int64 {
	if r == nil {
		return nil
	}
	return r.MaxOutputTokens
}

func (r *ResponseResource) GetMaxToolCalls() *int64 {
	if r == nil {
		return nil
	}
	return r.MaxToolCalls
}

func (r *ResponseResource) GetStore() bool {
	if r == nil {
		return false
	}
	return r.Store
}

func (r *ResponseResource) GetBackground() bool {
	if r == nil {
		return false
	}
	return r.Background
}

func (r *ResponseResource) GetServiceTier() string {
	if r == nil {
		return ""
	}
	return r.ServiceTier
}

func (r *ResponseResource) GetMetadata() any {
	if r == nil {
		return nil
	}
	return r.Metadata
}

func (r *ResponseResource) GetSafetyIdentifier() *string {
	if r == nil {
		return nil
	}
	return r.SafetyIdentifier
}

func (r *ResponseResource) GetPromptCacheKey() *string {
	if r == nil {
		return nil
	}
	return r.PromptCacheKey
}
