// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/responses/internal/utils"
	"github.com/speakeasy-api/gram/responses/optionalnullable"
)

type InputType string

const (
	InputTypeStr              InputType = "str"
	InputTypeArrayOfItemParam InputType = "arrayOfItemParam"
)

// Input - Context to provide to the model for the scope of this request. May either be a string or an array of input items. If a string is provided, it is interpreted as a user message.
type Input struct {
	Str              *string     `queryParam:"inline" union:"member"`
	ArrayOfItemParam []ItemParam `queryParam:"inline" union:"member"`

	Type InputType
}

func CreateInputStr(str string) Input {
	typ := InputTypeStr

	return Input{
		Str:  &str,
		Type: typ,
	}
}

func CreateInputArrayOfItemParam(arrayOfItemParam []ItemParam) Input {
	typ := InputTypeArrayOfItemParam

	return Input{
		ArrayOfItemParam: arrayOfItemParam,
		Type:             typ,
	}
}

func (u *Input) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputTypeStr,
			Value: &str,
		})
	}

	var arrayOfItemParam []ItemParam = []ItemParam{}
	if err := utils.UnmarshalJSON(data, &arrayOfItemParam, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputTypeArrayOfItemParam,
			Value: arrayOfItemParam,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Input", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Input", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(InputType)
	switch best.Type {
	case InputTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case InputTypeArrayOfItemParam:
		u.ArrayOfItemParam = best.Value.([]ItemParam)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Input", string(data))
}

func (u Input) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfItemParam != nil {
		return utils.MarshalJSON(u.ArrayOfItemParam, "", true)
	}

	return nil, errors.New("could not marshal union type Input: all fields are null")
}

type CreateResponseBody struct {
	Model              optionalnullable.OptionalNullable[string]               `json:"model,omitzero" form:"name=model"`
	Input              optionalnullable.OptionalNullable[Input]                `json:"input,omitzero" form:"name=input,json"`
	PreviousResponseID optionalnullable.OptionalNullable[string]               `json:"previous_response_id,omitzero" form:"name=previous_response_id"`
	Include            []IncludeEnum                                           `json:"include,omitzero" form:"name=include"`
	Tools              optionalnullable.OptionalNullable[[]ResponsesToolParam] `json:"tools,omitzero" form:"name=tools,json"`
	ToolChoice         optionalnullable.OptionalNullable[ToolChoiceParam]      `json:"tool_choice,omitzero" form:"name=tool_choice,json"`
	Metadata           optionalnullable.OptionalNullable[map[string]string]    `json:"metadata,omitzero" form:"name=metadata,json"`
	Text               optionalnullable.OptionalNullable[TextParam]            `json:"text,omitzero" form:"name=text,json"`
	Temperature        optionalnullable.OptionalNullable[float64]              `json:"temperature,omitzero" form:"name=temperature"`
	TopP               optionalnullable.OptionalNullable[float64]              `json:"top_p,omitzero" form:"name=top_p"`
	PresencePenalty    optionalnullable.OptionalNullable[float64]              `json:"presence_penalty,omitzero" form:"name=presence_penalty"`
	FrequencyPenalty   optionalnullable.OptionalNullable[float64]              `json:"frequency_penalty,omitzero" form:"name=frequency_penalty"`
	ParallelToolCalls  optionalnullable.OptionalNullable[bool]                 `json:"parallel_tool_calls,omitzero" form:"name=parallel_tool_calls"`
	// Whether to stream response events as server-sent events.
	Stream        *bool                                                 `json:"stream,omitzero" form:"name=stream"`
	StreamOptions optionalnullable.OptionalNullable[StreamOptionsParam] `json:"stream_options,omitzero" form:"name=stream_options,json"`
	// Whether to run the request in the background and return immediately.
	Background       *bool                                             `json:"background,omitzero" form:"name=background"`
	MaxOutputTokens  optionalnullable.OptionalNullable[int64]          `json:"max_output_tokens,omitzero" form:"name=max_output_tokens"`
	MaxToolCalls     optionalnullable.OptionalNullable[int64]          `json:"max_tool_calls,omitzero" form:"name=max_tool_calls"`
	Reasoning        optionalnullable.OptionalNullable[ReasoningParam] `json:"reasoning,omitzero" form:"name=reasoning,json"`
	SafetyIdentifier optionalnullable.OptionalNullable[string]         `json:"safety_identifier,omitzero" form:"name=safety_identifier"`
	PromptCacheKey   optionalnullable.OptionalNullable[string]         `json:"prompt_cache_key,omitzero" form:"name=prompt_cache_key"`
	Truncation       *TruncationEnum                                   `json:"truncation,omitzero" form:"name=truncation"`
	Instructions     optionalnullable.OptionalNullable[string]         `json:"instructions,omitzero" form:"name=instructions"`
	// Whether to store the response so it can be retrieved later.
	Store       *bool                                    `json:"store,omitzero" form:"name=store"`
	ServiceTier *ServiceTierEnum                         `json:"service_tier,omitzero" form:"name=service_tier"`
	TopLogprobs optionalnullable.OptionalNullable[int64] `json:"top_logprobs,omitzero" form:"name=top_logprobs"`
}

func (c CreateResponseBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateResponseBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateResponseBody) GetModel() optionalnullable.OptionalNullable[string] {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CreateResponseBody) GetInput() optionalnullable.OptionalNullable[Input] {
	if c == nil {
		return nil
	}
	return c.Input
}

func (c *CreateResponseBody) GetPreviousResponseID() optionalnullable.OptionalNullable[string] {
	if c == nil {
		return nil
	}
	return c.PreviousResponseID
}

func (c *CreateResponseBody) GetInclude() []IncludeEnum {
	if c == nil {
		return nil
	}
	return c.Include
}

func (c *CreateResponseBody) GetTools() optionalnullable.OptionalNullable[[]ResponsesToolParam] {
	if c == nil {
		return nil
	}
	return c.Tools
}

func (c *CreateResponseBody) GetToolChoice() optionalnullable.OptionalNullable[ToolChoiceParam] {
	if c == nil {
		return nil
	}
	return c.ToolChoice
}

func (c *CreateResponseBody) GetMetadata() optionalnullable.OptionalNullable[map[string]string] {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateResponseBody) GetText() optionalnullable.OptionalNullable[TextParam] {
	if c == nil {
		return nil
	}
	return c.Text
}

func (c *CreateResponseBody) GetTemperature() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.Temperature
}

func (c *CreateResponseBody) GetTopP() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.TopP
}

func (c *CreateResponseBody) GetPresencePenalty() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.PresencePenalty
}

func (c *CreateResponseBody) GetFrequencyPenalty() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.FrequencyPenalty
}

func (c *CreateResponseBody) GetParallelToolCalls() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.ParallelToolCalls
}

func (c *CreateResponseBody) GetStream() *bool {
	if c == nil {
		return nil
	}
	return c.Stream
}

func (c *CreateResponseBody) GetStreamOptions() optionalnullable.OptionalNullable[StreamOptionsParam] {
	if c == nil {
		return nil
	}
	return c.StreamOptions
}

func (c *CreateResponseBody) GetBackground() *bool {
	if c == nil {
		return nil
	}
	return c.Background
}

func (c *CreateResponseBody) GetMaxOutputTokens() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.MaxOutputTokens
}

func (c *CreateResponseBody) GetMaxToolCalls() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.MaxToolCalls
}

func (c *CreateResponseBody) GetReasoning() optionalnullable.OptionalNullable[ReasoningParam] {
	if c == nil {
		return nil
	}
	return c.Reasoning
}

func (c *CreateResponseBody) GetSafetyIdentifier() optionalnullable.OptionalNullable[string] {
	if c == nil {
		return nil
	}
	return c.SafetyIdentifier
}

func (c *CreateResponseBody) GetPromptCacheKey() optionalnullable.OptionalNullable[string] {
	if c == nil {
		return nil
	}
	return c.PromptCacheKey
}

func (c *CreateResponseBody) GetTruncation() *TruncationEnum {
	if c == nil {
		return nil
	}
	return c.Truncation
}

func (c *CreateResponseBody) GetInstructions() optionalnullable.OptionalNullable[string] {
	if c == nil {
		return nil
	}
	return c.Instructions
}

func (c *CreateResponseBody) GetStore() *bool {
	if c == nil {
		return nil
	}
	return c.Store
}

func (c *CreateResponseBody) GetServiceTier() *ServiceTierEnum {
	if c == nil {
		return nil
	}
	return c.ServiceTier
}

func (c *CreateResponseBody) GetTopLogprobs() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.TopLogprobs
}
