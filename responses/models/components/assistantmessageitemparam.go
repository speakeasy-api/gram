// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/responses/internal/utils"
	"github.com/speakeasy-api/gram/responses/optionalnullable"
)

// AssistantMessageItemParamType - The item type. Always `message`.
type AssistantMessageItemParamType string

const (
	AssistantMessageItemParamTypeMessage AssistantMessageItemParamType = "message"
)

func (e AssistantMessageItemParamType) ToPointer() *AssistantMessageItemParamType {
	return &e
}
func (e *AssistantMessageItemParamType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "message":
		*e = AssistantMessageItemParamType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssistantMessageItemParamType: %v", v)
	}
}

// AssistantMessageItemParamRole - The role of the message author. Always `assistant`.
type AssistantMessageItemParamRole string

const (
	AssistantMessageItemParamRoleAssistant AssistantMessageItemParamRole = "assistant"
)

func (e AssistantMessageItemParamRole) ToPointer() *AssistantMessageItemParamRole {
	return &e
}
func (e *AssistantMessageItemParamRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "assistant":
		*e = AssistantMessageItemParamRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssistantMessageItemParamRole: %v", v)
	}
}

type AssistantMessageItemParamContent1Type string

const (
	AssistantMessageItemParamContent1TypeOutputTextContentParam AssistantMessageItemParamContent1Type = "OutputTextContentParam"
	AssistantMessageItemParamContent1TypeRefusalContentParam    AssistantMessageItemParamContent1Type = "RefusalContentParam"
)

// AssistantMessageItemParamContent1 - A piece of assistant message content, such as text or a refusal.
type AssistantMessageItemParamContent1 struct {
	OutputTextContentParam *OutputTextContentParam `queryParam:"inline" union:"member"`
	RefusalContentParam    *RefusalContentParam    `queryParam:"inline" union:"member"`

	Type AssistantMessageItemParamContent1Type
}

func CreateAssistantMessageItemParamContent1OutputTextContentParam(outputTextContentParam OutputTextContentParam) AssistantMessageItemParamContent1 {
	typ := AssistantMessageItemParamContent1TypeOutputTextContentParam

	return AssistantMessageItemParamContent1{
		OutputTextContentParam: &outputTextContentParam,
		Type:                   typ,
	}
}

func CreateAssistantMessageItemParamContent1RefusalContentParam(refusalContentParam RefusalContentParam) AssistantMessageItemParamContent1 {
	typ := AssistantMessageItemParamContent1TypeRefusalContentParam

	return AssistantMessageItemParamContent1{
		RefusalContentParam: &refusalContentParam,
		Type:                typ,
	}
}

func (u *AssistantMessageItemParamContent1) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var outputTextContentParam OutputTextContentParam = OutputTextContentParam{}
	if err := utils.UnmarshalJSON(data, &outputTextContentParam, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AssistantMessageItemParamContent1TypeOutputTextContentParam,
			Value: &outputTextContentParam,
		})
	}

	var refusalContentParam RefusalContentParam = RefusalContentParam{}
	if err := utils.UnmarshalJSON(data, &refusalContentParam, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AssistantMessageItemParamContent1TypeRefusalContentParam,
			Value: &refusalContentParam,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AssistantMessageItemParamContent1", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AssistantMessageItemParamContent1", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AssistantMessageItemParamContent1Type)
	switch best.Type {
	case AssistantMessageItemParamContent1TypeOutputTextContentParam:
		u.OutputTextContentParam = best.Value.(*OutputTextContentParam)
		return nil
	case AssistantMessageItemParamContent1TypeRefusalContentParam:
		u.RefusalContentParam = best.Value.(*RefusalContentParam)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AssistantMessageItemParamContent1", string(data))
}

func (u AssistantMessageItemParamContent1) MarshalJSON() ([]byte, error) {
	if u.OutputTextContentParam != nil {
		return utils.MarshalJSON(u.OutputTextContentParam, "", true)
	}

	if u.RefusalContentParam != nil {
		return utils.MarshalJSON(u.RefusalContentParam, "", true)
	}

	return nil, errors.New("could not marshal union type AssistantMessageItemParamContent1: all fields are null")
}

type AssistantMessageItemParamContent2Type string

const (
	AssistantMessageItemParamContent2TypeArrayOfAssistantMessageItemParamContent1 AssistantMessageItemParamContent2Type = "arrayOfAssistantMessageItemParamContent1"
	AssistantMessageItemParamContent2TypeStr                                      AssistantMessageItemParamContent2Type = "str"
)

// AssistantMessageItemParamContent2 - The message content, as an array of content parts.
type AssistantMessageItemParamContent2 struct {
	ArrayOfAssistantMessageItemParamContent1 []AssistantMessageItemParamContent1 `queryParam:"inline" union:"member"`
	Str                                      *string                             `queryParam:"inline" union:"member"`

	Type AssistantMessageItemParamContent2Type
}

func CreateAssistantMessageItemParamContent2ArrayOfAssistantMessageItemParamContent1(arrayOfAssistantMessageItemParamContent1 []AssistantMessageItemParamContent1) AssistantMessageItemParamContent2 {
	typ := AssistantMessageItemParamContent2TypeArrayOfAssistantMessageItemParamContent1

	return AssistantMessageItemParamContent2{
		ArrayOfAssistantMessageItemParamContent1: arrayOfAssistantMessageItemParamContent1,
		Type:                                     typ,
	}
}

func CreateAssistantMessageItemParamContent2Str(str string) AssistantMessageItemParamContent2 {
	typ := AssistantMessageItemParamContent2TypeStr

	return AssistantMessageItemParamContent2{
		Str:  &str,
		Type: typ,
	}
}

func (u *AssistantMessageItemParamContent2) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOfAssistantMessageItemParamContent1 []AssistantMessageItemParamContent1 = []AssistantMessageItemParamContent1{}
	if err := utils.UnmarshalJSON(data, &arrayOfAssistantMessageItemParamContent1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AssistantMessageItemParamContent2TypeArrayOfAssistantMessageItemParamContent1,
			Value: arrayOfAssistantMessageItemParamContent1,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AssistantMessageItemParamContent2TypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AssistantMessageItemParamContent2", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AssistantMessageItemParamContent2", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AssistantMessageItemParamContent2Type)
	switch best.Type {
	case AssistantMessageItemParamContent2TypeArrayOfAssistantMessageItemParamContent1:
		u.ArrayOfAssistantMessageItemParamContent1 = best.Value.([]AssistantMessageItemParamContent1)
		return nil
	case AssistantMessageItemParamContent2TypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AssistantMessageItemParamContent2", string(data))
}

func (u AssistantMessageItemParamContent2) MarshalJSON() ([]byte, error) {
	if u.ArrayOfAssistantMessageItemParamContent1 != nil {
		return utils.MarshalJSON(u.ArrayOfAssistantMessageItemParamContent1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type AssistantMessageItemParamContent2: all fields are null")
}

type AssistantMessageItemParam struct {
	ID optionalnullable.OptionalNullable[string] `json:"id,omitzero"`
	// The item type. Always `message`.
	Type *AssistantMessageItemParamType `default:"message" json:"type"`
	// The role of the message author. Always `assistant`.
	Role *AssistantMessageItemParamRole `default:"assistant" json:"role"`
	// The message content, as an array of content parts.
	Content AssistantMessageItemParamContent2         `json:"content"`
	Status  optionalnullable.OptionalNullable[string] `json:"status,omitzero"`
}

func (a AssistantMessageItemParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AssistantMessageItemParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AssistantMessageItemParam) GetID() optionalnullable.OptionalNullable[string] {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AssistantMessageItemParam) GetType() *AssistantMessageItemParamType {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *AssistantMessageItemParam) GetRole() *AssistantMessageItemParamRole {
	if a == nil {
		return nil
	}
	return a.Role
}

func (a *AssistantMessageItemParam) GetContent() AssistantMessageItemParamContent2 {
	if a == nil {
		return AssistantMessageItemParamContent2{}
	}
	return a.Content
}

func (a *AssistantMessageItemParam) GetStatus() optionalnullable.OptionalNullable[string] {
	if a == nil {
		return nil
	}
	return a.Status
}
