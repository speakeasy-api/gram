/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CanonicalToolAttributes,
  CanonicalToolAttributes$inboundSchema,
  CanonicalToolAttributes$Outbound,
  CanonicalToolAttributes$outboundSchema,
} from "./canonicaltoolattributes.js";
import {
  ToolVariation,
  ToolVariation$inboundSchema,
  ToolVariation$Outbound,
  ToolVariation$outboundSchema,
} from "./toolvariation.js";

/**
 * The transport type used to connect to the MCP server
 */
export const TransportType = {
  StreamableHttp: "streamable-http",
  Sse: "sse",
} as const;
/**
 * The transport type used to connect to the MCP server
 */
export type TransportType = ClosedEnum<typeof TransportType>;

/**
 * A proxy tool that references an external MCP server
 */
export type ExternalMCPToolDefinition = {
  /**
   * The original details of a tool
   */
  canonical?: CanonicalToolAttributes | undefined;
  /**
   * The canonical name of the tool. Will be the same as the name if there is no variation.
   */
  canonicalName: string;
  /**
   * Confirmation mode for the tool
   */
  confirm?: string | undefined;
  /**
   * Prompt for the confirmation
   */
  confirmPrompt?: string | undefined;
  /**
   * The creation date of the tool.
   */
  createdAt: Date;
  /**
   * The ID of the deployments_external_mcps record
   */
  deploymentExternalMcpId: string;
  /**
   * The ID of the deployment
   */
  deploymentId: string;
  /**
   * Description of the tool
   */
  description: string;
  /**
   * The ID of the tool
   */
  id: string;
  /**
   * The name of the tool
   */
  name: string;
  /**
   * The OAuth authorization endpoint URL
   */
  oauthAuthorizationEndpoint?: string | undefined;
  /**
   * The OAuth dynamic client registration endpoint URL
   */
  oauthRegistrationEndpoint?: string | undefined;
  /**
   * The OAuth scopes supported by the server
   */
  oauthScopesSupported?: Array<string> | undefined;
  /**
   * The OAuth token endpoint URL
   */
  oauthTokenEndpoint?: string | undefined;
  /**
   * OAuth version: '2.1' (MCP OAuth), '2.0' (legacy), or 'none'
   */
  oauthVersion: string;
  /**
   * The ID of the project
   */
  projectId: string;
  /**
   * The ID of the MCP registry
   */
  registryId: string;
  /**
   * The name of the external MCP server (e.g., exa)
   */
  registryServerName: string;
  /**
   * The specifier of the external MCP server (e.g., 'io.modelcontextprotocol.anonymous/exa')
   */
  registrySpecifier: string;
  /**
   * The URL to connect to the MCP server
   */
  remoteUrl: string;
  /**
   * Whether the external MCP server requires OAuth authentication
   */
  requiresOauth: boolean;
  /**
   * JSON schema for the request
   */
  schema: string;
  /**
   * Version of the schema
   */
  schemaVersion?: string | undefined;
  /**
   * The slug used for tool prefixing (e.g., github)
   */
  slug: string;
  /**
   * Summarizer for the tool
   */
  summarizer?: string | undefined;
  /**
   * The URN of this tool
   */
  toolUrn: string;
  /**
   * The transport type used to connect to the MCP server
   */
  transportType: TransportType;
  /**
   * Whether or not the tool is a proxy tool
   */
  type?: string | undefined;
  /**
   * The last update date of the tool.
   */
  updatedAt: Date;
  variation?: ToolVariation | undefined;
};

/** @internal */
export const TransportType$inboundSchema: z.ZodNativeEnum<
  typeof TransportType
> = z.nativeEnum(TransportType);

/** @internal */
export const TransportType$outboundSchema: z.ZodNativeEnum<
  typeof TransportType
> = TransportType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransportType$ {
  /** @deprecated use `TransportType$inboundSchema` instead. */
  export const inboundSchema = TransportType$inboundSchema;
  /** @deprecated use `TransportType$outboundSchema` instead. */
  export const outboundSchema = TransportType$outboundSchema;
}

/** @internal */
export const ExternalMCPToolDefinition$inboundSchema: z.ZodType<
  ExternalMCPToolDefinition,
  z.ZodTypeDef,
  unknown
> = z.object({
  canonical: CanonicalToolAttributes$inboundSchema.optional(),
  canonical_name: z.string(),
  confirm: z.string().optional(),
  confirm_prompt: z.string().optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  deployment_external_mcp_id: z.string(),
  deployment_id: z.string(),
  description: z.string(),
  id: z.string(),
  name: z.string(),
  oauth_authorization_endpoint: z.string().optional(),
  oauth_registration_endpoint: z.string().optional(),
  oauth_scopes_supported: z.array(z.string()).optional(),
  oauth_token_endpoint: z.string().optional(),
  oauth_version: z.string(),
  project_id: z.string(),
  registry_id: z.string(),
  registry_server_name: z.string(),
  registry_specifier: z.string(),
  remote_url: z.string(),
  requires_oauth: z.boolean(),
  schema: z.string(),
  schema_version: z.string().optional(),
  slug: z.string(),
  summarizer: z.string().optional(),
  tool_urn: z.string(),
  transport_type: TransportType$inboundSchema,
  type: z.string().optional(),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  variation: ToolVariation$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "canonical_name": "canonicalName",
    "confirm_prompt": "confirmPrompt",
    "created_at": "createdAt",
    "deployment_external_mcp_id": "deploymentExternalMcpId",
    "deployment_id": "deploymentId",
    "oauth_authorization_endpoint": "oauthAuthorizationEndpoint",
    "oauth_registration_endpoint": "oauthRegistrationEndpoint",
    "oauth_scopes_supported": "oauthScopesSupported",
    "oauth_token_endpoint": "oauthTokenEndpoint",
    "oauth_version": "oauthVersion",
    "project_id": "projectId",
    "registry_id": "registryId",
    "registry_server_name": "registryServerName",
    "registry_specifier": "registrySpecifier",
    "remote_url": "remoteUrl",
    "requires_oauth": "requiresOauth",
    "schema_version": "schemaVersion",
    "tool_urn": "toolUrn",
    "transport_type": "transportType",
    "updated_at": "updatedAt",
  });
});

/** @internal */
export type ExternalMCPToolDefinition$Outbound = {
  canonical?: CanonicalToolAttributes$Outbound | undefined;
  canonical_name: string;
  confirm?: string | undefined;
  confirm_prompt?: string | undefined;
  created_at: string;
  deployment_external_mcp_id: string;
  deployment_id: string;
  description: string;
  id: string;
  name: string;
  oauth_authorization_endpoint?: string | undefined;
  oauth_registration_endpoint?: string | undefined;
  oauth_scopes_supported?: Array<string> | undefined;
  oauth_token_endpoint?: string | undefined;
  oauth_version: string;
  project_id: string;
  registry_id: string;
  registry_server_name: string;
  registry_specifier: string;
  remote_url: string;
  requires_oauth: boolean;
  schema: string;
  schema_version?: string | undefined;
  slug: string;
  summarizer?: string | undefined;
  tool_urn: string;
  transport_type: string;
  type?: string | undefined;
  updated_at: string;
  variation?: ToolVariation$Outbound | undefined;
};

/** @internal */
export const ExternalMCPToolDefinition$outboundSchema: z.ZodType<
  ExternalMCPToolDefinition$Outbound,
  z.ZodTypeDef,
  ExternalMCPToolDefinition
> = z.object({
  canonical: CanonicalToolAttributes$outboundSchema.optional(),
  canonicalName: z.string(),
  confirm: z.string().optional(),
  confirmPrompt: z.string().optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  deploymentExternalMcpId: z.string(),
  deploymentId: z.string(),
  description: z.string(),
  id: z.string(),
  name: z.string(),
  oauthAuthorizationEndpoint: z.string().optional(),
  oauthRegistrationEndpoint: z.string().optional(),
  oauthScopesSupported: z.array(z.string()).optional(),
  oauthTokenEndpoint: z.string().optional(),
  oauthVersion: z.string(),
  projectId: z.string(),
  registryId: z.string(),
  registryServerName: z.string(),
  registrySpecifier: z.string(),
  remoteUrl: z.string(),
  requiresOauth: z.boolean(),
  schema: z.string(),
  schemaVersion: z.string().optional(),
  slug: z.string(),
  summarizer: z.string().optional(),
  toolUrn: z.string(),
  transportType: TransportType$outboundSchema,
  type: z.string().optional(),
  updatedAt: z.date().transform(v => v.toISOString()),
  variation: ToolVariation$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    canonicalName: "canonical_name",
    confirmPrompt: "confirm_prompt",
    createdAt: "created_at",
    deploymentExternalMcpId: "deployment_external_mcp_id",
    deploymentId: "deployment_id",
    oauthAuthorizationEndpoint: "oauth_authorization_endpoint",
    oauthRegistrationEndpoint: "oauth_registration_endpoint",
    oauthScopesSupported: "oauth_scopes_supported",
    oauthTokenEndpoint: "oauth_token_endpoint",
    oauthVersion: "oauth_version",
    projectId: "project_id",
    registryId: "registry_id",
    registryServerName: "registry_server_name",
    registrySpecifier: "registry_specifier",
    remoteUrl: "remote_url",
    requiresOauth: "requires_oauth",
    schemaVersion: "schema_version",
    toolUrn: "tool_urn",
    transportType: "transport_type",
    updatedAt: "updated_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExternalMCPToolDefinition$ {
  /** @deprecated use `ExternalMCPToolDefinition$inboundSchema` instead. */
  export const inboundSchema = ExternalMCPToolDefinition$inboundSchema;
  /** @deprecated use `ExternalMCPToolDefinition$outboundSchema` instead. */
  export const outboundSchema = ExternalMCPToolDefinition$outboundSchema;
  /** @deprecated use `ExternalMCPToolDefinition$Outbound` instead. */
  export type Outbound = ExternalMCPToolDefinition$Outbound;
}

export function externalMCPToolDefinitionToJSON(
  externalMCPToolDefinition: ExternalMCPToolDefinition,
): string {
  return JSON.stringify(
    ExternalMCPToolDefinition$outboundSchema.parse(externalMCPToolDefinition),
  );
}

export function externalMCPToolDefinitionFromJSON(
  jsonString: string,
): SafeParseResult<ExternalMCPToolDefinition, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExternalMCPToolDefinition$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExternalMCPToolDefinition' from JSON`,
  );
}
