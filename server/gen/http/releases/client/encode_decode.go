// Code generated by goa v3.22.6, DO NOT EDIT.
//
// releases HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"

	releases "github.com/speakeasy-api/gram/server/gen/releases"
	types "github.com/speakeasy-api/gram/server/gen/types"
	goahttp "goa.design/goa/v3/http"
)

// BuildCreateReleaseRequest instantiates a HTTP request object with method and
// path set to call the "releases" service "createRelease" endpoint
func (c *Client) BuildCreateReleaseRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateReleaseReleasesPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("releases", "createRelease", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateReleaseRequest returns an encoder for requests sent to the
// releases createRelease server.
func EncodeCreateReleaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*releases.CreateReleasePayload)
		if !ok {
			return goahttp.ErrInvalidType("releases", "createRelease", "*releases.CreateReleasePayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ApikeyToken != nil {
			head := *p.ApikeyToken
			req.Header.Set("Gram-Key", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		body := NewCreateReleaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("releases", "createRelease", err)
		}
		return nil
	}
}

// DecodeCreateReleaseResponse returns a decoder for responses returned by the
// releases createRelease endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeCreateReleaseResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - "conflict" (type *goa.ServiceError): http.StatusConflict
//   - "unsupported_media" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//   - "invalid" (type *goa.ServiceError): http.StatusUnprocessableEntity
//   - "invariant_violation" (type *goa.ServiceError): http.StatusInternalServerError
//   - "unexpected" (type *goa.ServiceError): http.StatusInternalServerError
//   - "gateway_error" (type *goa.ServiceError): http.StatusBadGateway
//   - error: internal error
func DecodeCreateReleaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CreateReleaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			res := NewCreateReleaseToolsetReleaseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body CreateReleaseUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body CreateReleaseForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseForbidden(&body)
		case http.StatusBadRequest:
			var (
				body CreateReleaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseBadRequest(&body)
		case http.StatusNotFound:
			var (
				body CreateReleaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseNotFound(&body)
		case http.StatusConflict:
			var (
				body CreateReleaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseConflict(&body)
		case http.StatusUnsupportedMediaType:
			var (
				body CreateReleaseUnsupportedMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseUnsupportedMediaResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseUnsupportedMedia(&body)
		case http.StatusUnprocessableEntity:
			var (
				body CreateReleaseInvalidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseInvalidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseInvalid(&body)
		case http.StatusInternalServerError:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invariant_violation":
				var (
					body CreateReleaseInvariantViolationResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
				}
				err = ValidateCreateReleaseInvariantViolationResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "createRelease", err)
				}
				return nil, NewCreateReleaseInvariantViolation(&body)
			case "unexpected":
				var (
					body CreateReleaseUnexpectedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
				}
				err = ValidateCreateReleaseUnexpectedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "createRelease", err)
				}
				return nil, NewCreateReleaseUnexpected(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("releases", "createRelease", resp.StatusCode, string(body))
			}
		case http.StatusBadGateway:
			var (
				body CreateReleaseGatewayErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "createRelease", err)
			}
			err = ValidateCreateReleaseGatewayErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "createRelease", err)
			}
			return nil, NewCreateReleaseGatewayError(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("releases", "createRelease", resp.StatusCode, string(body))
		}
	}
}

// BuildListReleasesRequest instantiates a HTTP request object with method and
// path set to call the "releases" service "listReleases" endpoint
func (c *Client) BuildListReleasesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListReleasesReleasesPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("releases", "listReleases", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListReleasesRequest returns an encoder for requests sent to the
// releases listReleases server.
func EncodeListReleasesRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*releases.ListReleasesPayload)
		if !ok {
			return goahttp.ErrInvalidType("releases", "listReleases", "*releases.ListReleasesPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ApikeyToken != nil {
			head := *p.ApikeyToken
			req.Header.Set("Gram-Key", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		values := req.URL.Query()
		values.Add("toolset_slug", string(p.ToolsetSlug))
		if p.Limit != nil {
			values.Add("limit", fmt.Sprintf("%v", *p.Limit))
		}
		if p.Offset != nil {
			values.Add("offset", fmt.Sprintf("%v", *p.Offset))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListReleasesResponse returns a decoder for responses returned by the
// releases listReleases endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeListReleasesResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - "conflict" (type *goa.ServiceError): http.StatusConflict
//   - "unsupported_media" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//   - "invalid" (type *goa.ServiceError): http.StatusUnprocessableEntity
//   - "invariant_violation" (type *goa.ServiceError): http.StatusInternalServerError
//   - "unexpected" (type *goa.ServiceError): http.StatusInternalServerError
//   - "gateway_error" (type *goa.ServiceError): http.StatusBadGateway
//   - error: internal error
func DecodeListReleasesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListReleasesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			res := NewListReleasesResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ListReleasesUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body ListReleasesForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesForbidden(&body)
		case http.StatusBadRequest:
			var (
				body ListReleasesBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesBadRequest(&body)
		case http.StatusNotFound:
			var (
				body ListReleasesNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesNotFound(&body)
		case http.StatusConflict:
			var (
				body ListReleasesConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesConflict(&body)
		case http.StatusUnsupportedMediaType:
			var (
				body ListReleasesUnsupportedMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesUnsupportedMediaResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesUnsupportedMedia(&body)
		case http.StatusUnprocessableEntity:
			var (
				body ListReleasesInvalidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesInvalidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesInvalid(&body)
		case http.StatusInternalServerError:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invariant_violation":
				var (
					body ListReleasesInvariantViolationResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
				}
				err = ValidateListReleasesInvariantViolationResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "listReleases", err)
				}
				return nil, NewListReleasesInvariantViolation(&body)
			case "unexpected":
				var (
					body ListReleasesUnexpectedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
				}
				err = ValidateListReleasesUnexpectedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "listReleases", err)
				}
				return nil, NewListReleasesUnexpected(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("releases", "listReleases", resp.StatusCode, string(body))
			}
		case http.StatusBadGateway:
			var (
				body ListReleasesGatewayErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "listReleases", err)
			}
			err = ValidateListReleasesGatewayErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "listReleases", err)
			}
			return nil, NewListReleasesGatewayError(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("releases", "listReleases", resp.StatusCode, string(body))
		}
	}
}

// BuildGetReleaseRequest instantiates a HTTP request object with method and
// path set to call the "releases" service "getRelease" endpoint
func (c *Client) BuildGetReleaseRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetReleaseReleasesPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("releases", "getRelease", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetReleaseRequest returns an encoder for requests sent to the releases
// getRelease server.
func EncodeGetReleaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*releases.GetReleasePayload)
		if !ok {
			return goahttp.ErrInvalidType("releases", "getRelease", "*releases.GetReleasePayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ApikeyToken != nil {
			head := *p.ApikeyToken
			req.Header.Set("Gram-Key", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		values := req.URL.Query()
		values.Add("release_id", p.ReleaseID)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetReleaseResponse returns a decoder for responses returned by the
// releases getRelease endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetReleaseResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - "conflict" (type *goa.ServiceError): http.StatusConflict
//   - "unsupported_media" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//   - "invalid" (type *goa.ServiceError): http.StatusUnprocessableEntity
//   - "invariant_violation" (type *goa.ServiceError): http.StatusInternalServerError
//   - "unexpected" (type *goa.ServiceError): http.StatusInternalServerError
//   - "gateway_error" (type *goa.ServiceError): http.StatusBadGateway
//   - error: internal error
func DecodeGetReleaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetReleaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			res := NewGetReleaseToolsetReleaseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body GetReleaseUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body GetReleaseForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseForbidden(&body)
		case http.StatusBadRequest:
			var (
				body GetReleaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseBadRequest(&body)
		case http.StatusNotFound:
			var (
				body GetReleaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseNotFound(&body)
		case http.StatusConflict:
			var (
				body GetReleaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseConflict(&body)
		case http.StatusUnsupportedMediaType:
			var (
				body GetReleaseUnsupportedMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseUnsupportedMediaResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseUnsupportedMedia(&body)
		case http.StatusUnprocessableEntity:
			var (
				body GetReleaseInvalidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseInvalidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseInvalid(&body)
		case http.StatusInternalServerError:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invariant_violation":
				var (
					body GetReleaseInvariantViolationResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
				}
				err = ValidateGetReleaseInvariantViolationResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "getRelease", err)
				}
				return nil, NewGetReleaseInvariantViolation(&body)
			case "unexpected":
				var (
					body GetReleaseUnexpectedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
				}
				err = ValidateGetReleaseUnexpectedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "getRelease", err)
				}
				return nil, NewGetReleaseUnexpected(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("releases", "getRelease", resp.StatusCode, string(body))
			}
		case http.StatusBadGateway:
			var (
				body GetReleaseGatewayErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getRelease", err)
			}
			err = ValidateGetReleaseGatewayErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getRelease", err)
			}
			return nil, NewGetReleaseGatewayError(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("releases", "getRelease", resp.StatusCode, string(body))
		}
	}
}

// BuildGetReleaseByNumberRequest instantiates a HTTP request object with
// method and path set to call the "releases" service "getReleaseByNumber"
// endpoint
func (c *Client) BuildGetReleaseByNumberRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetReleaseByNumberReleasesPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("releases", "getReleaseByNumber", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetReleaseByNumberRequest returns an encoder for requests sent to the
// releases getReleaseByNumber server.
func EncodeGetReleaseByNumberRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*releases.GetReleaseByNumberPayload)
		if !ok {
			return goahttp.ErrInvalidType("releases", "getReleaseByNumber", "*releases.GetReleaseByNumberPayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ApikeyToken != nil {
			head := *p.ApikeyToken
			req.Header.Set("Gram-Key", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		values := req.URL.Query()
		values.Add("toolset_slug", string(p.ToolsetSlug))
		values.Add("release_number", fmt.Sprintf("%v", p.ReleaseNumber))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetReleaseByNumberResponse returns a decoder for responses returned by
// the releases getReleaseByNumber endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetReleaseByNumberResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - "conflict" (type *goa.ServiceError): http.StatusConflict
//   - "unsupported_media" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//   - "invalid" (type *goa.ServiceError): http.StatusUnprocessableEntity
//   - "invariant_violation" (type *goa.ServiceError): http.StatusInternalServerError
//   - "unexpected" (type *goa.ServiceError): http.StatusInternalServerError
//   - "gateway_error" (type *goa.ServiceError): http.StatusBadGateway
//   - error: internal error
func DecodeGetReleaseByNumberResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetReleaseByNumberResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			res := NewGetReleaseByNumberToolsetReleaseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body GetReleaseByNumberUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body GetReleaseByNumberForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberForbidden(&body)
		case http.StatusBadRequest:
			var (
				body GetReleaseByNumberBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberBadRequest(&body)
		case http.StatusNotFound:
			var (
				body GetReleaseByNumberNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberNotFound(&body)
		case http.StatusConflict:
			var (
				body GetReleaseByNumberConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberConflict(&body)
		case http.StatusUnsupportedMediaType:
			var (
				body GetReleaseByNumberUnsupportedMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberUnsupportedMediaResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberUnsupportedMedia(&body)
		case http.StatusUnprocessableEntity:
			var (
				body GetReleaseByNumberInvalidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberInvalidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberInvalid(&body)
		case http.StatusInternalServerError:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invariant_violation":
				var (
					body GetReleaseByNumberInvariantViolationResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
				}
				err = ValidateGetReleaseByNumberInvariantViolationResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
				}
				return nil, NewGetReleaseByNumberInvariantViolation(&body)
			case "unexpected":
				var (
					body GetReleaseByNumberUnexpectedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
				}
				err = ValidateGetReleaseByNumberUnexpectedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
				}
				return nil, NewGetReleaseByNumberUnexpected(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("releases", "getReleaseByNumber", resp.StatusCode, string(body))
			}
		case http.StatusBadGateway:
			var (
				body GetReleaseByNumberGatewayErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getReleaseByNumber", err)
			}
			err = ValidateGetReleaseByNumberGatewayErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getReleaseByNumber", err)
			}
			return nil, NewGetReleaseByNumberGatewayError(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("releases", "getReleaseByNumber", resp.StatusCode, string(body))
		}
	}
}

// BuildGetLatestReleaseRequest instantiates a HTTP request object with method
// and path set to call the "releases" service "getLatestRelease" endpoint
func (c *Client) BuildGetLatestReleaseRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetLatestReleaseReleasesPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("releases", "getLatestRelease", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetLatestReleaseRequest returns an encoder for requests sent to the
// releases getLatestRelease server.
func EncodeGetLatestReleaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*releases.GetLatestReleasePayload)
		if !ok {
			return goahttp.ErrInvalidType("releases", "getLatestRelease", "*releases.GetLatestReleasePayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ApikeyToken != nil {
			head := *p.ApikeyToken
			req.Header.Set("Gram-Key", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		values := req.URL.Query()
		values.Add("toolset_slug", string(p.ToolsetSlug))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetLatestReleaseResponse returns a decoder for responses returned by
// the releases getLatestRelease endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetLatestReleaseResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - "conflict" (type *goa.ServiceError): http.StatusConflict
//   - "unsupported_media" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//   - "invalid" (type *goa.ServiceError): http.StatusUnprocessableEntity
//   - "invariant_violation" (type *goa.ServiceError): http.StatusInternalServerError
//   - "unexpected" (type *goa.ServiceError): http.StatusInternalServerError
//   - "gateway_error" (type *goa.ServiceError): http.StatusBadGateway
//   - error: internal error
func DecodeGetLatestReleaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetLatestReleaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			res := NewGetLatestReleaseToolsetReleaseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body GetLatestReleaseUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body GetLatestReleaseForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseForbidden(&body)
		case http.StatusBadRequest:
			var (
				body GetLatestReleaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseBadRequest(&body)
		case http.StatusNotFound:
			var (
				body GetLatestReleaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseNotFound(&body)
		case http.StatusConflict:
			var (
				body GetLatestReleaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseConflict(&body)
		case http.StatusUnsupportedMediaType:
			var (
				body GetLatestReleaseUnsupportedMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseUnsupportedMediaResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseUnsupportedMedia(&body)
		case http.StatusUnprocessableEntity:
			var (
				body GetLatestReleaseInvalidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseInvalidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseInvalid(&body)
		case http.StatusInternalServerError:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invariant_violation":
				var (
					body GetLatestReleaseInvariantViolationResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
				}
				err = ValidateGetLatestReleaseInvariantViolationResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
				}
				return nil, NewGetLatestReleaseInvariantViolation(&body)
			case "unexpected":
				var (
					body GetLatestReleaseUnexpectedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
				}
				err = ValidateGetLatestReleaseUnexpectedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
				}
				return nil, NewGetLatestReleaseUnexpected(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("releases", "getLatestRelease", resp.StatusCode, string(body))
			}
		case http.StatusBadGateway:
			var (
				body GetLatestReleaseGatewayErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "getLatestRelease", err)
			}
			err = ValidateGetLatestReleaseGatewayErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "getLatestRelease", err)
			}
			return nil, NewGetLatestReleaseGatewayError(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("releases", "getLatestRelease", resp.StatusCode, string(body))
		}
	}
}

// BuildRollbackToReleaseRequest instantiates a HTTP request object with method
// and path set to call the "releases" service "rollbackToRelease" endpoint
func (c *Client) BuildRollbackToReleaseRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RollbackToReleaseReleasesPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("releases", "rollbackToRelease", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRollbackToReleaseRequest returns an encoder for requests sent to the
// releases rollbackToRelease server.
func EncodeRollbackToReleaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*releases.RollbackToReleasePayload)
		if !ok {
			return goahttp.ErrInvalidType("releases", "rollbackToRelease", "*releases.RollbackToReleasePayload", v)
		}
		if p.SessionToken != nil {
			head := *p.SessionToken
			req.Header.Set("Gram-Session", head)
		}
		if p.ApikeyToken != nil {
			head := *p.ApikeyToken
			req.Header.Set("Gram-Key", head)
		}
		if p.ProjectSlugInput != nil {
			head := *p.ProjectSlugInput
			req.Header.Set("Gram-Project", head)
		}
		body := NewRollbackToReleaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("releases", "rollbackToRelease", err)
		}
		return nil
	}
}

// DecodeRollbackToReleaseResponse returns a decoder for responses returned by
// the releases rollbackToRelease endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeRollbackToReleaseResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//   - "not_found" (type *goa.ServiceError): http.StatusNotFound
//   - "conflict" (type *goa.ServiceError): http.StatusConflict
//   - "unsupported_media" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//   - "invalid" (type *goa.ServiceError): http.StatusUnprocessableEntity
//   - "invariant_violation" (type *goa.ServiceError): http.StatusInternalServerError
//   - "unexpected" (type *goa.ServiceError): http.StatusInternalServerError
//   - "gateway_error" (type *goa.ServiceError): http.StatusBadGateway
//   - error: internal error
func DecodeRollbackToReleaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RollbackToReleaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			res := NewRollbackToReleaseToolsetOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body RollbackToReleaseUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body RollbackToReleaseForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseForbidden(&body)
		case http.StatusBadRequest:
			var (
				body RollbackToReleaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseBadRequest(&body)
		case http.StatusNotFound:
			var (
				body RollbackToReleaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseNotFound(&body)
		case http.StatusConflict:
			var (
				body RollbackToReleaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseConflict(&body)
		case http.StatusUnsupportedMediaType:
			var (
				body RollbackToReleaseUnsupportedMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseUnsupportedMediaResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseUnsupportedMedia(&body)
		case http.StatusUnprocessableEntity:
			var (
				body RollbackToReleaseInvalidResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseInvalidResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseInvalid(&body)
		case http.StatusInternalServerError:
			en := resp.Header.Get("goa-error")
			switch en {
			case "invariant_violation":
				var (
					body RollbackToReleaseInvariantViolationResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
				}
				err = ValidateRollbackToReleaseInvariantViolationResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
				}
				return nil, NewRollbackToReleaseInvariantViolation(&body)
			case "unexpected":
				var (
					body RollbackToReleaseUnexpectedResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
				}
				err = ValidateRollbackToReleaseUnexpectedResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
				}
				return nil, NewRollbackToReleaseUnexpected(&body)
			default:
				body, _ := io.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("releases", "rollbackToRelease", resp.StatusCode, string(body))
			}
		case http.StatusBadGateway:
			var (
				body RollbackToReleaseGatewayErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("releases", "rollbackToRelease", err)
			}
			err = ValidateRollbackToReleaseGatewayErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("releases", "rollbackToRelease", err)
			}
			return nil, NewRollbackToReleaseGatewayError(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("releases", "rollbackToRelease", resp.StatusCode, string(body))
		}
	}
}

// unmarshalToolsetReleaseResponseBodyToTypesToolsetRelease builds a value of
// type *types.ToolsetRelease from a value of type *ToolsetReleaseResponseBody.
func unmarshalToolsetReleaseResponseBodyToTypesToolsetRelease(v *ToolsetReleaseResponseBody) *types.ToolsetRelease {
	res := &types.ToolsetRelease{
		ID:                         *v.ID,
		ToolsetID:                  *v.ToolsetID,
		ReleaseNumber:              *v.ReleaseNumber,
		SourceStateID:              v.SourceStateID,
		ToolsetVersionID:           *v.ToolsetVersionID,
		GlobalVariationsVersionID:  v.GlobalVariationsVersionID,
		ToolsetVariationsVersionID: v.ToolsetVariationsVersionID,
		Notes:                      v.Notes,
		ReleasedByUserID:           *v.ReleasedByUserID,
		CreatedAt:                  *v.CreatedAt,
	}

	return res
}

// unmarshalSecurityVariableResponseBodyToTypesSecurityVariable builds a value
// of type *types.SecurityVariable from a value of type
// *SecurityVariableResponseBody.
func unmarshalSecurityVariableResponseBodyToTypesSecurityVariable(v *SecurityVariableResponseBody) *types.SecurityVariable {
	if v == nil {
		return nil
	}
	res := &types.SecurityVariable{
		Type:         v.Type,
		Name:         *v.Name,
		InPlacement:  *v.InPlacement,
		Scheme:       *v.Scheme,
		BearerFormat: v.BearerFormat,
		OauthFlows:   v.OauthFlows,
	}
	if v.OauthTypes != nil {
		res.OauthTypes = make([]string, len(v.OauthTypes))
		for i, val := range v.OauthTypes {
			res.OauthTypes[i] = val
		}
	}
	res.EnvVariables = make([]string, len(v.EnvVariables))
	for i, val := range v.EnvVariables {
		res.EnvVariables[i] = val
	}

	return res
}

// unmarshalServerVariableResponseBodyToTypesServerVariable builds a value of
// type *types.ServerVariable from a value of type *ServerVariableResponseBody.
func unmarshalServerVariableResponseBodyToTypesServerVariable(v *ServerVariableResponseBody) *types.ServerVariable {
	if v == nil {
		return nil
	}
	res := &types.ServerVariable{
		Description: *v.Description,
	}
	res.EnvVariables = make([]string, len(v.EnvVariables))
	for i, val := range v.EnvVariables {
		res.EnvVariables[i] = val
	}

	return res
}

// unmarshalFunctionEnvironmentVariableResponseBodyToTypesFunctionEnvironmentVariable
// builds a value of type *types.FunctionEnvironmentVariable from a value of
// type *FunctionEnvironmentVariableResponseBody.
func unmarshalFunctionEnvironmentVariableResponseBodyToTypesFunctionEnvironmentVariable(v *FunctionEnvironmentVariableResponseBody) *types.FunctionEnvironmentVariable {
	if v == nil {
		return nil
	}
	res := &types.FunctionEnvironmentVariable{
		Description: v.Description,
		Name:        *v.Name,
	}

	return res
}

// unmarshalToolResponseBodyToTypesTool builds a value of type *types.Tool from
// a value of type *ToolResponseBody.
func unmarshalToolResponseBodyToTypesTool(v *ToolResponseBody) *types.Tool {
	res := &types.Tool{}
	if v.HTTPToolDefinition != nil {
		res.HTTPToolDefinition = unmarshalHTTPToolDefinitionResponseBodyToTypesHTTPToolDefinition(v.HTTPToolDefinition)
	}
	if v.FunctionToolDefinition != nil {
		res.FunctionToolDefinition = unmarshalFunctionToolDefinitionResponseBodyToTypesFunctionToolDefinition(v.FunctionToolDefinition)
	}
	if v.PromptTemplate != nil {
		res.PromptTemplate = unmarshalPromptTemplateResponseBodyToTypesPromptTemplate(v.PromptTemplate)
	}

	return res
}

// unmarshalHTTPToolDefinitionResponseBodyToTypesHTTPToolDefinition builds a
// value of type *types.HTTPToolDefinition from a value of type
// *HTTPToolDefinitionResponseBody.
func unmarshalHTTPToolDefinitionResponseBodyToTypesHTTPToolDefinition(v *HTTPToolDefinitionResponseBody) *types.HTTPToolDefinition {
	if v == nil {
		return nil
	}
	res := &types.HTTPToolDefinition{
		DeploymentID:        *v.DeploymentID,
		AssetID:             *v.AssetID,
		Summary:             *v.Summary,
		Openapiv3DocumentID: v.Openapiv3DocumentID,
		Openapiv3Operation:  v.Openapiv3Operation,
		Security:            v.Security,
		DefaultServerURL:    v.DefaultServerURL,
		HTTPMethod:          *v.HTTPMethod,
		Path:                *v.Path,
		PackageName:         v.PackageName,
		ID:                  *v.ID,
		ToolUrn:             *v.ToolUrn,
		ProjectID:           *v.ProjectID,
		Name:                *v.Name,
		CanonicalName:       *v.CanonicalName,
		Description:         *v.Description,
		SchemaVersion:       v.SchemaVersion,
		Schema:              *v.Schema,
		Confirm:             v.Confirm,
		ConfirmPrompt:       v.ConfirmPrompt,
		Summarizer:          v.Summarizer,
		CreatedAt:           *v.CreatedAt,
		UpdatedAt:           *v.UpdatedAt,
	}
	if v.ResponseFilter != nil {
		res.ResponseFilter = unmarshalResponseFilterResponseBodyToTypesResponseFilter(v.ResponseFilter)
	}
	res.Tags = make([]string, len(v.Tags))
	for i, val := range v.Tags {
		res.Tags[i] = val
	}
	if v.Canonical != nil {
		res.Canonical = unmarshalCanonicalToolAttributesResponseBodyToTypesCanonicalToolAttributes(v.Canonical)
	}
	if v.Variation != nil {
		res.Variation = unmarshalToolVariationResponseBodyToTypesToolVariation(v.Variation)
	}

	return res
}

// unmarshalResponseFilterResponseBodyToTypesResponseFilter builds a value of
// type *types.ResponseFilter from a value of type *ResponseFilterResponseBody.
func unmarshalResponseFilterResponseBodyToTypesResponseFilter(v *ResponseFilterResponseBody) *types.ResponseFilter {
	if v == nil {
		return nil
	}
	res := &types.ResponseFilter{
		Type: *v.Type,
	}
	res.StatusCodes = make([]string, len(v.StatusCodes))
	for i, val := range v.StatusCodes {
		res.StatusCodes[i] = val
	}
	res.ContentTypes = make([]string, len(v.ContentTypes))
	for i, val := range v.ContentTypes {
		res.ContentTypes[i] = val
	}

	return res
}

// unmarshalCanonicalToolAttributesResponseBodyToTypesCanonicalToolAttributes
// builds a value of type *types.CanonicalToolAttributes from a value of type
// *CanonicalToolAttributesResponseBody.
func unmarshalCanonicalToolAttributesResponseBodyToTypesCanonicalToolAttributes(v *CanonicalToolAttributesResponseBody) *types.CanonicalToolAttributes {
	if v == nil {
		return nil
	}
	res := &types.CanonicalToolAttributes{
		VariationID:   *v.VariationID,
		Name:          *v.Name,
		Description:   *v.Description,
		Confirm:       v.Confirm,
		ConfirmPrompt: v.ConfirmPrompt,
		Summarizer:    v.Summarizer,
	}

	return res
}

// unmarshalToolVariationResponseBodyToTypesToolVariation builds a value of
// type *types.ToolVariation from a value of type *ToolVariationResponseBody.
func unmarshalToolVariationResponseBodyToTypesToolVariation(v *ToolVariationResponseBody) *types.ToolVariation {
	if v == nil {
		return nil
	}
	res := &types.ToolVariation{
		ID:            *v.ID,
		GroupID:       *v.GroupID,
		SrcToolUrn:    *v.SrcToolUrn,
		SrcToolName:   *v.SrcToolName,
		Confirm:       v.Confirm,
		ConfirmPrompt: v.ConfirmPrompt,
		Name:          v.Name,
		Description:   v.Description,
		Summarizer:    v.Summarizer,
		CreatedAt:     *v.CreatedAt,
		UpdatedAt:     *v.UpdatedAt,
	}

	return res
}

// unmarshalFunctionToolDefinitionResponseBodyToTypesFunctionToolDefinition
// builds a value of type *types.FunctionToolDefinition from a value of type
// *FunctionToolDefinitionResponseBody.
func unmarshalFunctionToolDefinitionResponseBodyToTypesFunctionToolDefinition(v *FunctionToolDefinitionResponseBody) *types.FunctionToolDefinition {
	if v == nil {
		return nil
	}
	res := &types.FunctionToolDefinition{
		DeploymentID:  *v.DeploymentID,
		AssetID:       *v.AssetID,
		FunctionID:    *v.FunctionID,
		Runtime:       *v.Runtime,
		Variables:     v.Variables,
		ID:            *v.ID,
		ToolUrn:       *v.ToolUrn,
		ProjectID:     *v.ProjectID,
		Name:          *v.Name,
		CanonicalName: *v.CanonicalName,
		Description:   *v.Description,
		SchemaVersion: v.SchemaVersion,
		Schema:        *v.Schema,
		Confirm:       v.Confirm,
		ConfirmPrompt: v.ConfirmPrompt,
		Summarizer:    v.Summarizer,
		CreatedAt:     *v.CreatedAt,
		UpdatedAt:     *v.UpdatedAt,
	}
	if v.Meta != nil {
		res.Meta = make(map[string]any, len(v.Meta))
		for key, val := range v.Meta {
			tk := key
			tv := val
			res.Meta[tk] = tv
		}
	}
	if v.Canonical != nil {
		res.Canonical = unmarshalCanonicalToolAttributesResponseBodyToTypesCanonicalToolAttributes(v.Canonical)
	}
	if v.Variation != nil {
		res.Variation = unmarshalToolVariationResponseBodyToTypesToolVariation(v.Variation)
	}

	return res
}

// unmarshalPromptTemplateResponseBodyToTypesPromptTemplate builds a value of
// type *types.PromptTemplate from a value of type *PromptTemplateResponseBody.
func unmarshalPromptTemplateResponseBodyToTypesPromptTemplate(v *PromptTemplateResponseBody) *types.PromptTemplate {
	if v == nil {
		return nil
	}
	res := &types.PromptTemplate{
		HistoryID:     *v.HistoryID,
		PredecessorID: v.PredecessorID,
		Prompt:        *v.Prompt,
		Engine:        *v.Engine,
		Kind:          *v.Kind,
		ID:            *v.ID,
		ToolUrn:       *v.ToolUrn,
		ProjectID:     *v.ProjectID,
		Name:          *v.Name,
		CanonicalName: *v.CanonicalName,
		Description:   *v.Description,
		SchemaVersion: v.SchemaVersion,
		Schema:        *v.Schema,
		Confirm:       v.Confirm,
		ConfirmPrompt: v.ConfirmPrompt,
		Summarizer:    v.Summarizer,
		CreatedAt:     *v.CreatedAt,
		UpdatedAt:     *v.UpdatedAt,
	}
	res.ToolsHint = make([]string, len(v.ToolsHint))
	for i, val := range v.ToolsHint {
		res.ToolsHint[i] = val
	}
	if v.ToolUrnsHint != nil {
		res.ToolUrnsHint = make([]string, len(v.ToolUrnsHint))
		for i, val := range v.ToolUrnsHint {
			res.ToolUrnsHint[i] = val
		}
	}
	if v.Canonical != nil {
		res.Canonical = unmarshalCanonicalToolAttributesResponseBodyToTypesCanonicalToolAttributes(v.Canonical)
	}
	if v.Variation != nil {
		res.Variation = unmarshalToolVariationResponseBodyToTypesToolVariation(v.Variation)
	}

	return res
}

// unmarshalResourceResponseBodyToTypesResource builds a value of type
// *types.Resource from a value of type *ResourceResponseBody.
func unmarshalResourceResponseBodyToTypesResource(v *ResourceResponseBody) *types.Resource {
	res := &types.Resource{}
	if v.FunctionResourceDefinition != nil {
		res.FunctionResourceDefinition = unmarshalFunctionResourceDefinitionResponseBodyToTypesFunctionResourceDefinition(v.FunctionResourceDefinition)
	}

	return res
}

// unmarshalFunctionResourceDefinitionResponseBodyToTypesFunctionResourceDefinition
// builds a value of type *types.FunctionResourceDefinition from a value of
// type *FunctionResourceDefinitionResponseBody.
func unmarshalFunctionResourceDefinitionResponseBodyToTypesFunctionResourceDefinition(v *FunctionResourceDefinitionResponseBody) *types.FunctionResourceDefinition {
	if v == nil {
		return nil
	}
	res := &types.FunctionResourceDefinition{
		DeploymentID: *v.DeploymentID,
		FunctionID:   *v.FunctionID,
		Runtime:      *v.Runtime,
		Variables:    v.Variables,
		ID:           *v.ID,
		ResourceUrn:  *v.ResourceUrn,
		ProjectID:    *v.ProjectID,
		Name:         *v.Name,
		Description:  *v.Description,
		URI:          *v.URI,
		Title:        v.Title,
		MimeType:     v.MimeType,
		CreatedAt:    *v.CreatedAt,
		UpdatedAt:    *v.UpdatedAt,
	}
	if v.Meta != nil {
		res.Meta = make(map[string]any, len(v.Meta))
		for key, val := range v.Meta {
			tk := key
			tv := val
			res.Meta[tk] = tv
		}
	}

	return res
}

// unmarshalExternalOAuthServerResponseBodyToTypesExternalOAuthServer builds a
// value of type *types.ExternalOAuthServer from a value of type
// *ExternalOAuthServerResponseBody.
func unmarshalExternalOAuthServerResponseBodyToTypesExternalOAuthServer(v *ExternalOAuthServerResponseBody) *types.ExternalOAuthServer {
	if v == nil {
		return nil
	}
	res := &types.ExternalOAuthServer{
		ID:        *v.ID,
		ProjectID: *v.ProjectID,
		Slug:      types.Slug(*v.Slug),
		Metadata:  v.Metadata,
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
	}

	return res
}

// unmarshalOAuthProxyServerResponseBodyToTypesOAuthProxyServer builds a value
// of type *types.OAuthProxyServer from a value of type
// *OAuthProxyServerResponseBody.
func unmarshalOAuthProxyServerResponseBodyToTypesOAuthProxyServer(v *OAuthProxyServerResponseBody) *types.OAuthProxyServer {
	if v == nil {
		return nil
	}
	res := &types.OAuthProxyServer{
		ID:        *v.ID,
		ProjectID: *v.ProjectID,
		Slug:      types.Slug(*v.Slug),
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
	}
	if v.OauthProxyProviders != nil {
		res.OauthProxyProviders = make([]*types.OAuthProxyProvider, len(v.OauthProxyProviders))
		for i, val := range v.OauthProxyProviders {
			res.OauthProxyProviders[i] = unmarshalOAuthProxyProviderResponseBodyToTypesOAuthProxyProvider(val)
		}
	}

	return res
}

// unmarshalOAuthProxyProviderResponseBodyToTypesOAuthProxyProvider builds a
// value of type *types.OAuthProxyProvider from a value of type
// *OAuthProxyProviderResponseBody.
func unmarshalOAuthProxyProviderResponseBodyToTypesOAuthProxyProvider(v *OAuthProxyProviderResponseBody) *types.OAuthProxyProvider {
	if v == nil {
		return nil
	}
	res := &types.OAuthProxyProvider{
		ID:                    *v.ID,
		Slug:                  types.Slug(*v.Slug),
		AuthorizationEndpoint: *v.AuthorizationEndpoint,
		TokenEndpoint:         *v.TokenEndpoint,
		CreatedAt:             *v.CreatedAt,
		UpdatedAt:             *v.UpdatedAt,
	}
	if v.ScopesSupported != nil {
		res.ScopesSupported = make([]string, len(v.ScopesSupported))
		for i, val := range v.ScopesSupported {
			res.ScopesSupported[i] = val
		}
	}
	if v.GrantTypesSupported != nil {
		res.GrantTypesSupported = make([]string, len(v.GrantTypesSupported))
		for i, val := range v.GrantTypesSupported {
			res.GrantTypesSupported[i] = val
		}
	}
	if v.TokenEndpointAuthMethodsSupported != nil {
		res.TokenEndpointAuthMethodsSupported = make([]string, len(v.TokenEndpointAuthMethodsSupported))
		for i, val := range v.TokenEndpointAuthMethodsSupported {
			res.TokenEndpointAuthMethodsSupported[i] = val
		}
	}

	return res
}
