// Code generated by goa v3.22.6, DO NOT EDIT.
//
// releases HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	releases "github.com/speakeasy-api/gram/server/gen/releases"
	types "github.com/speakeasy-api/gram/server/gen/types"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateReleasePayload builds the payload for the releases createRelease
// endpoint from CLI flags.
func BuildCreateReleasePayload(releasesCreateReleaseBody string, releasesCreateReleaseSessionToken string, releasesCreateReleaseApikeyToken string, releasesCreateReleaseProjectSlugInput string) (*releases.CreateReleasePayload, error) {
	var err error
	var body CreateReleaseRequestBody
	{
		err = json.Unmarshal([]byte(releasesCreateReleaseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"notes\": \"Quia optio dolor aliquam qui sit tempora.\",\n      \"toolset_slug\": \"ad8\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.toolset_slug", body.ToolsetSlug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(body.ToolsetSlug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.toolset_slug", body.ToolsetSlug, utf8.RuneCountInString(body.ToolsetSlug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if releasesCreateReleaseSessionToken != "" {
			sessionToken = &releasesCreateReleaseSessionToken
		}
	}
	var apikeyToken *string
	{
		if releasesCreateReleaseApikeyToken != "" {
			apikeyToken = &releasesCreateReleaseApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if releasesCreateReleaseProjectSlugInput != "" {
			projectSlugInput = &releasesCreateReleaseProjectSlugInput
		}
	}
	v := &releases.CreateReleasePayload{
		ToolsetSlug: types.Slug(body.ToolsetSlug),
		Notes:       body.Notes,
	}
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListReleasesPayload builds the payload for the releases listReleases
// endpoint from CLI flags.
func BuildListReleasesPayload(releasesListReleasesToolsetSlug string, releasesListReleasesLimit string, releasesListReleasesOffset string, releasesListReleasesSessionToken string, releasesListReleasesApikeyToken string, releasesListReleasesProjectSlugInput string) (*releases.ListReleasesPayload, error) {
	var err error
	var toolsetSlug string
	{
		toolsetSlug = releasesListReleasesToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("toolset_slug", toolsetSlug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(toolsetSlug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("toolset_slug", toolsetSlug, utf8.RuneCountInString(toolsetSlug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var limit *int32
	{
		if releasesListReleasesLimit != "" {
			var v int64
			v, err = strconv.ParseInt(releasesListReleasesLimit, 10, 32)
			val := int32(v)
			limit = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT32")
			}
		}
	}
	var offset *int32
	{
		if releasesListReleasesOffset != "" {
			var v int64
			v, err = strconv.ParseInt(releasesListReleasesOffset, 10, 32)
			val := int32(v)
			offset = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT32")
			}
		}
	}
	var sessionToken *string
	{
		if releasesListReleasesSessionToken != "" {
			sessionToken = &releasesListReleasesSessionToken
		}
	}
	var apikeyToken *string
	{
		if releasesListReleasesApikeyToken != "" {
			apikeyToken = &releasesListReleasesApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if releasesListReleasesProjectSlugInput != "" {
			projectSlugInput = &releasesListReleasesProjectSlugInput
		}
	}
	v := &releases.ListReleasesPayload{}
	v.ToolsetSlug = types.Slug(toolsetSlug)
	v.Limit = limit
	v.Offset = offset
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetReleasePayload builds the payload for the releases getRelease
// endpoint from CLI flags.
func BuildGetReleasePayload(releasesGetReleaseReleaseID string, releasesGetReleaseSessionToken string, releasesGetReleaseApikeyToken string, releasesGetReleaseProjectSlugInput string) (*releases.GetReleasePayload, error) {
	var releaseID string
	{
		releaseID = releasesGetReleaseReleaseID
	}
	var sessionToken *string
	{
		if releasesGetReleaseSessionToken != "" {
			sessionToken = &releasesGetReleaseSessionToken
		}
	}
	var apikeyToken *string
	{
		if releasesGetReleaseApikeyToken != "" {
			apikeyToken = &releasesGetReleaseApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if releasesGetReleaseProjectSlugInput != "" {
			projectSlugInput = &releasesGetReleaseProjectSlugInput
		}
	}
	v := &releases.GetReleasePayload{}
	v.ReleaseID = releaseID
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetReleaseByNumberPayload builds the payload for the releases
// getReleaseByNumber endpoint from CLI flags.
func BuildGetReleaseByNumberPayload(releasesGetReleaseByNumberToolsetSlug string, releasesGetReleaseByNumberReleaseNumber string, releasesGetReleaseByNumberSessionToken string, releasesGetReleaseByNumberApikeyToken string, releasesGetReleaseByNumberProjectSlugInput string) (*releases.GetReleaseByNumberPayload, error) {
	var err error
	var toolsetSlug string
	{
		toolsetSlug = releasesGetReleaseByNumberToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("toolset_slug", toolsetSlug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(toolsetSlug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("toolset_slug", toolsetSlug, utf8.RuneCountInString(toolsetSlug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var releaseNumber int64
	{
		releaseNumber, err = strconv.ParseInt(releasesGetReleaseByNumberReleaseNumber, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid value for releaseNumber, must be INT64")
		}
	}
	var sessionToken *string
	{
		if releasesGetReleaseByNumberSessionToken != "" {
			sessionToken = &releasesGetReleaseByNumberSessionToken
		}
	}
	var apikeyToken *string
	{
		if releasesGetReleaseByNumberApikeyToken != "" {
			apikeyToken = &releasesGetReleaseByNumberApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if releasesGetReleaseByNumberProjectSlugInput != "" {
			projectSlugInput = &releasesGetReleaseByNumberProjectSlugInput
		}
	}
	v := &releases.GetReleaseByNumberPayload{}
	v.ToolsetSlug = types.Slug(toolsetSlug)
	v.ReleaseNumber = releaseNumber
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetLatestReleasePayload builds the payload for the releases
// getLatestRelease endpoint from CLI flags.
func BuildGetLatestReleasePayload(releasesGetLatestReleaseToolsetSlug string, releasesGetLatestReleaseSessionToken string, releasesGetLatestReleaseApikeyToken string, releasesGetLatestReleaseProjectSlugInput string) (*releases.GetLatestReleasePayload, error) {
	var err error
	var toolsetSlug string
	{
		toolsetSlug = releasesGetLatestReleaseToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("toolset_slug", toolsetSlug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(toolsetSlug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("toolset_slug", toolsetSlug, utf8.RuneCountInString(toolsetSlug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if releasesGetLatestReleaseSessionToken != "" {
			sessionToken = &releasesGetLatestReleaseSessionToken
		}
	}
	var apikeyToken *string
	{
		if releasesGetLatestReleaseApikeyToken != "" {
			apikeyToken = &releasesGetLatestReleaseApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if releasesGetLatestReleaseProjectSlugInput != "" {
			projectSlugInput = &releasesGetLatestReleaseProjectSlugInput
		}
	}
	v := &releases.GetLatestReleasePayload{}
	v.ToolsetSlug = types.Slug(toolsetSlug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildRollbackToReleasePayload builds the payload for the releases
// rollbackToRelease endpoint from CLI flags.
func BuildRollbackToReleasePayload(releasesRollbackToReleaseBody string, releasesRollbackToReleaseSessionToken string, releasesRollbackToReleaseApikeyToken string, releasesRollbackToReleaseProjectSlugInput string) (*releases.RollbackToReleasePayload, error) {
	var err error
	var body RollbackToReleaseRequestBody
	{
		err = json.Unmarshal([]byte(releasesRollbackToReleaseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"release_number\": 6687147481956405984,\n      \"toolset_slug\": \"q4p\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.toolset_slug", body.ToolsetSlug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(body.ToolsetSlug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.toolset_slug", body.ToolsetSlug, utf8.RuneCountInString(body.ToolsetSlug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if releasesRollbackToReleaseSessionToken != "" {
			sessionToken = &releasesRollbackToReleaseSessionToken
		}
	}
	var apikeyToken *string
	{
		if releasesRollbackToReleaseApikeyToken != "" {
			apikeyToken = &releasesRollbackToReleaseApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if releasesRollbackToReleaseProjectSlugInput != "" {
			projectSlugInput = &releasesRollbackToReleaseProjectSlugInput
		}
	}
	v := &releases.RollbackToReleasePayload{
		ToolsetSlug:   types.Slug(body.ToolsetSlug),
		ReleaseNumber: body.ReleaseNumber,
	}
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
