// Code generated by goa v3.24.2, DO NOT EDIT.
//
// telemetry HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	telemetry "github.com/speakeasy-api/gram/server/gen/telemetry"
	goa "goa.design/goa/v3/pkg"
)

// BuildSearchLogsPayload builds the payload for the telemetry searchLogs
// endpoint from CLI flags.
func BuildSearchLogsPayload(telemetrySearchLogsBody string, telemetrySearchLogsApikeyToken string, telemetrySearchLogsSessionToken string, telemetrySearchLogsProjectSlugInput string) (*telemetry.SearchLogsPayload, error) {
	var err error
	var body SearchLogsRequestBody
	{
		err = json.Unmarshal([]byte(telemetrySearchLogsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"cursor\": \"abc123\",\n      \"filter\": {\n         \"deployment_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n         \"external_user_id\": \"abc123\",\n         \"from\": \"2025-12-19T10:00:00Z\",\n         \"function_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n         \"gram_chat_id\": \"abc123\",\n         \"gram_urn\": \"abc123\",\n         \"gram_urns\": [\n            \"abc123\"\n         ],\n         \"http_method\": \"POST\",\n         \"http_route\": \"abc123\",\n         \"http_status_code\": 1,\n         \"service_name\": \"abc123\",\n         \"severity_text\": \"INFO\",\n         \"to\": \"2025-12-19T11:00:00Z\",\n         \"trace_id\": \"11111111111111111111111111111111\",\n         \"user_id\": \"abc123\"\n      },\n      \"limit\": 2,\n      \"sort\": \"desc\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if telemetrySearchLogsApikeyToken != "" {
			apikeyToken = &telemetrySearchLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetrySearchLogsSessionToken != "" {
			sessionToken = &telemetrySearchLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetrySearchLogsProjectSlugInput != "" {
			projectSlugInput = &telemetrySearchLogsProjectSlugInput
		}
	}
	v := &telemetry.SearchLogsPayload{
		Cursor: body.Cursor,
		Sort:   body.Sort,
		Limit:  body.Limit,
	}
	if body.Filter != nil {
		v.Filter = marshalSearchLogsFilterRequestBodyToTelemetrySearchLogsFilter(body.Filter)
	}
	{
		var zero string
		if v.Sort == zero {
			v.Sort = "desc"
		}
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildSearchToolCallsPayload builds the payload for the telemetry
// searchToolCalls endpoint from CLI flags.
func BuildSearchToolCallsPayload(telemetrySearchToolCallsBody string, telemetrySearchToolCallsApikeyToken string, telemetrySearchToolCallsSessionToken string, telemetrySearchToolCallsProjectSlugInput string) (*telemetry.SearchToolCallsPayload, error) {
	var err error
	var body SearchToolCallsRequestBody
	{
		err = json.Unmarshal([]byte(telemetrySearchToolCallsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"cursor\": \"abc123\",\n      \"filter\": {\n         \"deployment_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n         \"from\": \"2025-12-19T10:00:00Z\",\n         \"function_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n         \"gram_urn\": \"abc123\",\n         \"to\": \"2025-12-19T11:00:00Z\"\n      },\n      \"limit\": 2,\n      \"sort\": \"desc\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if telemetrySearchToolCallsApikeyToken != "" {
			apikeyToken = &telemetrySearchToolCallsApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetrySearchToolCallsSessionToken != "" {
			sessionToken = &telemetrySearchToolCallsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetrySearchToolCallsProjectSlugInput != "" {
			projectSlugInput = &telemetrySearchToolCallsProjectSlugInput
		}
	}
	v := &telemetry.SearchToolCallsPayload{
		Cursor: body.Cursor,
		Sort:   body.Sort,
		Limit:  body.Limit,
	}
	if body.Filter != nil {
		v.Filter = marshalSearchToolCallsFilterRequestBodyToTelemetrySearchToolCallsFilter(body.Filter)
	}
	{
		var zero string
		if v.Sort == zero {
			v.Sort = "desc"
		}
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildSearchChatsPayload builds the payload for the telemetry searchChats
// endpoint from CLI flags.
func BuildSearchChatsPayload(telemetrySearchChatsBody string, telemetrySearchChatsApikeyToken string, telemetrySearchChatsSessionToken string, telemetrySearchChatsProjectSlugInput string) (*telemetry.SearchChatsPayload, error) {
	var err error
	var body SearchChatsRequestBody
	{
		err = json.Unmarshal([]byte(telemetrySearchChatsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"cursor\": \"abc123\",\n      \"filter\": {\n         \"deployment_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n         \"external_user_id\": \"abc123\",\n         \"from\": \"2025-12-19T10:00:00Z\",\n         \"gram_urn\": \"abc123\",\n         \"to\": \"2025-12-19T11:00:00Z\",\n         \"user_id\": \"abc123\"\n      },\n      \"limit\": 2,\n      \"sort\": \"desc\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if telemetrySearchChatsApikeyToken != "" {
			apikeyToken = &telemetrySearchChatsApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetrySearchChatsSessionToken != "" {
			sessionToken = &telemetrySearchChatsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetrySearchChatsProjectSlugInput != "" {
			projectSlugInput = &telemetrySearchChatsProjectSlugInput
		}
	}
	v := &telemetry.SearchChatsPayload{
		Cursor: body.Cursor,
		Sort:   body.Sort,
		Limit:  body.Limit,
	}
	if body.Filter != nil {
		v.Filter = marshalSearchChatsFilterRequestBodyToTelemetrySearchChatsFilter(body.Filter)
	}
	{
		var zero string
		if v.Sort == zero {
			v.Sort = "desc"
		}
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildSearchUsersPayload builds the payload for the telemetry searchUsers
// endpoint from CLI flags.
func BuildSearchUsersPayload(telemetrySearchUsersBody string, telemetrySearchUsersApikeyToken string, telemetrySearchUsersSessionToken string, telemetrySearchUsersProjectSlugInput string) (*telemetry.SearchUsersPayload, error) {
	var err error
	var body SearchUsersRequestBody
	{
		err = json.Unmarshal([]byte(telemetrySearchUsersBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"cursor\": \"abc123\",\n      \"filter\": {\n         \"deployment_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n         \"from\": \"2025-12-19T10:00:00Z\",\n         \"to\": \"2025-12-19T11:00:00Z\"\n      },\n      \"limit\": 2,\n      \"sort\": \"desc\",\n      \"user_type\": \"external\"\n   }'")
		}
		if body.Filter == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("filter", "body"))
		}
		if body.Filter != nil {
			if err2 := ValidateSearchUsersFilterRequestBody(body.Filter); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if !(body.UserType == "internal" || body.UserType == "external") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.user_type", body.UserType, []any{"internal", "external"}))
		}
		if !(body.Sort == "asc" || body.Sort == "desc") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.sort", body.Sort, []any{"asc", "desc"}))
		}
		if body.Limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.limit", body.Limit, 1, true))
		}
		if body.Limit > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.limit", body.Limit, 1000, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if telemetrySearchUsersApikeyToken != "" {
			apikeyToken = &telemetrySearchUsersApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetrySearchUsersSessionToken != "" {
			sessionToken = &telemetrySearchUsersSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetrySearchUsersProjectSlugInput != "" {
			projectSlugInput = &telemetrySearchUsersProjectSlugInput
		}
	}
	v := &telemetry.SearchUsersPayload{
		UserType: body.UserType,
		Cursor:   body.Cursor,
		Sort:     body.Sort,
		Limit:    body.Limit,
	}
	if body.Filter != nil {
		v.Filter = marshalSearchUsersFilterRequestBodyToTelemetrySearchUsersFilter(body.Filter)
	}
	{
		var zero string
		if v.Sort == zero {
			v.Sort = "desc"
		}
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildCaptureEventPayload builds the payload for the telemetry captureEvent
// endpoint from CLI flags.
func BuildCaptureEventPayload(telemetryCaptureEventBody string, telemetryCaptureEventApikeyToken string, telemetryCaptureEventSessionToken string, telemetryCaptureEventProjectSlugInput string, telemetryCaptureEventChatSessionsToken string) (*telemetry.CaptureEventPayload, error) {
	var err error
	var body CaptureEventRequestBody
	{
		err = json.Unmarshal([]byte(telemetryCaptureEventBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"distinct_id\": \"abc123\",\n      \"event\": \"button_clicked\",\n      \"properties\": {\n         \"button_name\": \"submit\",\n         \"page\": \"checkout\",\n         \"value\": 100\n      }\n   }'")
		}
		if utf8.RuneCountInString(body.Event) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.event", body.Event, utf8.RuneCountInString(body.Event), 1, true))
		}
		if utf8.RuneCountInString(body.Event) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.event", body.Event, utf8.RuneCountInString(body.Event), 255, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if telemetryCaptureEventApikeyToken != "" {
			apikeyToken = &telemetryCaptureEventApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetryCaptureEventSessionToken != "" {
			sessionToken = &telemetryCaptureEventSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetryCaptureEventProjectSlugInput != "" {
			projectSlugInput = &telemetryCaptureEventProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if telemetryCaptureEventChatSessionsToken != "" {
			chatSessionsToken = &telemetryCaptureEventChatSessionsToken
		}
	}
	v := &telemetry.CaptureEventPayload{
		Event:      body.Event,
		DistinctID: body.DistinctID,
	}
	if body.Properties != nil {
		v.Properties = make(map[string]any, len(body.Properties))
		for key, val := range body.Properties {
			tk := key
			tv := val
			v.Properties[tk] = tv
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}

// BuildGetProjectMetricsSummaryPayload builds the payload for the telemetry
// getProjectMetricsSummary endpoint from CLI flags.
func BuildGetProjectMetricsSummaryPayload(telemetryGetProjectMetricsSummaryBody string, telemetryGetProjectMetricsSummaryApikeyToken string, telemetryGetProjectMetricsSummarySessionToken string, telemetryGetProjectMetricsSummaryProjectSlugInput string) (*telemetry.GetProjectMetricsSummaryPayload, error) {
	var err error
	var body GetProjectMetricsSummaryRequestBody
	{
		err = json.Unmarshal([]byte(telemetryGetProjectMetricsSummaryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"from\": \"2025-12-19T10:00:00Z\",\n      \"to\": \"2025-12-19T11:00:00Z\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.from", body.From, goa.FormatDateTime))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.to", body.To, goa.FormatDateTime))
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if telemetryGetProjectMetricsSummaryApikeyToken != "" {
			apikeyToken = &telemetryGetProjectMetricsSummaryApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetryGetProjectMetricsSummarySessionToken != "" {
			sessionToken = &telemetryGetProjectMetricsSummarySessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetryGetProjectMetricsSummaryProjectSlugInput != "" {
			projectSlugInput = &telemetryGetProjectMetricsSummaryProjectSlugInput
		}
	}
	v := &telemetry.GetProjectMetricsSummaryPayload{
		From: body.From,
		To:   body.To,
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetUserMetricsSummaryPayload builds the payload for the telemetry
// getUserMetricsSummary endpoint from CLI flags.
func BuildGetUserMetricsSummaryPayload(telemetryGetUserMetricsSummaryBody string, telemetryGetUserMetricsSummaryApikeyToken string, telemetryGetUserMetricsSummarySessionToken string, telemetryGetUserMetricsSummaryProjectSlugInput string) (*telemetry.GetUserMetricsSummaryPayload, error) {
	var err error
	var body GetUserMetricsSummaryRequestBody
	{
		err = json.Unmarshal([]byte(telemetryGetUserMetricsSummaryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"external_user_id\": \"abc123\",\n      \"from\": \"2025-12-19T10:00:00Z\",\n      \"to\": \"2025-12-19T11:00:00Z\",\n      \"user_id\": \"abc123\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.from", body.From, goa.FormatDateTime))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.to", body.To, goa.FormatDateTime))
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if telemetryGetUserMetricsSummaryApikeyToken != "" {
			apikeyToken = &telemetryGetUserMetricsSummaryApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetryGetUserMetricsSummarySessionToken != "" {
			sessionToken = &telemetryGetUserMetricsSummarySessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetryGetUserMetricsSummaryProjectSlugInput != "" {
			projectSlugInput = &telemetryGetUserMetricsSummaryProjectSlugInput
		}
	}
	v := &telemetry.GetUserMetricsSummaryPayload{
		From:           body.From,
		To:             body.To,
		UserID:         body.UserID,
		ExternalUserID: body.ExternalUserID,
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetObservabilityOverviewPayload builds the payload for the telemetry
// getObservabilityOverview endpoint from CLI flags.
func BuildGetObservabilityOverviewPayload(telemetryGetObservabilityOverviewBody string, telemetryGetObservabilityOverviewApikeyToken string, telemetryGetObservabilityOverviewSessionToken string, telemetryGetObservabilityOverviewProjectSlugInput string) (*telemetry.GetObservabilityOverviewPayload, error) {
	var err error
	var body GetObservabilityOverviewRequestBody
	{
		err = json.Unmarshal([]byte(telemetryGetObservabilityOverviewBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"api_key_id\": \"abc123\",\n      \"external_user_id\": \"abc123\",\n      \"from\": \"2025-12-19T10:00:00Z\",\n      \"include_time_series\": false,\n      \"interval_seconds\": 1,\n      \"to\": \"2025-12-19T11:00:00Z\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.from", body.From, goa.FormatDateTime))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.to", body.To, goa.FormatDateTime))
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if telemetryGetObservabilityOverviewApikeyToken != "" {
			apikeyToken = &telemetryGetObservabilityOverviewApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetryGetObservabilityOverviewSessionToken != "" {
			sessionToken = &telemetryGetObservabilityOverviewSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetryGetObservabilityOverviewProjectSlugInput != "" {
			projectSlugInput = &telemetryGetObservabilityOverviewProjectSlugInput
		}
	}
	v := &telemetry.GetObservabilityOverviewPayload{
		From:              body.From,
		To:                body.To,
		ExternalUserID:    body.ExternalUserID,
		APIKeyID:          body.APIKeyID,
		IncludeTimeSeries: body.IncludeTimeSeries,
		IntervalSeconds:   body.IntervalSeconds,
	}
	{
		var zero bool
		if v.IncludeTimeSeries == zero {
			v.IncludeTimeSeries = true
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListFilterOptionsPayload builds the payload for the telemetry
// listFilterOptions endpoint from CLI flags.
func BuildListFilterOptionsPayload(telemetryListFilterOptionsBody string, telemetryListFilterOptionsApikeyToken string, telemetryListFilterOptionsSessionToken string, telemetryListFilterOptionsProjectSlugInput string) (*telemetry.ListFilterOptionsPayload, error) {
	var err error
	var body ListFilterOptionsRequestBody
	{
		err = json.Unmarshal([]byte(telemetryListFilterOptionsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filter_type\": \"user\",\n      \"from\": \"2025-12-19T10:00:00Z\",\n      \"to\": \"2025-12-19T11:00:00Z\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.from", body.From, goa.FormatDateTime))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.to", body.To, goa.FormatDateTime))
		if !(body.FilterType == "api_key" || body.FilterType == "user") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.filter_type", body.FilterType, []any{"api_key", "user"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if telemetryListFilterOptionsApikeyToken != "" {
			apikeyToken = &telemetryListFilterOptionsApikeyToken
		}
	}
	var sessionToken *string
	{
		if telemetryListFilterOptionsSessionToken != "" {
			sessionToken = &telemetryListFilterOptionsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if telemetryListFilterOptionsProjectSlugInput != "" {
			projectSlugInput = &telemetryListFilterOptionsProjectSlugInput
		}
	}
	v := &telemetry.ListFilterOptionsPayload{
		From:       body.From,
		To:         body.To,
		FilterType: body.FilterType,
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
