// Code generated by goa v3.24.1, DO NOT EDIT.
//
// telemetry HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strings"

	telemetry "github.com/speakeasy-api/gram/server/gen/telemetry"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeSearchLogsResponse returns an encoder for responses returned by the
// telemetry searchLogs endpoint.
func EncodeSearchLogsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*telemetry.SearchLogsResult)
		enc := encoder(ctx, w)
		body := NewSearchLogsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSearchLogsRequest returns a decoder for requests sent to the telemetry
// searchLogs endpoint.
func DecodeSearchLogsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*telemetry.SearchLogsPayload, error) {
	return func(r *http.Request) (*telemetry.SearchLogsPayload, error) {
		var (
			body SearchLogsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSearchLogsRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			apikeyToken      *string
			sessionToken     *string
			projectSlugInput *string
		)
		apikeyTokenRaw := r.Header.Get("Gram-Key")
		if apikeyTokenRaw != "" {
			apikeyToken = &apikeyTokenRaw
		}
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		payload := NewSearchLogsPayload(&body, apikeyToken, sessionToken, projectSlugInput)
		if payload.ApikeyToken != nil {
			if strings.Contains(*payload.ApikeyToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ApikeyToken, " ", 2)[1]
				payload.ApikeyToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeSearchLogsError returns an encoder for errors returned by the
// searchLogs telemetry endpoint.
func EncodeSearchLogsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "bad_request":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unsupported_media":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsUnsupportedMediaResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnsupportedMediaType)
			return enc.Encode(body)
		case "invalid":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsInvalidResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		case "invariant_violation":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsInvariantViolationResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "unexpected":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsUnexpectedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "gateway_error":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchLogsGatewayErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadGateway)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSearchToolCallsResponse returns an encoder for responses returned by
// the telemetry searchToolCalls endpoint.
func EncodeSearchToolCallsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*telemetry.SearchToolCallsResult)
		enc := encoder(ctx, w)
		body := NewSearchToolCallsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSearchToolCallsRequest returns a decoder for requests sent to the
// telemetry searchToolCalls endpoint.
func DecodeSearchToolCallsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*telemetry.SearchToolCallsPayload, error) {
	return func(r *http.Request) (*telemetry.SearchToolCallsPayload, error) {
		var (
			body SearchToolCallsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSearchToolCallsRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			apikeyToken      *string
			sessionToken     *string
			projectSlugInput *string
		)
		apikeyTokenRaw := r.Header.Get("Gram-Key")
		if apikeyTokenRaw != "" {
			apikeyToken = &apikeyTokenRaw
		}
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		payload := NewSearchToolCallsPayload(&body, apikeyToken, sessionToken, projectSlugInput)
		if payload.ApikeyToken != nil {
			if strings.Contains(*payload.ApikeyToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ApikeyToken, " ", 2)[1]
				payload.ApikeyToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeSearchToolCallsError returns an encoder for errors returned by the
// searchToolCalls telemetry endpoint.
func EncodeSearchToolCallsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "bad_request":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unsupported_media":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsUnsupportedMediaResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnsupportedMediaType)
			return enc.Encode(body)
		case "invalid":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsInvalidResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		case "invariant_violation":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsInvariantViolationResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "unexpected":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsUnexpectedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "gateway_error":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchToolCallsGatewayErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadGateway)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSearchChatsResponse returns an encoder for responses returned by the
// telemetry searchChats endpoint.
func EncodeSearchChatsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*telemetry.SearchChatsResult)
		enc := encoder(ctx, w)
		body := NewSearchChatsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSearchChatsRequest returns a decoder for requests sent to the
// telemetry searchChats endpoint.
func DecodeSearchChatsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*telemetry.SearchChatsPayload, error) {
	return func(r *http.Request) (*telemetry.SearchChatsPayload, error) {
		var (
			body SearchChatsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSearchChatsRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			apikeyToken      *string
			sessionToken     *string
			projectSlugInput *string
		)
		apikeyTokenRaw := r.Header.Get("Gram-Key")
		if apikeyTokenRaw != "" {
			apikeyToken = &apikeyTokenRaw
		}
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		payload := NewSearchChatsPayload(&body, apikeyToken, sessionToken, projectSlugInput)
		if payload.ApikeyToken != nil {
			if strings.Contains(*payload.ApikeyToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ApikeyToken, " ", 2)[1]
				payload.ApikeyToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeSearchChatsError returns an encoder for errors returned by the
// searchChats telemetry endpoint.
func EncodeSearchChatsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "bad_request":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unsupported_media":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsUnsupportedMediaResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnsupportedMediaType)
			return enc.Encode(body)
		case "invalid":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsInvalidResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		case "invariant_violation":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsInvariantViolationResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "unexpected":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsUnexpectedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "gateway_error":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewSearchChatsGatewayErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadGateway)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCaptureEventResponse returns an encoder for responses returned by the
// telemetry captureEvent endpoint.
func EncodeCaptureEventResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*telemetry.CaptureEventResult)
		enc := encoder(ctx, w)
		body := NewCaptureEventResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCaptureEventRequest returns a decoder for requests sent to the
// telemetry captureEvent endpoint.
func DecodeCaptureEventRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*telemetry.CaptureEventPayload, error) {
	return func(r *http.Request) (*telemetry.CaptureEventPayload, error) {
		var (
			body CaptureEventRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCaptureEventRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			apikeyToken       *string
			sessionToken      *string
			projectSlugInput  *string
			chatSessionsToken *string
		)
		apikeyTokenRaw := r.Header.Get("Gram-Key")
		if apikeyTokenRaw != "" {
			apikeyToken = &apikeyTokenRaw
		}
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		chatSessionsTokenRaw := r.Header.Get("Gram-Chat-Session")
		if chatSessionsTokenRaw != "" {
			chatSessionsToken = &chatSessionsTokenRaw
		}
		payload := NewCaptureEventPayload(&body, apikeyToken, sessionToken, projectSlugInput, chatSessionsToken)
		if payload.ApikeyToken != nil {
			if strings.Contains(*payload.ApikeyToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ApikeyToken, " ", 2)[1]
				payload.ApikeyToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}
		if payload.ChatSessionsToken != nil {
			if strings.Contains(*payload.ChatSessionsToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ChatSessionsToken, " ", 2)[1]
				payload.ChatSessionsToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCaptureEventError returns an encoder for errors returned by the
// captureEvent telemetry endpoint.
func EncodeCaptureEventError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "bad_request":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unsupported_media":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventUnsupportedMediaResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnsupportedMediaType)
			return enc.Encode(body)
		case "invalid":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventInvalidResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		case "invariant_violation":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventInvariantViolationResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "unexpected":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventUnexpectedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "gateway_error":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCaptureEventGatewayErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadGateway)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetProjectMetricsSummaryResponse returns an encoder for responses
// returned by the telemetry getProjectMetricsSummary endpoint.
func EncodeGetProjectMetricsSummaryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*telemetry.GetMetricsSummaryResult)
		enc := encoder(ctx, w)
		body := NewGetProjectMetricsSummaryResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetProjectMetricsSummaryRequest returns a decoder for requests sent to
// the telemetry getProjectMetricsSummary endpoint.
func DecodeGetProjectMetricsSummaryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*telemetry.GetProjectMetricsSummaryPayload, error) {
	return func(r *http.Request) (*telemetry.GetProjectMetricsSummaryPayload, error) {
		var (
			body GetProjectMetricsSummaryRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateGetProjectMetricsSummaryRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			apikeyToken      *string
			sessionToken     *string
			projectSlugInput *string
		)
		apikeyTokenRaw := r.Header.Get("Gram-Key")
		if apikeyTokenRaw != "" {
			apikeyToken = &apikeyTokenRaw
		}
		sessionTokenRaw := r.Header.Get("Gram-Session")
		if sessionTokenRaw != "" {
			sessionToken = &sessionTokenRaw
		}
		projectSlugInputRaw := r.Header.Get("Gram-Project")
		if projectSlugInputRaw != "" {
			projectSlugInput = &projectSlugInputRaw
		}
		payload := NewGetProjectMetricsSummaryPayload(&body, apikeyToken, sessionToken, projectSlugInput)
		if payload.ApikeyToken != nil {
			if strings.Contains(*payload.ApikeyToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ApikeyToken, " ", 2)[1]
				payload.ApikeyToken = &cred
			}
		}
		if payload.ProjectSlugInput != nil {
			if strings.Contains(*payload.ProjectSlugInput, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.ProjectSlugInput, " ", 2)[1]
				payload.ProjectSlugInput = &cred
			}
		}
		if payload.SessionToken != nil {
			if strings.Contains(*payload.SessionToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.SessionToken, " ", 2)[1]
				payload.SessionToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetProjectMetricsSummaryError returns an encoder for errors returned
// by the getProjectMetricsSummary telemetry endpoint.
func EncodeGetProjectMetricsSummaryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "bad_request":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_found":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unsupported_media":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryUnsupportedMediaResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnsupportedMediaType)
			return enc.Encode(body)
		case "invalid":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryInvalidResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnprocessableEntity)
			return enc.Encode(body)
		case "invariant_violation":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryInvariantViolationResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "unexpected":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryUnexpectedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "gateway_error":
			var res *goa.ServiceError
			errors.As(v, &res)
			ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetProjectMetricsSummaryGatewayErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadGateway)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// unmarshalSearchLogsFilterRequestBodyToTelemetrySearchLogsFilter builds a
// value of type *telemetry.SearchLogsFilter from a value of type
// *SearchLogsFilterRequestBody.
func unmarshalSearchLogsFilterRequestBodyToTelemetrySearchLogsFilter(v *SearchLogsFilterRequestBody) *telemetry.SearchLogsFilter {
	if v == nil {
		return nil
	}
	res := &telemetry.SearchLogsFilter{
		TraceID:        v.TraceID,
		SeverityText:   v.SeverityText,
		HTTPStatusCode: v.HTTPStatusCode,
		HTTPRoute:      v.HTTPRoute,
		HTTPMethod:     v.HTTPMethod,
		ServiceName:    v.ServiceName,
		GramChatID:     v.GramChatID,
		From:           v.From,
		To:             v.To,
		DeploymentID:   v.DeploymentID,
		FunctionID:     v.FunctionID,
		GramUrn:        v.GramUrn,
	}
	if v.GramUrns != nil {
		res.GramUrns = make([]string, len(v.GramUrns))
		for i, val := range v.GramUrns {
			res.GramUrns[i] = val
		}
	}

	return res
}

// marshalTelemetryTelemetryLogRecordToTelemetryLogRecordResponseBody builds a
// value of type *TelemetryLogRecordResponseBody from a value of type
// *telemetry.TelemetryLogRecord.
func marshalTelemetryTelemetryLogRecordToTelemetryLogRecordResponseBody(v *telemetry.TelemetryLogRecord) *TelemetryLogRecordResponseBody {
	res := &TelemetryLogRecordResponseBody{
		ID:                   v.ID,
		TimeUnixNano:         v.TimeUnixNano,
		ObservedTimeUnixNano: v.ObservedTimeUnixNano,
		SeverityText:         v.SeverityText,
		Body:                 v.Body,
		TraceID:              v.TraceID,
		SpanID:               v.SpanID,
		Attributes:           v.Attributes,
		ResourceAttributes:   v.ResourceAttributes,
	}
	if v.Service != nil {
		res.Service = marshalTelemetryServiceInfoToServiceInfoResponseBody(v.Service)
	}

	return res
}

// marshalTelemetryServiceInfoToServiceInfoResponseBody builds a value of type
// *ServiceInfoResponseBody from a value of type *telemetry.ServiceInfo.
func marshalTelemetryServiceInfoToServiceInfoResponseBody(v *telemetry.ServiceInfo) *ServiceInfoResponseBody {
	res := &ServiceInfoResponseBody{
		Name:    v.Name,
		Version: v.Version,
	}

	return res
}

// unmarshalSearchToolCallsFilterRequestBodyToTelemetrySearchToolCallsFilter
// builds a value of type *telemetry.SearchToolCallsFilter from a value of type
// *SearchToolCallsFilterRequestBody.
func unmarshalSearchToolCallsFilterRequestBodyToTelemetrySearchToolCallsFilter(v *SearchToolCallsFilterRequestBody) *telemetry.SearchToolCallsFilter {
	if v == nil {
		return nil
	}
	res := &telemetry.SearchToolCallsFilter{
		From:         v.From,
		To:           v.To,
		DeploymentID: v.DeploymentID,
		FunctionID:   v.FunctionID,
		GramUrn:      v.GramUrn,
	}

	return res
}

// marshalTelemetryToolCallSummaryToToolCallSummaryResponseBody builds a value
// of type *ToolCallSummaryResponseBody from a value of type
// *telemetry.ToolCallSummary.
func marshalTelemetryToolCallSummaryToToolCallSummaryResponseBody(v *telemetry.ToolCallSummary) *ToolCallSummaryResponseBody {
	res := &ToolCallSummaryResponseBody{
		TraceID:           v.TraceID,
		StartTimeUnixNano: v.StartTimeUnixNano,
		LogCount:          v.LogCount,
		HTTPStatusCode:    v.HTTPStatusCode,
		GramUrn:           v.GramUrn,
	}

	return res
}

// unmarshalSearchChatsFilterRequestBodyToTelemetrySearchChatsFilter builds a
// value of type *telemetry.SearchChatsFilter from a value of type
// *SearchChatsFilterRequestBody.
func unmarshalSearchChatsFilterRequestBodyToTelemetrySearchChatsFilter(v *SearchChatsFilterRequestBody) *telemetry.SearchChatsFilter {
	if v == nil {
		return nil
	}
	res := &telemetry.SearchChatsFilter{
		From:         v.From,
		To:           v.To,
		DeploymentID: v.DeploymentID,
		FunctionID:   v.FunctionID,
		GramUrn:      v.GramUrn,
	}

	return res
}

// marshalTelemetryChatSummaryToChatSummaryResponseBody builds a value of type
// *ChatSummaryResponseBody from a value of type *telemetry.ChatSummary.
func marshalTelemetryChatSummaryToChatSummaryResponseBody(v *telemetry.ChatSummary) *ChatSummaryResponseBody {
	res := &ChatSummaryResponseBody{
		GramChatID:        v.GramChatID,
		StartTimeUnixNano: v.StartTimeUnixNano,
		EndTimeUnixNano:   v.EndTimeUnixNano,
		LogCount:          v.LogCount,
		ToolCallCount:     v.ToolCallCount,
		UserID:            v.UserID,
		TotalInputTokens:  v.TotalInputTokens,
		TotalOutputTokens: v.TotalOutputTokens,
	}

	return res
}

// marshalTelemetryMetricsToMetricsResponseBody builds a value of type
// *MetricsResponseBody from a value of type *telemetry.Metrics.
func marshalTelemetryMetricsToMetricsResponseBody(v *telemetry.Metrics) *MetricsResponseBody {
	res := &MetricsResponseBody{
		TotalInputTokens:      v.TotalInputTokens,
		TotalOutputTokens:     v.TotalOutputTokens,
		TotalTokens:           v.TotalTokens,
		AvgTokensPerRequest:   v.AvgTokensPerRequest,
		TotalChatRequests:     v.TotalChatRequests,
		AvgChatDurationMs:     v.AvgChatDurationMs,
		FinishReasonStop:      v.FinishReasonStop,
		FinishReasonToolCalls: v.FinishReasonToolCalls,
		TotalToolCalls:        v.TotalToolCalls,
		ToolCallSuccess:       v.ToolCallSuccess,
		ToolCallFailure:       v.ToolCallFailure,
		AvgToolDurationMs:     v.AvgToolDurationMs,
		TotalChats:            v.TotalChats,
		DistinctModels:        v.DistinctModels,
		DistinctProviders:     v.DistinctProviders,
	}
	if v.Models != nil {
		res.Models = make([]*ModelUsageResponseBody, len(v.Models))
		for i, val := range v.Models {
			if val == nil {
				res.Models[i] = nil
				continue
			}
			res.Models[i] = marshalTelemetryModelUsageToModelUsageResponseBody(val)
		}
	} else {
		res.Models = []*ModelUsageResponseBody{}
	}
	if v.Tools != nil {
		res.Tools = make([]*ToolUsageResponseBody, len(v.Tools))
		for i, val := range v.Tools {
			if val == nil {
				res.Tools[i] = nil
				continue
			}
			res.Tools[i] = marshalTelemetryToolUsageToToolUsageResponseBody(val)
		}
	} else {
		res.Tools = []*ToolUsageResponseBody{}
	}

	return res
}

// marshalTelemetryModelUsageToModelUsageResponseBody builds a value of type
// *ModelUsageResponseBody from a value of type *telemetry.ModelUsage.
func marshalTelemetryModelUsageToModelUsageResponseBody(v *telemetry.ModelUsage) *ModelUsageResponseBody {
	res := &ModelUsageResponseBody{
		Name:  v.Name,
		Count: v.Count,
	}

	return res
}

// marshalTelemetryToolUsageToToolUsageResponseBody builds a value of type
// *ToolUsageResponseBody from a value of type *telemetry.ToolUsage.
func marshalTelemetryToolUsageToToolUsageResponseBody(v *telemetry.ToolUsage) *ToolUsageResponseBody {
	res := &ToolUsageResponseBody{
		Urn:          v.Urn,
		Count:        v.Count,
		SuccessCount: v.SuccessCount,
		FailureCount: v.FailureCount,
	}

	return res
}
