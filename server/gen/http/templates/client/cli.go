// Code generated by goa v3.23.4, DO NOT EDIT.
//
// templates HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	templates "github.com/speakeasy-api/gram/server/gen/templates"
	types "github.com/speakeasy-api/gram/server/gen/types"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateTemplatePayload builds the payload for the templates
// createTemplate endpoint from CLI flags.
func BuildCreateTemplatePayload(templatesCreateTemplateBody string, templatesCreateTemplateApikeyToken string, templatesCreateTemplateSessionToken string, templatesCreateTemplateProjectSlugInput string) (*templates.CreateTemplatePayload, error) {
	var err error
	var body CreateTemplateRequestBody
	{
		err = json.Unmarshal([]byte(templatesCreateTemplateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"arguments\": \"{\\\"name\\\":\\\"example\\\",\\\"email\\\":\\\"mail@example.com\\\"}\",\n      \"description\": \"Dolores est perspiciatis doloribus nihil consequuntur.\",\n      \"engine\": \"mustache\",\n      \"kind\": \"higher_order_tool\",\n      \"name\": \"48j\",\n      \"prompt\": \"Quia dolorum natus quam excepturi.\",\n      \"tool_urns_hint\": [\n         \"Eum quaerat dolore velit natus aperiam.\",\n         \"Est animi.\",\n         \"Quae dolores.\"\n      ],\n      \"tools_hint\": [\n         \"Ut beatae.\",\n         \"Dolorem in sequi in vel.\",\n         \"Accusantium molestiae sed atque.\"\n      ]\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.name", body.Name, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(body.Name) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 40, false))
		}
		if body.Arguments != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.arguments", *body.Arguments, goa.FormatJSON))
		}
		if !(body.Engine == "mustache") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.engine", body.Engine, []any{"mustache"}))
		}
		if !(body.Kind == "prompt" || body.Kind == "higher_order_tool") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.kind", body.Kind, []any{"prompt", "higher_order_tool"}))
		}
		if len(body.ToolsHint) > 20 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tools_hint", body.ToolsHint, len(body.ToolsHint), 20, false))
		}
		if len(body.ToolUrnsHint) > 20 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tool_urns_hint", body.ToolUrnsHint, len(body.ToolUrnsHint), 20, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if templatesCreateTemplateApikeyToken != "" {
			apikeyToken = &templatesCreateTemplateApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesCreateTemplateSessionToken != "" {
			sessionToken = &templatesCreateTemplateSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesCreateTemplateProjectSlugInput != "" {
			projectSlugInput = &templatesCreateTemplateProjectSlugInput
		}
	}
	v := &templates.CreateTemplatePayload{
		Name:        types.Slug(body.Name),
		Prompt:      body.Prompt,
		Description: body.Description,
		Arguments:   body.Arguments,
		Engine:      body.Engine,
		Kind:        body.Kind,
	}
	if body.ToolsHint != nil {
		v.ToolsHint = make([]string, len(body.ToolsHint))
		for i, val := range body.ToolsHint {
			v.ToolsHint[i] = val
		}
	}
	if body.ToolUrnsHint != nil {
		v.ToolUrnsHint = make([]string, len(body.ToolUrnsHint))
		for i, val := range body.ToolUrnsHint {
			v.ToolUrnsHint[i] = val
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildUpdateTemplatePayload builds the payload for the templates
// updateTemplate endpoint from CLI flags.
func BuildUpdateTemplatePayload(templatesUpdateTemplateBody string, templatesUpdateTemplateApikeyToken string, templatesUpdateTemplateSessionToken string, templatesUpdateTemplateProjectSlugInput string) (*templates.UpdateTemplatePayload, error) {
	var err error
	var body UpdateTemplateRequestBody
	{
		err = json.Unmarshal([]byte(templatesUpdateTemplateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"arguments\": \"{\\\"name\\\":\\\"example\\\",\\\"email\\\":\\\"mail@example.com\\\"}\",\n      \"description\": \"Repellendus et neque temporibus ea quia.\",\n      \"engine\": \"mustache\",\n      \"id\": \"Occaecati et.\",\n      \"kind\": \"prompt\",\n      \"name\": \"Sit occaecati nulla sint libero quia.\",\n      \"prompt\": \"Ea doloremque.\",\n      \"tool_urns_hint\": [\n         \"Quo aliquam et et voluptates voluptatem repudiandae.\",\n         \"Aut dolorum eum eum nihil ducimus.\",\n         \"Laborum qui sed.\"\n      ],\n      \"tools_hint\": [\n         \"Quidem aut velit cum ratione ad.\",\n         \"Deleniti nihil et.\",\n         \"Aut ullam non.\"\n      ]\n   }'")
		}
		if body.Arguments != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.arguments", *body.Arguments, goa.FormatJSON))
		}
		if body.Engine != nil {
			if !(*body.Engine == "mustache") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.engine", *body.Engine, []any{"mustache"}))
			}
		}
		if body.Kind != nil {
			if !(*body.Kind == "prompt" || *body.Kind == "higher_order_tool") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.kind", *body.Kind, []any{"prompt", "higher_order_tool"}))
			}
		}
		if len(body.ToolsHint) > 20 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tools_hint", body.ToolsHint, len(body.ToolsHint), 20, false))
		}
		if len(body.ToolUrnsHint) > 20 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tool_urns_hint", body.ToolUrnsHint, len(body.ToolUrnsHint), 20, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if templatesUpdateTemplateApikeyToken != "" {
			apikeyToken = &templatesUpdateTemplateApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesUpdateTemplateSessionToken != "" {
			sessionToken = &templatesUpdateTemplateSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesUpdateTemplateProjectSlugInput != "" {
			projectSlugInput = &templatesUpdateTemplateProjectSlugInput
		}
	}
	v := &templates.UpdateTemplatePayload{
		ID:          body.ID,
		Name:        body.Name,
		Prompt:      body.Prompt,
		Description: body.Description,
		Arguments:   body.Arguments,
		Engine:      body.Engine,
		Kind:        body.Kind,
	}
	if body.ToolsHint != nil {
		v.ToolsHint = make([]string, len(body.ToolsHint))
		for i, val := range body.ToolsHint {
			v.ToolsHint[i] = val
		}
	}
	if body.ToolUrnsHint != nil {
		v.ToolUrnsHint = make([]string, len(body.ToolUrnsHint))
		for i, val := range body.ToolUrnsHint {
			v.ToolUrnsHint[i] = val
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetTemplatePayload builds the payload for the templates getTemplate
// endpoint from CLI flags.
func BuildGetTemplatePayload(templatesGetTemplateID string, templatesGetTemplateName string, templatesGetTemplateApikeyToken string, templatesGetTemplateSessionToken string, templatesGetTemplateProjectSlugInput string) (*templates.GetTemplatePayload, error) {
	var id *string
	{
		if templatesGetTemplateID != "" {
			id = &templatesGetTemplateID
		}
	}
	var name *string
	{
		if templatesGetTemplateName != "" {
			name = &templatesGetTemplateName
		}
	}
	var apikeyToken *string
	{
		if templatesGetTemplateApikeyToken != "" {
			apikeyToken = &templatesGetTemplateApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesGetTemplateSessionToken != "" {
			sessionToken = &templatesGetTemplateSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesGetTemplateProjectSlugInput != "" {
			projectSlugInput = &templatesGetTemplateProjectSlugInput
		}
	}
	v := &templates.GetTemplatePayload{}
	v.ID = id
	v.Name = name
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListTemplatesPayload builds the payload for the templates listTemplates
// endpoint from CLI flags.
func BuildListTemplatesPayload(templatesListTemplatesApikeyToken string, templatesListTemplatesSessionToken string, templatesListTemplatesProjectSlugInput string) (*templates.ListTemplatesPayload, error) {
	var apikeyToken *string
	{
		if templatesListTemplatesApikeyToken != "" {
			apikeyToken = &templatesListTemplatesApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesListTemplatesSessionToken != "" {
			sessionToken = &templatesListTemplatesSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesListTemplatesProjectSlugInput != "" {
			projectSlugInput = &templatesListTemplatesProjectSlugInput
		}
	}
	v := &templates.ListTemplatesPayload{}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildDeleteTemplatePayload builds the payload for the templates
// deleteTemplate endpoint from CLI flags.
func BuildDeleteTemplatePayload(templatesDeleteTemplateID string, templatesDeleteTemplateName string, templatesDeleteTemplateApikeyToken string, templatesDeleteTemplateSessionToken string, templatesDeleteTemplateProjectSlugInput string) (*templates.DeleteTemplatePayload, error) {
	var id *string
	{
		if templatesDeleteTemplateID != "" {
			id = &templatesDeleteTemplateID
		}
	}
	var name *string
	{
		if templatesDeleteTemplateName != "" {
			name = &templatesDeleteTemplateName
		}
	}
	var apikeyToken *string
	{
		if templatesDeleteTemplateApikeyToken != "" {
			apikeyToken = &templatesDeleteTemplateApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesDeleteTemplateSessionToken != "" {
			sessionToken = &templatesDeleteTemplateSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesDeleteTemplateProjectSlugInput != "" {
			projectSlugInput = &templatesDeleteTemplateProjectSlugInput
		}
	}
	v := &templates.DeleteTemplatePayload{}
	v.ID = id
	v.Name = name
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildRenderTemplateByIDPayload builds the payload for the templates
// renderTemplateByID endpoint from CLI flags.
func BuildRenderTemplateByIDPayload(templatesRenderTemplateByIDBody string, templatesRenderTemplateByIDID string, templatesRenderTemplateByIDApikeyToken string, templatesRenderTemplateByIDSessionToken string, templatesRenderTemplateByIDProjectSlugInput string) (*templates.RenderTemplateByIDPayload, error) {
	var err error
	var body RenderTemplateByIDRequestBody
	{
		err = json.Unmarshal([]byte(templatesRenderTemplateByIDBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"arguments\": {\n         \"Dolor nam eum.\": \"Mollitia non praesentium eos hic sapiente accusamus.\",\n         \"Nam provident tempora.\": \"Et adipisci sed ratione.\",\n         \"Ut fuga.\": \"Et earum sed neque.\"\n      }\n   }'")
		}
		if body.Arguments == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("arguments", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var id string
	{
		id = templatesRenderTemplateByIDID
	}
	var apikeyToken *string
	{
		if templatesRenderTemplateByIDApikeyToken != "" {
			apikeyToken = &templatesRenderTemplateByIDApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesRenderTemplateByIDSessionToken != "" {
			sessionToken = &templatesRenderTemplateByIDSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesRenderTemplateByIDProjectSlugInput != "" {
			projectSlugInput = &templatesRenderTemplateByIDProjectSlugInput
		}
	}
	v := &templates.RenderTemplateByIDPayload{}
	if body.Arguments != nil {
		v.Arguments = make(map[string]any, len(body.Arguments))
		for key, val := range body.Arguments {
			tk := key
			tv := val
			v.Arguments[tk] = tv
		}
	}
	v.ID = id
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildRenderTemplatePayload builds the payload for the templates
// renderTemplate endpoint from CLI flags.
func BuildRenderTemplatePayload(templatesRenderTemplateBody string, templatesRenderTemplateApikeyToken string, templatesRenderTemplateSessionToken string, templatesRenderTemplateProjectSlugInput string) (*templates.RenderTemplatePayload, error) {
	var err error
	var body RenderTemplateRequestBody
	{
		err = json.Unmarshal([]byte(templatesRenderTemplateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"arguments\": {\n         \"Aspernatur ratione eos aut sit excepturi.\": \"Voluptas vero asperiores ea beatae.\"\n      },\n      \"engine\": \"mustache\",\n      \"kind\": \"prompt\",\n      \"prompt\": \"Dolorem voluptatem eaque.\"\n   }'")
		}
		if body.Arguments == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("arguments", "body"))
		}
		if !(body.Engine == "mustache") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.engine", body.Engine, []any{"mustache"}))
		}
		if !(body.Kind == "prompt" || body.Kind == "higher_order_tool") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.kind", body.Kind, []any{"prompt", "higher_order_tool"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if templatesRenderTemplateApikeyToken != "" {
			apikeyToken = &templatesRenderTemplateApikeyToken
		}
	}
	var sessionToken *string
	{
		if templatesRenderTemplateSessionToken != "" {
			sessionToken = &templatesRenderTemplateSessionToken
		}
	}
	var projectSlugInput *string
	{
		if templatesRenderTemplateProjectSlugInput != "" {
			projectSlugInput = &templatesRenderTemplateProjectSlugInput
		}
	}
	v := &templates.RenderTemplatePayload{
		Prompt: body.Prompt,
		Engine: body.Engine,
		Kind:   body.Kind,
	}
	if body.Arguments != nil {
		v.Arguments = make(map[string]any, len(body.Arguments))
		for key, val := range body.Arguments {
			tk := key
			tv := val
			v.Arguments[tk] = tv
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
