// Code generated by goa v3.24.2, DO NOT EDIT.
//
// chat HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	chat "github.com/speakeasy-api/gram/server/gen/chat"
	goa "goa.design/goa/v3/pkg"
)

// BuildListChatsPayload builds the payload for the chat listChats endpoint
// from CLI flags.
func BuildListChatsPayload(chatListChatsSessionToken string, chatListChatsProjectSlugInput string, chatListChatsChatSessionsToken string) (*chat.ListChatsPayload, error) {
	var sessionToken *string
	{
		if chatListChatsSessionToken != "" {
			sessionToken = &chatListChatsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if chatListChatsProjectSlugInput != "" {
			projectSlugInput = &chatListChatsProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if chatListChatsChatSessionsToken != "" {
			chatSessionsToken = &chatListChatsChatSessionsToken
		}
	}
	v := &chat.ListChatsPayload{}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}

// BuildLoadChatPayload builds the payload for the chat loadChat endpoint from
// CLI flags.
func BuildLoadChatPayload(chatLoadChatID string, chatLoadChatSessionToken string, chatLoadChatProjectSlugInput string, chatLoadChatChatSessionsToken string) (*chat.LoadChatPayload, error) {
	var id string
	{
		id = chatLoadChatID
	}
	var sessionToken *string
	{
		if chatLoadChatSessionToken != "" {
			sessionToken = &chatLoadChatSessionToken
		}
	}
	var projectSlugInput *string
	{
		if chatLoadChatProjectSlugInput != "" {
			projectSlugInput = &chatLoadChatProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if chatLoadChatChatSessionsToken != "" {
			chatSessionsToken = &chatLoadChatChatSessionsToken
		}
	}
	v := &chat.LoadChatPayload{}
	v.ID = id
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}

// BuildGenerateTitlePayload builds the payload for the chat generateTitle
// endpoint from CLI flags.
func BuildGenerateTitlePayload(chatGenerateTitleBody string, chatGenerateTitleSessionToken string, chatGenerateTitleProjectSlugInput string, chatGenerateTitleChatSessionsToken string) (*chat.GenerateTitlePayload, error) {
	var err error
	var body GenerateTitleRequestBody
	{
		err = json.Unmarshal([]byte(chatGenerateTitleBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"abc123\"\n   }'")
		}
	}
	var sessionToken *string
	{
		if chatGenerateTitleSessionToken != "" {
			sessionToken = &chatGenerateTitleSessionToken
		}
	}
	var projectSlugInput *string
	{
		if chatGenerateTitleProjectSlugInput != "" {
			projectSlugInput = &chatGenerateTitleProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if chatGenerateTitleChatSessionsToken != "" {
			chatSessionsToken = &chatGenerateTitleChatSessionsToken
		}
	}
	v := &chat.GenerateTitlePayload{
		ID: body.ID,
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}

// BuildCreditUsagePayload builds the payload for the chat creditUsage endpoint
// from CLI flags.
func BuildCreditUsagePayload(chatCreditUsageSessionToken string, chatCreditUsageProjectSlugInput string, chatCreditUsageChatSessionsToken string) (*chat.CreditUsagePayload, error) {
	var sessionToken *string
	{
		if chatCreditUsageSessionToken != "" {
			sessionToken = &chatCreditUsageSessionToken
		}
	}
	var projectSlugInput *string
	{
		if chatCreditUsageProjectSlugInput != "" {
			projectSlugInput = &chatCreditUsageProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if chatCreditUsageChatSessionsToken != "" {
			chatSessionsToken = &chatCreditUsageChatSessionsToken
		}
	}
	v := &chat.CreditUsagePayload{}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}

// BuildListChatsWithResolutionsPayload builds the payload for the chat
// listChatsWithResolutions endpoint from CLI flags.
func BuildListChatsWithResolutionsPayload(chatListChatsWithResolutionsExternalUserID string, chatListChatsWithResolutionsResolutionStatus string, chatListChatsWithResolutionsLimit string, chatListChatsWithResolutionsOffset string, chatListChatsWithResolutionsSessionToken string, chatListChatsWithResolutionsProjectSlugInput string, chatListChatsWithResolutionsChatSessionsToken string) (*chat.ListChatsWithResolutionsPayload, error) {
	var err error
	var externalUserID *string
	{
		if chatListChatsWithResolutionsExternalUserID != "" {
			externalUserID = &chatListChatsWithResolutionsExternalUserID
		}
	}
	var resolutionStatus *string
	{
		if chatListChatsWithResolutionsResolutionStatus != "" {
			resolutionStatus = &chatListChatsWithResolutionsResolutionStatus
		}
	}
	var limit int
	{
		if chatListChatsWithResolutionsLimit != "" {
			var v int64
			v, err = strconv.ParseInt(chatListChatsWithResolutionsLimit, 10, strconv.IntSize)
			limit = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
			if limit < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
			}
			if limit > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var offset int
	{
		if chatListChatsWithResolutionsOffset != "" {
			var v int64
			v, err = strconv.ParseInt(chatListChatsWithResolutionsOffset, 10, strconv.IntSize)
			offset = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for offset, must be INT")
			}
			if offset < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("offset", offset, 0, true))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sessionToken *string
	{
		if chatListChatsWithResolutionsSessionToken != "" {
			sessionToken = &chatListChatsWithResolutionsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if chatListChatsWithResolutionsProjectSlugInput != "" {
			projectSlugInput = &chatListChatsWithResolutionsProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if chatListChatsWithResolutionsChatSessionsToken != "" {
			chatSessionsToken = &chatListChatsWithResolutionsChatSessionsToken
		}
	}
	v := &chat.ListChatsWithResolutionsPayload{}
	v.ExternalUserID = externalUserID
	v.ResolutionStatus = resolutionStatus
	v.Limit = limit
	v.Offset = offset
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}

// BuildSubmitFeedbackPayload builds the payload for the chat submitFeedback
// endpoint from CLI flags.
func BuildSubmitFeedbackPayload(chatSubmitFeedbackBody string, chatSubmitFeedbackSessionToken string, chatSubmitFeedbackProjectSlugInput string, chatSubmitFeedbackChatSessionsToken string) (*chat.SubmitFeedbackPayload, error) {
	var err error
	var body SubmitFeedbackRequestBody
	{
		err = json.Unmarshal([]byte(chatSubmitFeedbackBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"feedback\": \"failure\",\n      \"id\": \"abc123\"\n   }'")
		}
		if !(body.Feedback == "success" || body.Feedback == "failure") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.feedback", body.Feedback, []any{"success", "failure"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if chatSubmitFeedbackSessionToken != "" {
			sessionToken = &chatSubmitFeedbackSessionToken
		}
	}
	var projectSlugInput *string
	{
		if chatSubmitFeedbackProjectSlugInput != "" {
			projectSlugInput = &chatSubmitFeedbackProjectSlugInput
		}
	}
	var chatSessionsToken *string
	{
		if chatSubmitFeedbackChatSessionsToken != "" {
			chatSessionsToken = &chatSubmitFeedbackChatSessionsToken
		}
	}
	v := &chat.SubmitFeedbackPayload{
		ID:       body.ID,
		Feedback: body.Feedback,
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ChatSessionsToken = chatSessionsToken

	return v, nil
}
