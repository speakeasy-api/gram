// Code generated by goa v3.21.5, DO NOT EDIT.
//
// variations HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"

	variations "github.com/speakeasy-api/gram/server/gen/variations"
	goa "goa.design/goa/v3/pkg"
)

// BuildUpsertGlobalPayload builds the payload for the variations upsertGlobal
// endpoint from CLI flags.
func BuildUpsertGlobalPayload(variationsUpsertGlobalBody string, variationsUpsertGlobalSessionToken string, variationsUpsertGlobalApikeyToken string, variationsUpsertGlobalProjectSlugInput string) (*variations.UpsertGlobalPayload, error) {
	var err error
	var body UpsertGlobalRequestBody
	{
		err = json.Unmarshal([]byte(variationsUpsertGlobalBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"confirm\": \"always\",\n      \"confirm_prompt\": \"Et pariatur.\",\n      \"description\": \"Neque nobis maiores et rerum et.\",\n      \"name\": \"Suscipit iure illo blanditiis enim sunt mollitia.\",\n      \"src_tool_name\": \"Ex illum.\",\n      \"summarizer\": \"Fugit ut porro.\",\n      \"summary\": \"Harum qui velit et.\",\n      \"tags\": [\n         \"Deserunt quo.\",\n         \"Deleniti et numquam.\",\n         \"Eveniet tenetur omnis est et.\",\n         \"Repellendus rerum et ea ab voluptatum quis.\"\n      ]\n   }'")
		}
		if body.Confirm != nil {
			if !(*body.Confirm == "always" || *body.Confirm == "never" || *body.Confirm == "session") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.confirm", *body.Confirm, []any{"always", "never", "session"}))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if variationsUpsertGlobalSessionToken != "" {
			sessionToken = &variationsUpsertGlobalSessionToken
		}
	}
	var apikeyToken *string
	{
		if variationsUpsertGlobalApikeyToken != "" {
			apikeyToken = &variationsUpsertGlobalApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if variationsUpsertGlobalProjectSlugInput != "" {
			projectSlugInput = &variationsUpsertGlobalProjectSlugInput
		}
	}
	v := &variations.UpsertGlobalPayload{
		SrcToolName:   body.SrcToolName,
		Confirm:       body.Confirm,
		ConfirmPrompt: body.ConfirmPrompt,
		Name:          body.Name,
		Summary:       body.Summary,
		Description:   body.Description,
		Summarizer:    body.Summarizer,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildDeleteGlobalPayload builds the payload for the variations deleteGlobal
// endpoint from CLI flags.
func BuildDeleteGlobalPayload(variationsDeleteGlobalVariationID string, variationsDeleteGlobalSessionToken string, variationsDeleteGlobalApikeyToken string, variationsDeleteGlobalProjectSlugInput string) (*variations.DeleteGlobalPayload, error) {
	var variationID string
	{
		variationID = variationsDeleteGlobalVariationID
	}
	var sessionToken *string
	{
		if variationsDeleteGlobalSessionToken != "" {
			sessionToken = &variationsDeleteGlobalSessionToken
		}
	}
	var apikeyToken *string
	{
		if variationsDeleteGlobalApikeyToken != "" {
			apikeyToken = &variationsDeleteGlobalApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if variationsDeleteGlobalProjectSlugInput != "" {
			projectSlugInput = &variationsDeleteGlobalProjectSlugInput
		}
	}
	v := &variations.DeleteGlobalPayload{}
	v.VariationID = variationID
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListGlobalPayload builds the payload for the variations listGlobal
// endpoint from CLI flags.
func BuildListGlobalPayload(variationsListGlobalSessionToken string, variationsListGlobalApikeyToken string, variationsListGlobalProjectSlugInput string) (*variations.ListGlobalPayload, error) {
	var sessionToken *string
	{
		if variationsListGlobalSessionToken != "" {
			sessionToken = &variationsListGlobalSessionToken
		}
	}
	var apikeyToken *string
	{
		if variationsListGlobalApikeyToken != "" {
			apikeyToken = &variationsListGlobalApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if variationsListGlobalProjectSlugInput != "" {
			projectSlugInput = &variationsListGlobalProjectSlugInput
		}
	}
	v := &variations.ListGlobalPayload{}
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
