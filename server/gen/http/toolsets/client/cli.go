// Code generated by goa v3.24.1, DO NOT EDIT.
//
// toolsets HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	toolsets "github.com/speakeasy-api/gram/server/gen/toolsets"
	types "github.com/speakeasy-api/gram/server/gen/types"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateToolsetPayload builds the payload for the toolsets createToolset
// endpoint from CLI flags.
func BuildCreateToolsetPayload(toolsetsCreateToolsetBody string, toolsetsCreateToolsetSessionToken string, toolsetsCreateToolsetApikeyToken string, toolsetsCreateToolsetProjectSlugInput string) (*toolsets.CreateToolsetPayload, error) {
	var err error
	var body CreateToolsetRequestBody
	{
		err = json.Unmarshal([]byte(toolsetsCreateToolsetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"default_environment_slug\": \"ozc\",\n      \"description\": \"Sed eum provident aspernatur autem temporibus qui.\",\n      \"name\": \"Velit consequatur aut porro ut minus.\",\n      \"resource_urns\": [\n         \"Aut nesciunt voluptatem porro laborum.\",\n         \"Rerum nihil.\",\n         \"Voluptatem corporis.\",\n         \"Qui labore harum ut sequi.\"\n      ],\n      \"tool_urns\": [\n         \"Culpa consectetur omnis est cum similique quis.\",\n         \"Dolorum incidunt inventore.\"\n      ]\n   }'")
		}
		if body.DefaultEnvironmentSlug != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.default_environment_slug", *body.DefaultEnvironmentSlug, "^[a-z0-9_-]{1,128}$"))
		}
		if body.DefaultEnvironmentSlug != nil {
			if utf8.RuneCountInString(*body.DefaultEnvironmentSlug) > 40 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.default_environment_slug", *body.DefaultEnvironmentSlug, utf8.RuneCountInString(*body.DefaultEnvironmentSlug), 40, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsCreateToolsetSessionToken != "" {
			sessionToken = &toolsetsCreateToolsetSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsCreateToolsetApikeyToken != "" {
			apikeyToken = &toolsetsCreateToolsetApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsCreateToolsetProjectSlugInput != "" {
			projectSlugInput = &toolsetsCreateToolsetProjectSlugInput
		}
	}
	v := &toolsets.CreateToolsetPayload{
		Name:        body.Name,
		Description: body.Description,
	}
	if body.DefaultEnvironmentSlug != nil {
		defaultEnvironmentSlug := types.Slug(*body.DefaultEnvironmentSlug)
		v.DefaultEnvironmentSlug = &defaultEnvironmentSlug
	}
	if body.ToolUrns != nil {
		v.ToolUrns = make([]string, len(body.ToolUrns))
		for i, val := range body.ToolUrns {
			v.ToolUrns[i] = val
		}
	}
	if body.ResourceUrns != nil {
		v.ResourceUrns = make([]string, len(body.ResourceUrns))
		for i, val := range body.ResourceUrns {
			v.ResourceUrns[i] = val
		}
	}
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListToolsetsPayload builds the payload for the toolsets listToolsets
// endpoint from CLI flags.
func BuildListToolsetsPayload(toolsetsListToolsetsSessionToken string, toolsetsListToolsetsApikeyToken string, toolsetsListToolsetsProjectSlugInput string) (*toolsets.ListToolsetsPayload, error) {
	var sessionToken *string
	{
		if toolsetsListToolsetsSessionToken != "" {
			sessionToken = &toolsetsListToolsetsSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsListToolsetsApikeyToken != "" {
			apikeyToken = &toolsetsListToolsetsApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsListToolsetsProjectSlugInput != "" {
			projectSlugInput = &toolsetsListToolsetsProjectSlugInput
		}
	}
	v := &toolsets.ListToolsetsPayload{}
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildUpdateToolsetPayload builds the payload for the toolsets updateToolset
// endpoint from CLI flags.
func BuildUpdateToolsetPayload(toolsetsUpdateToolsetBody string, toolsetsUpdateToolsetSlug string, toolsetsUpdateToolsetSessionToken string, toolsetsUpdateToolsetApikeyToken string, toolsetsUpdateToolsetProjectSlugInput string) (*toolsets.UpdateToolsetPayload, error) {
	var err error
	var body UpdateToolsetRequestBody
	{
		err = json.Unmarshal([]byte(toolsetsUpdateToolsetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"custom_domain_id\": \"Cumque voluptatibus.\",\n      \"default_environment_slug\": \"dkg\",\n      \"description\": \"In et.\",\n      \"mcp_enabled\": true,\n      \"mcp_is_public\": true,\n      \"mcp_slug\": \"xiw\",\n      \"name\": \"Quae sunt sit.\",\n      \"prompt_template_names\": [\n         \"Expedita unde sit aut ducimus.\",\n         \"Quia atque ut deserunt.\"\n      ],\n      \"resource_urns\": [\n         \"Praesentium qui laboriosam consequatur.\",\n         \"Vel facilis asperiores similique deserunt asperiores atque.\"\n      ],\n      \"tool_selection_mode\": \"Occaecati libero sint.\",\n      \"tool_urns\": [\n         \"Eum qui.\",\n         \"Aut ut.\",\n         \"Sequi nobis laudantium.\",\n         \"Ex dolor qui rerum eius repellendus perspiciatis.\"\n      ]\n   }'")
		}
		if body.DefaultEnvironmentSlug != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.default_environment_slug", *body.DefaultEnvironmentSlug, "^[a-z0-9_-]{1,128}$"))
		}
		if body.DefaultEnvironmentSlug != nil {
			if utf8.RuneCountInString(*body.DefaultEnvironmentSlug) > 40 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.default_environment_slug", *body.DefaultEnvironmentSlug, utf8.RuneCountInString(*body.DefaultEnvironmentSlug), 40, false))
			}
		}
		if body.McpSlug != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.mcp_slug", *body.McpSlug, "^[a-z0-9_-]{1,128}$"))
		}
		if body.McpSlug != nil {
			if utf8.RuneCountInString(*body.McpSlug) > 40 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.mcp_slug", *body.McpSlug, utf8.RuneCountInString(*body.McpSlug), 40, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var slug string
	{
		slug = toolsetsUpdateToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsUpdateToolsetSessionToken != "" {
			sessionToken = &toolsetsUpdateToolsetSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsUpdateToolsetApikeyToken != "" {
			apikeyToken = &toolsetsUpdateToolsetApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsUpdateToolsetProjectSlugInput != "" {
			projectSlugInput = &toolsetsUpdateToolsetProjectSlugInput
		}
	}
	v := &toolsets.UpdateToolsetPayload{
		Name:              body.Name,
		Description:       body.Description,
		McpEnabled:        body.McpEnabled,
		McpIsPublic:       body.McpIsPublic,
		CustomDomainID:    body.CustomDomainID,
		ToolSelectionMode: body.ToolSelectionMode,
	}
	if body.DefaultEnvironmentSlug != nil {
		defaultEnvironmentSlug := types.Slug(*body.DefaultEnvironmentSlug)
		v.DefaultEnvironmentSlug = &defaultEnvironmentSlug
	}
	if body.McpSlug != nil {
		mcpSlug := types.Slug(*body.McpSlug)
		v.McpSlug = &mcpSlug
	}
	if body.PromptTemplateNames != nil {
		v.PromptTemplateNames = make([]string, len(body.PromptTemplateNames))
		for i, val := range body.PromptTemplateNames {
			v.PromptTemplateNames[i] = val
		}
	}
	if body.ToolUrns != nil {
		v.ToolUrns = make([]string, len(body.ToolUrns))
		for i, val := range body.ToolUrns {
			v.ToolUrns[i] = val
		}
	}
	if body.ResourceUrns != nil {
		v.ResourceUrns = make([]string, len(body.ResourceUrns))
		for i, val := range body.ResourceUrns {
			v.ResourceUrns[i] = val
		}
	}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildDeleteToolsetPayload builds the payload for the toolsets deleteToolset
// endpoint from CLI flags.
func BuildDeleteToolsetPayload(toolsetsDeleteToolsetSlug string, toolsetsDeleteToolsetSessionToken string, toolsetsDeleteToolsetApikeyToken string, toolsetsDeleteToolsetProjectSlugInput string) (*toolsets.DeleteToolsetPayload, error) {
	var err error
	var slug string
	{
		slug = toolsetsDeleteToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsDeleteToolsetSessionToken != "" {
			sessionToken = &toolsetsDeleteToolsetSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsDeleteToolsetApikeyToken != "" {
			apikeyToken = &toolsetsDeleteToolsetApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsDeleteToolsetProjectSlugInput != "" {
			projectSlugInput = &toolsetsDeleteToolsetProjectSlugInput
		}
	}
	v := &toolsets.DeleteToolsetPayload{}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetToolsetPayload builds the payload for the toolsets getToolset
// endpoint from CLI flags.
func BuildGetToolsetPayload(toolsetsGetToolsetSlug string, toolsetsGetToolsetSessionToken string, toolsetsGetToolsetApikeyToken string, toolsetsGetToolsetProjectSlugInput string) (*toolsets.GetToolsetPayload, error) {
	var err error
	var slug string
	{
		slug = toolsetsGetToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsGetToolsetSessionToken != "" {
			sessionToken = &toolsetsGetToolsetSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsGetToolsetApikeyToken != "" {
			apikeyToken = &toolsetsGetToolsetApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsGetToolsetProjectSlugInput != "" {
			projectSlugInput = &toolsetsGetToolsetProjectSlugInput
		}
	}
	v := &toolsets.GetToolsetPayload{}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildCheckMCPSlugAvailabilityPayload builds the payload for the toolsets
// checkMCPSlugAvailability endpoint from CLI flags.
func BuildCheckMCPSlugAvailabilityPayload(toolsetsCheckMCPSlugAvailabilitySlug string, toolsetsCheckMCPSlugAvailabilitySessionToken string, toolsetsCheckMCPSlugAvailabilityApikeyToken string, toolsetsCheckMCPSlugAvailabilityProjectSlugInput string) (*toolsets.CheckMCPSlugAvailabilityPayload, error) {
	var err error
	var slug string
	{
		slug = toolsetsCheckMCPSlugAvailabilitySlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsCheckMCPSlugAvailabilitySessionToken != "" {
			sessionToken = &toolsetsCheckMCPSlugAvailabilitySessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsCheckMCPSlugAvailabilityApikeyToken != "" {
			apikeyToken = &toolsetsCheckMCPSlugAvailabilityApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsCheckMCPSlugAvailabilityProjectSlugInput != "" {
			projectSlugInput = &toolsetsCheckMCPSlugAvailabilityProjectSlugInput
		}
	}
	v := &toolsets.CheckMCPSlugAvailabilityPayload{}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildCloneToolsetPayload builds the payload for the toolsets cloneToolset
// endpoint from CLI flags.
func BuildCloneToolsetPayload(toolsetsCloneToolsetSlug string, toolsetsCloneToolsetSessionToken string, toolsetsCloneToolsetProjectSlugInput string, toolsetsCloneToolsetApikeyToken string) (*toolsets.CloneToolsetPayload, error) {
	var err error
	var slug string
	{
		slug = toolsetsCloneToolsetSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsCloneToolsetSessionToken != "" {
			sessionToken = &toolsetsCloneToolsetSessionToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsCloneToolsetProjectSlugInput != "" {
			projectSlugInput = &toolsetsCloneToolsetProjectSlugInput
		}
	}
	var apikeyToken *string
	{
		if toolsetsCloneToolsetApikeyToken != "" {
			apikeyToken = &toolsetsCloneToolsetApikeyToken
		}
	}
	v := &toolsets.CloneToolsetPayload{}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput
	v.ApikeyToken = apikeyToken

	return v, nil
}

// BuildAddExternalOAuthServerPayload builds the payload for the toolsets
// addExternalOAuthServer endpoint from CLI flags.
func BuildAddExternalOAuthServerPayload(toolsetsAddExternalOAuthServerBody string, toolsetsAddExternalOAuthServerSlug string, toolsetsAddExternalOAuthServerSessionToken string, toolsetsAddExternalOAuthServerApikeyToken string, toolsetsAddExternalOAuthServerProjectSlugInput string) (*toolsets.AddExternalOAuthServerPayload, error) {
	var err error
	var body AddExternalOAuthServerRequestBody
	{
		err = json.Unmarshal([]byte(toolsetsAddExternalOAuthServerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"external_oauth_server\": {\n         \"metadata\": \"Dolores ullam necessitatibus et tenetur nam.\",\n         \"slug\": \"861\"\n      }\n   }'")
		}
		if body.ExternalOauthServer == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("external_oauth_server", "body"))
		}
		if body.ExternalOauthServer != nil {
			if err2 := ValidateExternalOAuthServerFormRequestBody(body.ExternalOauthServer); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var slug string
	{
		slug = toolsetsAddExternalOAuthServerSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsAddExternalOAuthServerSessionToken != "" {
			sessionToken = &toolsetsAddExternalOAuthServerSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsAddExternalOAuthServerApikeyToken != "" {
			apikeyToken = &toolsetsAddExternalOAuthServerApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsAddExternalOAuthServerProjectSlugInput != "" {
			projectSlugInput = &toolsetsAddExternalOAuthServerProjectSlugInput
		}
	}
	v := &toolsets.AddExternalOAuthServerPayload{}
	if body.ExternalOauthServer != nil {
		v.ExternalOauthServer = marshalExternalOAuthServerFormRequestBodyToTypesExternalOAuthServerForm(body.ExternalOauthServer)
	}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildRemoveOAuthServerPayload builds the payload for the toolsets
// removeOAuthServer endpoint from CLI flags.
func BuildRemoveOAuthServerPayload(toolsetsRemoveOAuthServerSlug string, toolsetsRemoveOAuthServerSessionToken string, toolsetsRemoveOAuthServerApikeyToken string, toolsetsRemoveOAuthServerProjectSlugInput string) (*toolsets.RemoveOAuthServerPayload, error) {
	var err error
	var slug string
	{
		slug = toolsetsRemoveOAuthServerSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsRemoveOAuthServerSessionToken != "" {
			sessionToken = &toolsetsRemoveOAuthServerSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsRemoveOAuthServerApikeyToken != "" {
			apikeyToken = &toolsetsRemoveOAuthServerApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsRemoveOAuthServerProjectSlugInput != "" {
			projectSlugInput = &toolsetsRemoveOAuthServerProjectSlugInput
		}
	}
	v := &toolsets.RemoveOAuthServerPayload{}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildAddOAuthProxyServerPayload builds the payload for the toolsets
// addOAuthProxyServer endpoint from CLI flags.
func BuildAddOAuthProxyServerPayload(toolsetsAddOAuthProxyServerBody string, toolsetsAddOAuthProxyServerSlug string, toolsetsAddOAuthProxyServerSessionToken string, toolsetsAddOAuthProxyServerApikeyToken string, toolsetsAddOAuthProxyServerProjectSlugInput string) (*toolsets.AddOAuthProxyServerPayload, error) {
	var err error
	var body AddOAuthProxyServerRequestBody
	{
		err = json.Unmarshal([]byte(toolsetsAddOAuthProxyServerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"oauth_proxy_server\": {\n         \"authorization_endpoint\": \"Autem consequuntur nihil illo occaecati et nihil.\",\n         \"environment_slug\": \"m7m\",\n         \"provider_type\": \"gram\",\n         \"scopes_supported\": [\n            \"Quos labore cum sed dicta maxime aspernatur.\",\n            \"Ipsam sint amet pariatur ipsa sunt.\"\n         ],\n         \"slug\": \"vxk\",\n         \"token_endpoint\": \"Accusamus voluptas et tenetur voluptas voluptate.\",\n         \"token_endpoint_auth_methods_supported\": [\n            \"Quia cumque esse delectus praesentium.\",\n            \"Sed blanditiis corporis voluptatum quia iure.\",\n            \"Sed commodi.\",\n            \"Tenetur quaerat quo.\"\n         ]\n      }\n   }'")
		}
		if body.OauthProxyServer == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("oauth_proxy_server", "body"))
		}
		if body.OauthProxyServer != nil {
			if err2 := ValidateOAuthProxyServerFormRequestBody(body.OauthProxyServer); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var slug string
	{
		slug = toolsetsAddOAuthProxyServerSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsAddOAuthProxyServerSessionToken != "" {
			sessionToken = &toolsetsAddOAuthProxyServerSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsAddOAuthProxyServerApikeyToken != "" {
			apikeyToken = &toolsetsAddOAuthProxyServerApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsAddOAuthProxyServerProjectSlugInput != "" {
			projectSlugInput = &toolsetsAddOAuthProxyServerProjectSlugInput
		}
	}
	v := &toolsets.AddOAuthProxyServerPayload{}
	if body.OauthProxyServer != nil {
		v.OauthProxyServer = marshalOAuthProxyServerFormRequestBodyToTypesOAuthProxyServerForm(body.OauthProxyServer)
	}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildUpdateExternalOAuthServerPayload builds the payload for the toolsets
// updateExternalOAuthServer endpoint from CLI flags.
func BuildUpdateExternalOAuthServerPayload(toolsetsUpdateExternalOAuthServerBody string, toolsetsUpdateExternalOAuthServerSlug string, toolsetsUpdateExternalOAuthServerSessionToken string, toolsetsUpdateExternalOAuthServerApikeyToken string, toolsetsUpdateExternalOAuthServerProjectSlugInput string) (*toolsets.UpdateExternalOAuthServerPayload, error) {
	var err error
	var body UpdateExternalOAuthServerRequestBody
	{
		err = json.Unmarshal([]byte(toolsetsUpdateExternalOAuthServerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"metadata\": \"Repellendus dolores provident earum.\"\n   }'")
		}
		if body.Metadata == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("metadata", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var slug string
	{
		slug = toolsetsUpdateExternalOAuthServerSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsUpdateExternalOAuthServerSessionToken != "" {
			sessionToken = &toolsetsUpdateExternalOAuthServerSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsUpdateExternalOAuthServerApikeyToken != "" {
			apikeyToken = &toolsetsUpdateExternalOAuthServerApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsUpdateExternalOAuthServerProjectSlugInput != "" {
			projectSlugInput = &toolsetsUpdateExternalOAuthServerProjectSlugInput
		}
	}
	v := &toolsets.UpdateExternalOAuthServerPayload{
		Metadata: body.Metadata,
	}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildUpdateOAuthProxyServerPayload builds the payload for the toolsets
// updateOAuthProxyServer endpoint from CLI flags.
func BuildUpdateOAuthProxyServerPayload(toolsetsUpdateOAuthProxyServerBody string, toolsetsUpdateOAuthProxyServerSlug string, toolsetsUpdateOAuthProxyServerSessionToken string, toolsetsUpdateOAuthProxyServerApikeyToken string, toolsetsUpdateOAuthProxyServerProjectSlugInput string) (*toolsets.UpdateOAuthProxyServerPayload, error) {
	var err error
	var body UpdateOAuthProxyServerRequestBody
	{
		err = json.Unmarshal([]byte(toolsetsUpdateOAuthProxyServerBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"authorization_endpoint\": \"Dolor doloremque ipsam corrupti.\",\n      \"environment_slug\": \"kbc\",\n      \"scopes_supported\": [\n         \"Harum dicta quis quia et sequi beatae.\",\n         \"Adipisci sint sed sapiente et aperiam.\"\n      ],\n      \"token_endpoint\": \"Modi error.\",\n      \"token_endpoint_auth_methods_supported\": [\n         \"Quia pariatur dolores debitis rerum.\",\n         \"Tempora necessitatibus deserunt blanditiis saepe sed.\",\n         \"Aut odit ut.\",\n         \"Rem nostrum.\"\n      ]\n   }'")
		}
		if body.EnvironmentSlug != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.environment_slug", *body.EnvironmentSlug, "^[a-z0-9_-]{1,128}$"))
		}
		if body.EnvironmentSlug != nil {
			if utf8.RuneCountInString(*body.EnvironmentSlug) > 40 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.environment_slug", *body.EnvironmentSlug, utf8.RuneCountInString(*body.EnvironmentSlug), 40, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var slug string
	{
		slug = toolsetsUpdateOAuthProxyServerSlug
		err = goa.MergeErrors(err, goa.ValidatePattern("slug", slug, "^[a-z0-9_-]{1,128}$"))
		if utf8.RuneCountInString(slug) > 40 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("slug", slug, utf8.RuneCountInString(slug), 40, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if toolsetsUpdateOAuthProxyServerSessionToken != "" {
			sessionToken = &toolsetsUpdateOAuthProxyServerSessionToken
		}
	}
	var apikeyToken *string
	{
		if toolsetsUpdateOAuthProxyServerApikeyToken != "" {
			apikeyToken = &toolsetsUpdateOAuthProxyServerApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if toolsetsUpdateOAuthProxyServerProjectSlugInput != "" {
			projectSlugInput = &toolsetsUpdateOAuthProxyServerProjectSlugInput
		}
	}
	v := &toolsets.UpdateOAuthProxyServerPayload{
		AuthorizationEndpoint: body.AuthorizationEndpoint,
		TokenEndpoint:         body.TokenEndpoint,
	}
	if body.EnvironmentSlug != nil {
		environmentSlug := types.Slug(*body.EnvironmentSlug)
		v.EnvironmentSlug = &environmentSlug
	}
	if body.ScopesSupported != nil {
		v.ScopesSupported = make([]string, len(body.ScopesSupported))
		for i, val := range body.ScopesSupported {
			v.ScopesSupported[i] = val
		}
	}
	if body.TokenEndpointAuthMethodsSupported != nil {
		v.TokenEndpointAuthMethodsSupported = make([]string, len(body.TokenEndpointAuthMethodsSupported))
		for i, val := range body.TokenEndpointAuthMethodsSupported {
			v.TokenEndpointAuthMethodsSupported[i] = val
		}
	}
	v.Slug = types.Slug(slug)
	v.SessionToken = sessionToken
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
