// Code generated by goa v3.23.4, DO NOT EDIT.
//
// notifications HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	notifications "github.com/speakeasy-api/gram/server/gen/notifications"
	goa "goa.design/goa/v3/pkg"
)

// BuildListNotificationsPayload builds the payload for the notifications
// listNotifications endpoint from CLI flags.
func BuildListNotificationsPayload(notificationsListNotificationsArchived string, notificationsListNotificationsLimit string, notificationsListNotificationsCursor string, notificationsListNotificationsSessionToken string, notificationsListNotificationsProjectSlugInput string) (*notifications.ListNotificationsPayload, error) {
	var err error
	var archived bool
	{
		if notificationsListNotificationsArchived != "" {
			archived, err = strconv.ParseBool(notificationsListNotificationsArchived)
			if err != nil {
				return nil, fmt.Errorf("invalid value for archived, must be BOOL")
			}
		}
	}
	var limit int32
	{
		if notificationsListNotificationsLimit != "" {
			var v int64
			v, err = strconv.ParseInt(notificationsListNotificationsLimit, 10, 32)
			limit = int32(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT32")
			}
			if limit > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if notificationsListNotificationsCursor != "" {
			cursor = &notificationsListNotificationsCursor
		}
	}
	var sessionToken *string
	{
		if notificationsListNotificationsSessionToken != "" {
			sessionToken = &notificationsListNotificationsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if notificationsListNotificationsProjectSlugInput != "" {
			projectSlugInput = &notificationsListNotificationsProjectSlugInput
		}
	}
	v := &notifications.ListNotificationsPayload{}
	v.Archived = archived
	v.Limit = limit
	v.Cursor = cursor
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildCreateNotificationPayload builds the payload for the notifications
// createNotification endpoint from CLI flags.
func BuildCreateNotificationPayload(notificationsCreateNotificationBody string, notificationsCreateNotificationSessionToken string, notificationsCreateNotificationProjectSlugInput string) (*notifications.CreateNotificationPayload, error) {
	var err error
	var body CreateNotificationRequestBody
	{
		err = json.Unmarshal([]byte(notificationsCreateNotificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"level\": \"success\",\n      \"message\": \"j64\",\n      \"resourceId\": \"8sj\",\n      \"resourceType\": \"023\",\n      \"title\": \"jc4\",\n      \"type\": \"user_action\"\n   }'")
		}
		if !(body.Type == "system" || body.Type == "user_action") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"system", "user_action"}))
		}
		if !(body.Level == "info" || body.Level == "success" || body.Level == "warning" || body.Level == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.level", body.Level, []any{"info", "success", "warning", "error"}))
		}
		if utf8.RuneCountInString(body.Title) > 200 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", body.Title, utf8.RuneCountInString(body.Title), 200, false))
		}
		if body.Message != nil {
			if utf8.RuneCountInString(*body.Message) > 2000 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.message", *body.Message, utf8.RuneCountInString(*body.Message), 2000, false))
			}
		}
		if body.ResourceType != nil {
			if utf8.RuneCountInString(*body.ResourceType) > 50 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.resourceType", *body.ResourceType, utf8.RuneCountInString(*body.ResourceType), 50, false))
			}
		}
		if body.ResourceID != nil {
			if utf8.RuneCountInString(*body.ResourceID) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.resourceId", *body.ResourceID, utf8.RuneCountInString(*body.ResourceID), 100, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if notificationsCreateNotificationSessionToken != "" {
			sessionToken = &notificationsCreateNotificationSessionToken
		}
	}
	var projectSlugInput *string
	{
		if notificationsCreateNotificationProjectSlugInput != "" {
			projectSlugInput = &notificationsCreateNotificationProjectSlugInput
		}
	}
	v := &notifications.CreateNotificationPayload{
		Type:         notifications.NotificationType(body.Type),
		Level:        notifications.NotificationLevel(body.Level),
		Title:        body.Title,
		Message:      body.Message,
		ResourceType: body.ResourceType,
		ResourceID:   body.ResourceID,
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildArchiveNotificationPayload builds the payload for the notifications
// archiveNotification endpoint from CLI flags.
func BuildArchiveNotificationPayload(notificationsArchiveNotificationBody string, notificationsArchiveNotificationSessionToken string, notificationsArchiveNotificationProjectSlugInput string) (*notifications.ArchiveNotificationPayload, error) {
	var err error
	var body ArchiveNotificationRequestBody
	{
		err = json.Unmarshal([]byte(notificationsArchiveNotificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"4f40d9d6-1816-448a-9be0-b72163f57a83\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", body.ID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var sessionToken *string
	{
		if notificationsArchiveNotificationSessionToken != "" {
			sessionToken = &notificationsArchiveNotificationSessionToken
		}
	}
	var projectSlugInput *string
	{
		if notificationsArchiveNotificationProjectSlugInput != "" {
			projectSlugInput = &notificationsArchiveNotificationProjectSlugInput
		}
	}
	v := &notifications.ArchiveNotificationPayload{
		ID: body.ID,
	}
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildGetUnreadCountPayload builds the payload for the notifications
// getUnreadCount endpoint from CLI flags.
func BuildGetUnreadCountPayload(notificationsGetUnreadCountSince string, notificationsGetUnreadCountSessionToken string, notificationsGetUnreadCountProjectSlugInput string) (*notifications.GetUnreadCountPayload, error) {
	var err error
	var since *string
	{
		if notificationsGetUnreadCountSince != "" {
			since = &notificationsGetUnreadCountSince
			err = goa.MergeErrors(err, goa.ValidateFormat("since", *since, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var sessionToken *string
	{
		if notificationsGetUnreadCountSessionToken != "" {
			sessionToken = &notificationsGetUnreadCountSessionToken
		}
	}
	var projectSlugInput *string
	{
		if notificationsGetUnreadCountProjectSlugInput != "" {
			projectSlugInput = &notificationsGetUnreadCountProjectSlugInput
		}
	}
	v := &notifications.GetUnreadCountPayload{}
	v.Since = since
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
