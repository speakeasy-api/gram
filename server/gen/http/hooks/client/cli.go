// Code generated by goa v3.25.1, DO NOT EDIT.
//
// hooks HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"

	hooks "github.com/speakeasy-api/gram/server/gen/hooks"
)

// BuildPreToolUsePayload builds the payload for the hooks preToolUse endpoint
// from CLI flags.
func BuildPreToolUsePayload(hooksPreToolUseBody string, hooksPreToolUseApikeyToken string, hooksPreToolUseProjectSlugInput string) (*hooks.PreToolUsePayload, error) {
	var err error
	var body PreToolUseRequestBody
	{
		err = json.Unmarshal([]byte(hooksPreToolUseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tool_input\": \"abc123\",\n      \"tool_name\": \"abc123\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if hooksPreToolUseApikeyToken != "" {
			apikeyToken = &hooksPreToolUseApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if hooksPreToolUseProjectSlugInput != "" {
			projectSlugInput = &hooksPreToolUseProjectSlugInput
		}
	}
	v := &hooks.PreToolUsePayload{
		ToolName:  body.ToolName,
		ToolInput: body.ToolInput,
	}
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildPostToolUsePayload builds the payload for the hooks postToolUse
// endpoint from CLI flags.
func BuildPostToolUsePayload(hooksPostToolUseBody string, hooksPostToolUseApikeyToken string, hooksPostToolUseProjectSlugInput string) (*hooks.PostToolUsePayload, error) {
	var err error
	var body PostToolUseRequestBody
	{
		err = json.Unmarshal([]byte(hooksPostToolUseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tool_input\": \"abc123\",\n      \"tool_name\": \"abc123\",\n      \"tool_response\": \"abc123\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if hooksPostToolUseApikeyToken != "" {
			apikeyToken = &hooksPostToolUseApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if hooksPostToolUseProjectSlugInput != "" {
			projectSlugInput = &hooksPostToolUseProjectSlugInput
		}
	}
	v := &hooks.PostToolUsePayload{
		ToolName:     body.ToolName,
		ToolInput:    body.ToolInput,
		ToolResponse: body.ToolResponse,
	}
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildPostToolUseFailurePayload builds the payload for the hooks
// postToolUseFailure endpoint from CLI flags.
func BuildPostToolUseFailurePayload(hooksPostToolUseFailureBody string, hooksPostToolUseFailureApikeyToken string, hooksPostToolUseFailureProjectSlugInput string) (*hooks.PostToolUseFailurePayload, error) {
	var err error
	var body PostToolUseFailureRequestBody
	{
		err = json.Unmarshal([]byte(hooksPostToolUseFailureBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tool_error\": \"abc123\",\n      \"tool_input\": \"abc123\",\n      \"tool_name\": \"abc123\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if hooksPostToolUseFailureApikeyToken != "" {
			apikeyToken = &hooksPostToolUseFailureApikeyToken
		}
	}
	var projectSlugInput *string
	{
		if hooksPostToolUseFailureProjectSlugInput != "" {
			projectSlugInput = &hooksPostToolUseFailureProjectSlugInput
		}
	}
	v := &hooks.PostToolUseFailurePayload{
		ToolName:  body.ToolName,
		ToolInput: body.ToolInput,
		ToolError: body.ToolError,
	}
	v.ApikeyToken = apikeyToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
