// Code generated by goa v3.23.1, DO NOT EDIT.
//
// logs HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	logs "github.com/speakeasy-api/gram/server/gen/logs"
	goa "goa.design/goa/v3/pkg"
)

// BuildListLogsPayload builds the payload for the logs listLogs endpoint from
// CLI flags.
func BuildListLogsPayload(logsListLogsToolID string, logsListLogsTsStart string, logsListLogsTsEnd string, logsListLogsCursor string, logsListLogsStatus string, logsListLogsServerName string, logsListLogsToolName string, logsListLogsToolType string, logsListLogsToolUrns string, logsListLogsPerPage string, logsListLogsDirection string, logsListLogsSort string, logsListLogsApikeyToken string, logsListLogsSessionToken string, logsListLogsProjectSlugInput string) (*logs.ListLogsPayload, error) {
	var err error
	var toolID *string
	{
		if logsListLogsToolID != "" {
			toolID = &logsListLogsToolID
			err = goa.MergeErrors(err, goa.ValidateFormat("tool_id", *toolID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsStart *string
	{
		if logsListLogsTsStart != "" {
			tsStart = &logsListLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListLogsTsEnd != "" {
			tsEnd = &logsListLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListLogsCursor != "" {
			cursor = &logsListLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var status *string
	{
		if logsListLogsStatus != "" {
			status = &logsListLogsStatus
			if !(*status == "success" || *status == "failure") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"success", "failure"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var serverName *string
	{
		if logsListLogsServerName != "" {
			serverName = &logsListLogsServerName
		}
	}
	var toolName *string
	{
		if logsListLogsToolName != "" {
			toolName = &logsListLogsToolName
		}
	}
	var toolType *string
	{
		if logsListLogsToolType != "" {
			toolType = &logsListLogsToolType
			if !(*toolType == "http" || *toolType == "function" || *toolType == "prompt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tool_type", *toolType, []any{"http", "function", "prompt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var toolUrns []string
	{
		if logsListLogsToolUrns != "" {
			err = json.Unmarshal([]byte(logsListLogsToolUrns), &toolUrns)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for toolUrns, \nerror: %s, \nexample of valid JSON:\n%s", err, "'[\n      \"Modi autem maiores.\",\n      \"Tempore at.\"\n   ]'")
			}
		}
	}
	var perPage int
	{
		if logsListLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListLogsDirection != "" {
			direction = logsListLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListLogsSort != "" {
			sort = logsListLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListLogsApikeyToken != "" {
			apikeyToken = &logsListLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListLogsSessionToken != "" {
			sessionToken = &logsListLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListLogsProjectSlugInput != "" {
			projectSlugInput = &logsListLogsProjectSlugInput
		}
	}
	v := &logs.ListLogsPayload{}
	v.ToolID = toolID
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.Cursor = cursor
	v.Status = status
	v.ServerName = serverName
	v.ToolName = toolName
	v.ToolType = toolType
	v.ToolUrns = toolUrns
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListToolExecutionLogsPayload builds the payload for the logs
// listToolExecutionLogs endpoint from CLI flags.
func BuildListToolExecutionLogsPayload(logsListToolExecutionLogsTsStart string, logsListToolExecutionLogsTsEnd string, logsListToolExecutionLogsDeploymentID string, logsListToolExecutionLogsFunctionID string, logsListToolExecutionLogsInstance string, logsListToolExecutionLogsLevel string, logsListToolExecutionLogsSource string, logsListToolExecutionLogsCursor string, logsListToolExecutionLogsPerPage string, logsListToolExecutionLogsDirection string, logsListToolExecutionLogsSort string, logsListToolExecutionLogsApikeyToken string, logsListToolExecutionLogsSessionToken string, logsListToolExecutionLogsProjectSlugInput string) (*logs.ListToolExecutionLogsPayload, error) {
	var err error
	var tsStart *string
	{
		if logsListToolExecutionLogsTsStart != "" {
			tsStart = &logsListToolExecutionLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListToolExecutionLogsTsEnd != "" {
			tsEnd = &logsListToolExecutionLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var deploymentID *string
	{
		if logsListToolExecutionLogsDeploymentID != "" {
			deploymentID = &logsListToolExecutionLogsDeploymentID
			err = goa.MergeErrors(err, goa.ValidateFormat("deployment_id", *deploymentID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var functionID *string
	{
		if logsListToolExecutionLogsFunctionID != "" {
			functionID = &logsListToolExecutionLogsFunctionID
			err = goa.MergeErrors(err, goa.ValidateFormat("function_id", *functionID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var instance *string
	{
		if logsListToolExecutionLogsInstance != "" {
			instance = &logsListToolExecutionLogsInstance
		}
	}
	var level *string
	{
		if logsListToolExecutionLogsLevel != "" {
			level = &logsListToolExecutionLogsLevel
			if !(*level == "debug" || *level == "info" || *level == "warn" || *level == "error") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("level", *level, []any{"debug", "info", "warn", "error"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var source *string
	{
		if logsListToolExecutionLogsSource != "" {
			source = &logsListToolExecutionLogsSource
			if !(*source == "stdout" || *source == "stderr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("source", *source, []any{"stdout", "stderr"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListToolExecutionLogsCursor != "" {
			cursor = &logsListToolExecutionLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var perPage int
	{
		if logsListToolExecutionLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListToolExecutionLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListToolExecutionLogsDirection != "" {
			direction = logsListToolExecutionLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListToolExecutionLogsSort != "" {
			sort = logsListToolExecutionLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListToolExecutionLogsApikeyToken != "" {
			apikeyToken = &logsListToolExecutionLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListToolExecutionLogsSessionToken != "" {
			sessionToken = &logsListToolExecutionLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListToolExecutionLogsProjectSlugInput != "" {
			projectSlugInput = &logsListToolExecutionLogsProjectSlugInput
		}
	}
	v := &logs.ListToolExecutionLogsPayload{}
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.DeploymentID = deploymentID
	v.FunctionID = functionID
	v.Instance = instance
	v.Level = level
	v.Source = source
	v.Cursor = cursor
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
