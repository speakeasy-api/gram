// Code generated by goa v3.23.4, DO NOT EDIT.
//
// logs HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	logs "github.com/speakeasy-api/gram/server/gen/logs"
	goa "goa.design/goa/v3/pkg"
)

// BuildListLogsPayload builds the payload for the logs listLogs endpoint from
// CLI flags.
func BuildListLogsPayload(logsListLogsToolID string, logsListLogsTsStart string, logsListLogsTsEnd string, logsListLogsCursor string, logsListLogsStatus string, logsListLogsServerName string, logsListLogsToolName string, logsListLogsToolType string, logsListLogsToolUrns string, logsListLogsPerPage string, logsListLogsDirection string, logsListLogsSort string, logsListLogsApikeyToken string, logsListLogsSessionToken string, logsListLogsProjectSlugInput string) (*logs.ListLogsPayload, error) {
	var err error
	var toolID *string
	{
		if logsListLogsToolID != "" {
			toolID = &logsListLogsToolID
			err = goa.MergeErrors(err, goa.ValidateFormat("tool_id", *toolID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsStart *string
	{
		if logsListLogsTsStart != "" {
			tsStart = &logsListLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListLogsTsEnd != "" {
			tsEnd = &logsListLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListLogsCursor != "" {
			cursor = &logsListLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var status *string
	{
		if logsListLogsStatus != "" {
			status = &logsListLogsStatus
			if !(*status == "success" || *status == "failure") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"success", "failure"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var serverName *string
	{
		if logsListLogsServerName != "" {
			serverName = &logsListLogsServerName
		}
	}
	var toolName *string
	{
		if logsListLogsToolName != "" {
			toolName = &logsListLogsToolName
		}
	}
	var toolType *string
	{
		if logsListLogsToolType != "" {
			toolType = &logsListLogsToolType
			if !(*toolType == "http" || *toolType == "function" || *toolType == "prompt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tool_type", *toolType, []any{"http", "function", "prompt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var toolUrns []string
	{
		if logsListLogsToolUrns != "" {
			err = json.Unmarshal([]byte(logsListLogsToolUrns), &toolUrns)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for toolUrns, \nerror: %s, \nexample of valid JSON:\n%s", err, "'[\n      \"Dolorem neque.\",\n      \"Expedita voluptatem quaerat cupiditate numquam illum.\",\n      \"Molestiae nihil aperiam fugiat inventore.\",\n      \"Aut aut facilis fugit excepturi id doloremque.\"\n   ]'")
			}
		}
	}
	var perPage int
	{
		if logsListLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListLogsDirection != "" {
			direction = logsListLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListLogsSort != "" {
			sort = logsListLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListLogsApikeyToken != "" {
			apikeyToken = &logsListLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListLogsSessionToken != "" {
			sessionToken = &logsListLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListLogsProjectSlugInput != "" {
			projectSlugInput = &logsListLogsProjectSlugInput
		}
	}
	v := &logs.ListLogsPayload{}
	v.ToolID = toolID
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.Cursor = cursor
	v.Status = status
	v.ServerName = serverName
	v.ToolName = toolName
	v.ToolType = toolType
	v.ToolUrns = toolUrns
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListToolExecutionLogsPayload builds the payload for the logs
// listToolExecutionLogs endpoint from CLI flags.
func BuildListToolExecutionLogsPayload(logsListToolExecutionLogsTsStart string, logsListToolExecutionLogsTsEnd string, logsListToolExecutionLogsDeploymentID string, logsListToolExecutionLogsFunctionID string, logsListToolExecutionLogsInstance string, logsListToolExecutionLogsLevel string, logsListToolExecutionLogsSource string, logsListToolExecutionLogsCursor string, logsListToolExecutionLogsPerPage string, logsListToolExecutionLogsDirection string, logsListToolExecutionLogsSort string, logsListToolExecutionLogsApikeyToken string, logsListToolExecutionLogsSessionToken string, logsListToolExecutionLogsProjectSlugInput string) (*logs.ListToolExecutionLogsPayload, error) {
	var err error
	var tsStart *string
	{
		if logsListToolExecutionLogsTsStart != "" {
			tsStart = &logsListToolExecutionLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListToolExecutionLogsTsEnd != "" {
			tsEnd = &logsListToolExecutionLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var deploymentID *string
	{
		if logsListToolExecutionLogsDeploymentID != "" {
			deploymentID = &logsListToolExecutionLogsDeploymentID
			err = goa.MergeErrors(err, goa.ValidateFormat("deployment_id", *deploymentID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var functionID *string
	{
		if logsListToolExecutionLogsFunctionID != "" {
			functionID = &logsListToolExecutionLogsFunctionID
			err = goa.MergeErrors(err, goa.ValidateFormat("function_id", *functionID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var instance *string
	{
		if logsListToolExecutionLogsInstance != "" {
			instance = &logsListToolExecutionLogsInstance
		}
	}
	var level *string
	{
		if logsListToolExecutionLogsLevel != "" {
			level = &logsListToolExecutionLogsLevel
			if !(*level == "debug" || *level == "info" || *level == "warn" || *level == "error") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("level", *level, []any{"debug", "info", "warn", "error"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var source *string
	{
		if logsListToolExecutionLogsSource != "" {
			source = &logsListToolExecutionLogsSource
			if !(*source == "stdout" || *source == "stderr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("source", *source, []any{"stdout", "stderr"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListToolExecutionLogsCursor != "" {
			cursor = &logsListToolExecutionLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var perPage int
	{
		if logsListToolExecutionLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListToolExecutionLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListToolExecutionLogsDirection != "" {
			direction = logsListToolExecutionLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListToolExecutionLogsSort != "" {
			sort = logsListToolExecutionLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListToolExecutionLogsApikeyToken != "" {
			apikeyToken = &logsListToolExecutionLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListToolExecutionLogsSessionToken != "" {
			sessionToken = &logsListToolExecutionLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListToolExecutionLogsProjectSlugInput != "" {
			projectSlugInput = &logsListToolExecutionLogsProjectSlugInput
		}
	}
	v := &logs.ListToolExecutionLogsPayload{}
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.DeploymentID = deploymentID
	v.FunctionID = functionID
	v.Instance = instance
	v.Level = level
	v.Source = source
	v.Cursor = cursor
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListTelemetryLogsPayload builds the payload for the logs
// listTelemetryLogs endpoint from CLI flags.
func BuildListTelemetryLogsPayload(logsListTelemetryLogsTimeStart string, logsListTelemetryLogsTimeEnd string, logsListTelemetryLogsGramUrn string, logsListTelemetryLogsTraceID string, logsListTelemetryLogsDeploymentID string, logsListTelemetryLogsFunctionID string, logsListTelemetryLogsSeverityText string, logsListTelemetryLogsHTTPStatusCode string, logsListTelemetryLogsHTTPRoute string, logsListTelemetryLogsHTTPMethod string, logsListTelemetryLogsServiceName string, logsListTelemetryLogsCursor string, logsListTelemetryLogsLimit string, logsListTelemetryLogsSort string, logsListTelemetryLogsApikeyToken string, logsListTelemetryLogsSessionToken string, logsListTelemetryLogsProjectSlugInput string) (*logs.ListTelemetryLogsPayload, error) {
	var err error
	var timeStart *int64
	{
		if logsListTelemetryLogsTimeStart != "" {
			val, err := strconv.ParseInt(logsListTelemetryLogsTimeStart, 10, 64)
			timeStart = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for timeStart, must be INT64")
			}
		}
	}
	var timeEnd *int64
	{
		if logsListTelemetryLogsTimeEnd != "" {
			val, err := strconv.ParseInt(logsListTelemetryLogsTimeEnd, 10, 64)
			timeEnd = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for timeEnd, must be INT64")
			}
		}
	}
	var gramUrn *string
	{
		if logsListTelemetryLogsGramUrn != "" {
			gramUrn = &logsListTelemetryLogsGramUrn
		}
	}
	var traceID *string
	{
		if logsListTelemetryLogsTraceID != "" {
			traceID = &logsListTelemetryLogsTraceID
			err = goa.MergeErrors(err, goa.ValidatePattern("trace_id", *traceID, "^[a-f0-9]{32}$"))
			if err != nil {
				return nil, err
			}
		}
	}
	var deploymentID *string
	{
		if logsListTelemetryLogsDeploymentID != "" {
			deploymentID = &logsListTelemetryLogsDeploymentID
			err = goa.MergeErrors(err, goa.ValidateFormat("deployment_id", *deploymentID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var functionID *string
	{
		if logsListTelemetryLogsFunctionID != "" {
			functionID = &logsListTelemetryLogsFunctionID
			err = goa.MergeErrors(err, goa.ValidateFormat("function_id", *functionID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var severityText *string
	{
		if logsListTelemetryLogsSeverityText != "" {
			severityText = &logsListTelemetryLogsSeverityText
			if !(*severityText == "DEBUG" || *severityText == "INFO" || *severityText == "WARN" || *severityText == "ERROR" || *severityText == "FATAL") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("severity_text", *severityText, []any{"DEBUG", "INFO", "WARN", "ERROR", "FATAL"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var httpStatusCode *int32
	{
		if logsListTelemetryLogsHTTPStatusCode != "" {
			var v int64
			v, err = strconv.ParseInt(logsListTelemetryLogsHTTPStatusCode, 10, 32)
			val := int32(v)
			httpStatusCode = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for httpStatusCode, must be INT32")
			}
		}
	}
	var httpRoute *string
	{
		if logsListTelemetryLogsHTTPRoute != "" {
			httpRoute = &logsListTelemetryLogsHTTPRoute
		}
	}
	var httpMethod *string
	{
		if logsListTelemetryLogsHTTPMethod != "" {
			httpMethod = &logsListTelemetryLogsHTTPMethod
			if !(*httpMethod == "GET" || *httpMethod == "POST" || *httpMethod == "PUT" || *httpMethod == "PATCH" || *httpMethod == "DELETE" || *httpMethod == "HEAD" || *httpMethod == "OPTIONS") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("http_method", *httpMethod, []any{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var serviceName *string
	{
		if logsListTelemetryLogsServiceName != "" {
			serviceName = &logsListTelemetryLogsServiceName
		}
	}
	var cursor *string
	{
		if logsListTelemetryLogsCursor != "" {
			cursor = &logsListTelemetryLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var limit int
	{
		if logsListTelemetryLogsLimit != "" {
			var v int64
			v, err = strconv.ParseInt(logsListTelemetryLogsLimit, 10, strconv.IntSize)
			limit = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
			if limit < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
			}
			if limit > 1000 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1000, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListTelemetryLogsSort != "" {
			sort = logsListTelemetryLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListTelemetryLogsApikeyToken != "" {
			apikeyToken = &logsListTelemetryLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListTelemetryLogsSessionToken != "" {
			sessionToken = &logsListTelemetryLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListTelemetryLogsProjectSlugInput != "" {
			projectSlugInput = &logsListTelemetryLogsProjectSlugInput
		}
	}
	v := &logs.ListTelemetryLogsPayload{}
	v.TimeStart = timeStart
	v.TimeEnd = timeEnd
	v.GramUrn = gramUrn
	v.TraceID = traceID
	v.DeploymentID = deploymentID
	v.FunctionID = functionID
	v.SeverityText = severityText
	v.HTTPStatusCode = httpStatusCode
	v.HTTPRoute = httpRoute
	v.HTTPMethod = httpMethod
	v.ServiceName = serviceName
	v.Cursor = cursor
	v.Limit = limit
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListTracesPayload builds the payload for the logs listTraces endpoint
// from CLI flags.
func BuildListTracesPayload(logsListTracesTimeStart string, logsListTracesTimeEnd string, logsListTracesDeploymentID string, logsListTracesFunctionID string, logsListTracesCursor string, logsListTracesLimit string, logsListTracesSort string, logsListTracesApikeyToken string, logsListTracesSessionToken string, logsListTracesProjectSlugInput string) (*logs.ListTracesPayload, error) {
	var err error
	var timeStart *int64
	{
		if logsListTracesTimeStart != "" {
			val, err := strconv.ParseInt(logsListTracesTimeStart, 10, 64)
			timeStart = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for timeStart, must be INT64")
			}
		}
	}
	var timeEnd *int64
	{
		if logsListTracesTimeEnd != "" {
			val, err := strconv.ParseInt(logsListTracesTimeEnd, 10, 64)
			timeEnd = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for timeEnd, must be INT64")
			}
		}
	}
	var deploymentID *string
	{
		if logsListTracesDeploymentID != "" {
			deploymentID = &logsListTracesDeploymentID
			err = goa.MergeErrors(err, goa.ValidateFormat("deployment_id", *deploymentID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var functionID *string
	{
		if logsListTracesFunctionID != "" {
			functionID = &logsListTracesFunctionID
			err = goa.MergeErrors(err, goa.ValidateFormat("function_id", *functionID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListTracesCursor != "" {
			cursor = &logsListTracesCursor
			err = goa.MergeErrors(err, goa.ValidatePattern("cursor", *cursor, "^[a-f0-9]{32}$"))
			if err != nil {
				return nil, err
			}
		}
	}
	var limit int
	{
		if logsListTracesLimit != "" {
			var v int64
			v, err = strconv.ParseInt(logsListTracesLimit, 10, strconv.IntSize)
			limit = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for limit, must be INT")
			}
			if limit < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1, true))
			}
			if limit > 1000 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("limit", limit, 1000, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListTracesSort != "" {
			sort = logsListTracesSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListTracesApikeyToken != "" {
			apikeyToken = &logsListTracesApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListTracesSessionToken != "" {
			sessionToken = &logsListTracesSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListTracesProjectSlugInput != "" {
			projectSlugInput = &logsListTracesProjectSlugInput
		}
	}
	v := &logs.ListTracesPayload{}
	v.TimeStart = timeStart
	v.TimeEnd = timeEnd
	v.DeploymentID = deploymentID
	v.FunctionID = functionID
	v.Cursor = cursor
	v.Limit = limit
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListLogsForTracePayload builds the payload for the logs
// listLogsForTrace endpoint from CLI flags.
func BuildListLogsForTracePayload(logsListLogsForTraceTraceID string, logsListLogsForTraceApikeyToken string, logsListLogsForTraceSessionToken string, logsListLogsForTraceProjectSlugInput string) (*logs.ListLogsForTracePayload, error) {
	var err error
	var traceID string
	{
		traceID = logsListLogsForTraceTraceID
		err = goa.MergeErrors(err, goa.ValidatePattern("trace_id", traceID, "^[a-f0-9]{32}$"))
		if err != nil {
			return nil, err
		}
	}
	var apikeyToken *string
	{
		if logsListLogsForTraceApikeyToken != "" {
			apikeyToken = &logsListLogsForTraceApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListLogsForTraceSessionToken != "" {
			sessionToken = &logsListLogsForTraceSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListLogsForTraceProjectSlugInput != "" {
			projectSlugInput = &logsListLogsForTraceProjectSlugInput
		}
	}
	v := &logs.ListLogsForTracePayload{}
	v.TraceID = traceID
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
