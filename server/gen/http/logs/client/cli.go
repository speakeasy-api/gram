// Code generated by goa v3.23.1, DO NOT EDIT.
//
// logs HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	logs "github.com/speakeasy-api/gram/server/gen/logs"
	goa "goa.design/goa/v3/pkg"
)

// BuildListLogsPayload builds the payload for the logs listLogs endpoint from
// CLI flags.
func BuildListLogsPayload(logsListLogsToolID string, logsListLogsTsStart string, logsListLogsTsEnd string, logsListLogsCursor string, logsListLogsStatus string, logsListLogsServerName string, logsListLogsToolName string, logsListLogsToolType string, logsListLogsToolUrns string, logsListLogsPerPage string, logsListLogsDirection string, logsListLogsSort string, logsListLogsApikeyToken string, logsListLogsSessionToken string, logsListLogsProjectSlugInput string) (*logs.ListLogsPayload, error) {
	var err error
	var toolID *string
	{
		if logsListLogsToolID != "" {
			toolID = &logsListLogsToolID
			err = goa.MergeErrors(err, goa.ValidateFormat("tool_id", *toolID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsStart *string
	{
		if logsListLogsTsStart != "" {
			tsStart = &logsListLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListLogsTsEnd != "" {
			tsEnd = &logsListLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListLogsCursor != "" {
			cursor = &logsListLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var status *string
	{
		if logsListLogsStatus != "" {
			status = &logsListLogsStatus
			if !(*status == "success" || *status == "failure") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"success", "failure"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var serverName *string
	{
		if logsListLogsServerName != "" {
			serverName = &logsListLogsServerName
		}
	}
	var toolName *string
	{
		if logsListLogsToolName != "" {
			toolName = &logsListLogsToolName
		}
	}
	var toolType *string
	{
		if logsListLogsToolType != "" {
			toolType = &logsListLogsToolType
			if !(*toolType == "http" || *toolType == "function" || *toolType == "prompt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tool_type", *toolType, []any{"http", "function", "prompt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var toolUrns []string
	{
		if logsListLogsToolUrns != "" {
			err = json.Unmarshal([]byte(logsListLogsToolUrns), &toolUrns)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for toolUrns, \nerror: %s, \nexample of valid JSON:\n%s", err, "'[\n      \"Tempora ea.\",\n      \"Tempore et qui.\"\n   ]'")
			}
		}
	}
	var perPage int
	{
		if logsListLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListLogsDirection != "" {
			direction = logsListLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListLogsSort != "" {
			sort = logsListLogsSort
			if !(sort == "ASC" || sort == "DESC") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"ASC", "DESC"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListLogsApikeyToken != "" {
			apikeyToken = &logsListLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListLogsSessionToken != "" {
			sessionToken = &logsListLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListLogsProjectSlugInput != "" {
			projectSlugInput = &logsListLogsProjectSlugInput
		}
	}
	v := &logs.ListLogsPayload{}
	v.ToolID = toolID
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.Cursor = cursor
	v.Status = status
	v.ServerName = serverName
	v.ToolName = toolName
	v.ToolType = toolType
	v.ToolUrns = toolUrns
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
