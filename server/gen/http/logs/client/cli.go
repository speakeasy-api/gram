// Code generated by goa v3.23.4, DO NOT EDIT.
//
// logs HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	logs "github.com/speakeasy-api/gram/server/gen/logs"
	goa "goa.design/goa/v3/pkg"
)

// BuildListLogsPayload builds the payload for the logs listLogs endpoint from
// CLI flags.
func BuildListLogsPayload(logsListLogsToolID string, logsListLogsTsStart string, logsListLogsTsEnd string, logsListLogsCursor string, logsListLogsStatus string, logsListLogsServerName string, logsListLogsToolName string, logsListLogsToolType string, logsListLogsToolUrns string, logsListLogsPerPage string, logsListLogsDirection string, logsListLogsSort string, logsListLogsApikeyToken string, logsListLogsSessionToken string, logsListLogsProjectSlugInput string) (*logs.ListLogsPayload, error) {
	var err error
	var toolID *string
	{
		if logsListLogsToolID != "" {
			toolID = &logsListLogsToolID
			err = goa.MergeErrors(err, goa.ValidateFormat("tool_id", *toolID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsStart *string
	{
		if logsListLogsTsStart != "" {
			tsStart = &logsListLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListLogsTsEnd != "" {
			tsEnd = &logsListLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListLogsCursor != "" {
			cursor = &logsListLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var status *string
	{
		if logsListLogsStatus != "" {
			status = &logsListLogsStatus
			if !(*status == "success" || *status == "failure") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", *status, []any{"success", "failure"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var serverName *string
	{
		if logsListLogsServerName != "" {
			serverName = &logsListLogsServerName
		}
	}
	var toolName *string
	{
		if logsListLogsToolName != "" {
			toolName = &logsListLogsToolName
		}
	}
	var toolType *string
	{
		if logsListLogsToolType != "" {
			toolType = &logsListLogsToolType
			if !(*toolType == "http" || *toolType == "function" || *toolType == "prompt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tool_type", *toolType, []any{"http", "function", "prompt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var toolUrns []string
	{
		if logsListLogsToolUrns != "" {
			err = json.Unmarshal([]byte(logsListLogsToolUrns), &toolUrns)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for toolUrns, \nerror: %s, \nexample of valid JSON:\n%s", err, "'[\n      \"Consequatur dolor eos aut et.\",\n      \"Rerum repellat amet ipsam consequatur fuga magnam.\",\n      \"Et qui libero nihil et magnam dolor.\",\n      \"Possimus cum vero natus et eum.\"\n   ]'")
			}
		}
	}
	var perPage int
	{
		if logsListLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListLogsDirection != "" {
			direction = logsListLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListLogsSort != "" {
			sort = logsListLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListLogsApikeyToken != "" {
			apikeyToken = &logsListLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListLogsSessionToken != "" {
			sessionToken = &logsListLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListLogsProjectSlugInput != "" {
			projectSlugInput = &logsListLogsProjectSlugInput
		}
	}
	v := &logs.ListLogsPayload{}
	v.ToolID = toolID
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.Cursor = cursor
	v.Status = status
	v.ServerName = serverName
	v.ToolName = toolName
	v.ToolType = toolType
	v.ToolUrns = toolUrns
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildListToolExecutionLogsPayload builds the payload for the logs
// listToolExecutionLogs endpoint from CLI flags.
func BuildListToolExecutionLogsPayload(logsListToolExecutionLogsTsStart string, logsListToolExecutionLogsTsEnd string, logsListToolExecutionLogsDeploymentID string, logsListToolExecutionLogsFunctionID string, logsListToolExecutionLogsInstance string, logsListToolExecutionLogsLevel string, logsListToolExecutionLogsSource string, logsListToolExecutionLogsCursor string, logsListToolExecutionLogsPerPage string, logsListToolExecutionLogsDirection string, logsListToolExecutionLogsSort string, logsListToolExecutionLogsApikeyToken string, logsListToolExecutionLogsSessionToken string, logsListToolExecutionLogsProjectSlugInput string) (*logs.ListToolExecutionLogsPayload, error) {
	var err error
	var tsStart *string
	{
		if logsListToolExecutionLogsTsStart != "" {
			tsStart = &logsListToolExecutionLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListToolExecutionLogsTsEnd != "" {
			tsEnd = &logsListToolExecutionLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var deploymentID *string
	{
		if logsListToolExecutionLogsDeploymentID != "" {
			deploymentID = &logsListToolExecutionLogsDeploymentID
			err = goa.MergeErrors(err, goa.ValidateFormat("deployment_id", *deploymentID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var functionID *string
	{
		if logsListToolExecutionLogsFunctionID != "" {
			functionID = &logsListToolExecutionLogsFunctionID
			err = goa.MergeErrors(err, goa.ValidateFormat("function_id", *functionID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var instance *string
	{
		if logsListToolExecutionLogsInstance != "" {
			instance = &logsListToolExecutionLogsInstance
		}
	}
	var level *string
	{
		if logsListToolExecutionLogsLevel != "" {
			level = &logsListToolExecutionLogsLevel
			if !(*level == "debug" || *level == "info" || *level == "warn" || *level == "error") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("level", *level, []any{"debug", "info", "warn", "error"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var source *string
	{
		if logsListToolExecutionLogsSource != "" {
			source = &logsListToolExecutionLogsSource
			if !(*source == "stdout" || *source == "stderr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("source", *source, []any{"stdout", "stderr"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListToolExecutionLogsCursor != "" {
			cursor = &logsListToolExecutionLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var perPage int
	{
		if logsListToolExecutionLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListToolExecutionLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListToolExecutionLogsDirection != "" {
			direction = logsListToolExecutionLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListToolExecutionLogsSort != "" {
			sort = logsListToolExecutionLogsSort
			if !(sort == "asc" || sort == "desc") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"asc", "desc"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListToolExecutionLogsApikeyToken != "" {
			apikeyToken = &logsListToolExecutionLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListToolExecutionLogsSessionToken != "" {
			sessionToken = &logsListToolExecutionLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListToolExecutionLogsProjectSlugInput != "" {
			projectSlugInput = &logsListToolExecutionLogsProjectSlugInput
		}
	}
	v := &logs.ListToolExecutionLogsPayload{}
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.DeploymentID = deploymentID
	v.FunctionID = functionID
	v.Instance = instance
	v.Level = level
	v.Source = source
	v.Cursor = cursor
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildSearchLogsPayload builds the payload for the logs searchLogs endpoint
// from CLI flags.
func BuildSearchLogsPayload(logsSearchLogsBody string, logsSearchLogsApikeyToken string, logsSearchLogsSessionToken string, logsSearchLogsProjectSlugInput string) (*logs.SearchLogsPayload, error) {
	var err error
	var body SearchLogsRequestBody
	{
		err = json.Unmarshal([]byte(logsSearchLogsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"cursor\": \"Voluptatum optio aut dolore ex.\",\n      \"filter\": {\n         \"deployment_id\": \"d901177b-a7b7-47ba-85e2-dad02598e3e4\",\n         \"from\": \"2025-12-19T10:00:00Z\",\n         \"function_id\": \"77f98452-a06d-4003-837c-31e378a2b84c\",\n         \"gram_urn\": \"Molestiae molestiae consectetur fugit aspernatur pariatur esse.\",\n         \"http_method\": \"HEAD\",\n         \"http_route\": \"Aspernatur laborum sed blanditiis amet.\",\n         \"http_status_code\": 1919514860,\n         \"service_name\": \"Maxime aliquid sit exercitationem consequatur.\",\n         \"severity_text\": \"FATAL\",\n         \"to\": \"2025-12-19T11:00:00Z\",\n         \"trace_id\": \"dd9404d5463eac6b6347f70a8c638a3f\"\n      },\n      \"limit\": 524,\n      \"sort\": \"asc\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if logsSearchLogsApikeyToken != "" {
			apikeyToken = &logsSearchLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsSearchLogsSessionToken != "" {
			sessionToken = &logsSearchLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsSearchLogsProjectSlugInput != "" {
			projectSlugInput = &logsSearchLogsProjectSlugInput
		}
	}
	v := &logs.SearchLogsPayload{
		Cursor: body.Cursor,
		Sort:   body.Sort,
		Limit:  body.Limit,
	}
	if body.Filter != nil {
		v.Filter = marshalSearchLogsFilterRequestBodyToLogsSearchLogsFilter(body.Filter)
	}
	{
		var zero string
		if v.Sort == zero {
			v.Sort = "desc"
		}
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}

// BuildSearchToolCallsPayload builds the payload for the logs searchToolCalls
// endpoint from CLI flags.
func BuildSearchToolCallsPayload(logsSearchToolCallsBody string, logsSearchToolCallsApikeyToken string, logsSearchToolCallsSessionToken string, logsSearchToolCallsProjectSlugInput string) (*logs.SearchToolCallsPayload, error) {
	var err error
	var body SearchToolCallsRequestBody
	{
		err = json.Unmarshal([]byte(logsSearchToolCallsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"cursor\": \"Nesciunt et fuga nemo quasi voluptas.\",\n      \"filter\": {\n         \"deployment_id\": \"24fe6b1c-dbc3-4dda-9113-7232b32d2215\",\n         \"from\": \"2025-12-19T10:00:00Z\",\n         \"function_id\": \"179726d1-3968-46e5-bb76-7759bdb52aec\",\n         \"gram_urn\": \"A rerum quam.\",\n         \"to\": \"2025-12-19T11:00:00Z\"\n      },\n      \"limit\": 210,\n      \"sort\": \"asc\"\n   }'")
		}
	}
	var apikeyToken *string
	{
		if logsSearchToolCallsApikeyToken != "" {
			apikeyToken = &logsSearchToolCallsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsSearchToolCallsSessionToken != "" {
			sessionToken = &logsSearchToolCallsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsSearchToolCallsProjectSlugInput != "" {
			projectSlugInput = &logsSearchToolCallsProjectSlugInput
		}
	}
	v := &logs.SearchToolCallsPayload{
		Cursor: body.Cursor,
		Sort:   body.Sort,
		Limit:  body.Limit,
	}
	if body.Filter != nil {
		v.Filter = marshalSearchToolCallsFilterRequestBodyToLogsSearchToolCallsFilter(body.Filter)
	}
	{
		var zero string
		if v.Sort == zero {
			v.Sort = "desc"
		}
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
