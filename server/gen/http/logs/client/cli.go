// Code generated by goa v3.22.6, DO NOT EDIT.
//
// logs HTTP client CLI support package
//
// Command:
// $ goa gen github.com/speakeasy-api/gram/server/design

package client

import (
	"fmt"
	"strconv"

	logs "github.com/speakeasy-api/gram/server/gen/logs"
	goa "goa.design/goa/v3/pkg"
)

// BuildListLogsPayload builds the payload for the logs listLogs endpoint from
// CLI flags.
func BuildListLogsPayload(logsListLogsToolID string, logsListLogsTsStart string, logsListLogsTsEnd string, logsListLogsCursor string, logsListLogsStatus string, logsListLogsServerName string, logsListLogsToolName string, logsListLogsToolType string, logsListLogsPerPage string, logsListLogsDirection string, logsListLogsSort string, logsListLogsApikeyToken string, logsListLogsSessionToken string, logsListLogsProjectSlugInput string) (*logs.ListLogsPayload, error) {
	var err error
	var toolID *string
	{
		if logsListLogsToolID != "" {
			toolID = &logsListLogsToolID
			err = goa.MergeErrors(err, goa.ValidateFormat("tool_id", *toolID, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsStart *string
	{
		if logsListLogsTsStart != "" {
			tsStart = &logsListLogsTsStart
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_start", *tsStart, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var tsEnd *string
	{
		if logsListLogsTsEnd != "" {
			tsEnd = &logsListLogsTsEnd
			err = goa.MergeErrors(err, goa.ValidateFormat("ts_end", *tsEnd, goa.FormatDateTime))
			if err != nil {
				return nil, err
			}
		}
	}
	var cursor *string
	{
		if logsListLogsCursor != "" {
			cursor = &logsListLogsCursor
			err = goa.MergeErrors(err, goa.ValidateFormat("cursor", *cursor, goa.FormatUUID))
			if err != nil {
				return nil, err
			}
		}
	}
	var status string
	{
		if logsListLogsStatus != "" {
			status = logsListLogsStatus
			if !(status == "success" || status == "failure") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("status", status, []any{"success", "failure"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var serverName *string
	{
		if logsListLogsServerName != "" {
			serverName = &logsListLogsServerName
		}
	}
	var toolName *string
	{
		if logsListLogsToolName != "" {
			toolName = &logsListLogsToolName
		}
	}
	var toolType string
	{
		if logsListLogsToolType != "" {
			toolType = logsListLogsToolType
			if !(toolType == "http" || toolType == "function" || toolType == "prompt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tool_type", toolType, []any{"http", "function", "prompt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var perPage int
	{
		if logsListLogsPerPage != "" {
			var v int64
			v, err = strconv.ParseInt(logsListLogsPerPage, 10, strconv.IntSize)
			perPage = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for perPage, must be INT")
			}
			if perPage < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 1, true))
			}
			if perPage > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("per_page", perPage, 100, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var direction string
	{
		if logsListLogsDirection != "" {
			direction = logsListLogsDirection
			if !(direction == "next" || direction == "prev") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("direction", direction, []any{"next", "prev"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var sort string
	{
		if logsListLogsSort != "" {
			sort = logsListLogsSort
			if !(sort == "ASC" || sort == "DESC") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"ASC", "DESC"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var apikeyToken *string
	{
		if logsListLogsApikeyToken != "" {
			apikeyToken = &logsListLogsApikeyToken
		}
	}
	var sessionToken *string
	{
		if logsListLogsSessionToken != "" {
			sessionToken = &logsListLogsSessionToken
		}
	}
	var projectSlugInput *string
	{
		if logsListLogsProjectSlugInput != "" {
			projectSlugInput = &logsListLogsProjectSlugInput
		}
	}
	v := &logs.ListLogsPayload{}
	v.ToolID = toolID
	v.TsStart = tsStart
	v.TsEnd = tsEnd
	v.Cursor = cursor
	v.Status = status
	v.ServerName = serverName
	v.ToolName = toolName
	v.ToolType = toolType
	v.PerPage = perPage
	v.Direction = direction
	v.Sort = sort
	v.ApikeyToken = apikeyToken
	v.SessionToken = sessionToken
	v.ProjectSlugInput = projectSlugInput

	return v, nil
}
