// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/tools/repo/models"
)

const findToolEntriesByName = `-- name: FindToolEntriesByName :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
),
external_deployments AS (
  SELECT package_versions.deployment_id as id
  FROM deployments_packages
  INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
  WHERE deployments_packages.deployment_id = (SELECT id FROM deployment)
)
SELECT 
  htd.id, htd.deployment_id, htd.name, htd.security, htd.server_env_var
FROM http_tool_definitions htd
WHERE
  htd.deployment_id = ANY (SELECT id FROM deployment UNION ALL SELECT id FROM external_deployments)
  AND htd.deleted IS FALSE
  AND htd.name = ANY ($1::text[])
ORDER BY htd.id DESC
`

type FindToolEntriesByNameParams struct {
	Names     []string
	ProjectID uuid.UUID
}

type FindToolEntriesByNameRow struct {
	ID           uuid.UUID
	DeploymentID uuid.UUID
	Name         string
	Security     []byte
	ServerEnvVar string
}

func (q *Queries) FindToolEntriesByName(ctx context.Context, arg FindToolEntriesByNameParams) ([]FindToolEntriesByNameRow, error) {
	rows, err := q.db.Query(ctx, findToolEntriesByName, arg.Names, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindToolEntriesByNameRow
	for rows.Next() {
		var i FindToolEntriesByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.Name,
			&i.Security,
			&i.ServerEnvVar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findToolsByName = `-- name: FindToolsByName :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $1
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
),
external_deployments AS (
  SELECT package_versions.deployment_id as id
  FROM deployments_packages
  INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
  WHERE deployments_packages.deployment_id = (SELECT id FROM deployment)
)
SELECT 
  http_tool_definitions.id, http_tool_definitions.project_id, http_tool_definitions.deployment_id, http_tool_definitions.openapiv3_document_id, http_tool_definitions.confirm, http_tool_definitions.confirm_prompt, http_tool_definitions.summarizer, http_tool_definitions.name, http_tool_definitions.untruncated_name, http_tool_definitions.summary, http_tool_definitions.description, http_tool_definitions.openapiv3_operation, http_tool_definitions.tags, http_tool_definitions.x_gram, http_tool_definitions.original_name, http_tool_definitions.original_summary, http_tool_definitions.original_description, http_tool_definitions.server_env_var, http_tool_definitions.default_server_url, http_tool_definitions.security, http_tool_definitions.http_method, http_tool_definitions.path, http_tool_definitions.schema_version, http_tool_definitions.schema, http_tool_definitions.header_settings, http_tool_definitions.query_settings, http_tool_definitions.path_settings, http_tool_definitions.request_content_type, http_tool_definitions.response_filter, http_tool_definitions.created_at, http_tool_definitions.updated_at, http_tool_definitions.deleted_at, http_tool_definitions.deleted,
  (select id from deployment) as owning_deployment_id,
  (CASE
    WHEN http_tool_definitions.project_id = $1 THEN ''
    WHEN packages.id IS NOT NULL THEN packages.name
    ELSE ''
  END) as package_name
FROM http_tool_definitions
LEFT JOIN packages ON http_tool_definitions.project_id = packages.project_id
WHERE
  http_tool_definitions.deployment_id = ANY (SELECT id FROM deployment UNION ALL SELECT id FROM external_deployments)
  AND http_tool_definitions.deleted IS FALSE
  AND http_tool_definitions.name = ANY ($2::text[])
ORDER BY http_tool_definitions.id DESC
`

type FindToolsByNameParams struct {
	ProjectID uuid.UUID
	Names     []string
}

type FindToolsByNameRow struct {
	HttpToolDefinition HttpToolDefinition
	OwningDeploymentID uuid.UUID
	PackageName        string
}

func (q *Queries) FindToolsByName(ctx context.Context, arg FindToolsByNameParams) ([]FindToolsByNameRow, error) {
	rows, err := q.db.Query(ctx, findToolsByName, arg.ProjectID, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindToolsByNameRow
	for rows.Next() {
		var i FindToolsByNameRow
		if err := rows.Scan(
			&i.HttpToolDefinition.ID,
			&i.HttpToolDefinition.ProjectID,
			&i.HttpToolDefinition.DeploymentID,
			&i.HttpToolDefinition.Openapiv3DocumentID,
			&i.HttpToolDefinition.Confirm,
			&i.HttpToolDefinition.ConfirmPrompt,
			&i.HttpToolDefinition.Summarizer,
			&i.HttpToolDefinition.Name,
			&i.HttpToolDefinition.UntruncatedName,
			&i.HttpToolDefinition.Summary,
			&i.HttpToolDefinition.Description,
			&i.HttpToolDefinition.Openapiv3Operation,
			&i.HttpToolDefinition.Tags,
			&i.HttpToolDefinition.XGram,
			&i.HttpToolDefinition.OriginalName,
			&i.HttpToolDefinition.OriginalSummary,
			&i.HttpToolDefinition.OriginalDescription,
			&i.HttpToolDefinition.ServerEnvVar,
			&i.HttpToolDefinition.DefaultServerUrl,
			&i.HttpToolDefinition.Security,
			&i.HttpToolDefinition.HttpMethod,
			&i.HttpToolDefinition.Path,
			&i.HttpToolDefinition.SchemaVersion,
			&i.HttpToolDefinition.Schema,
			&i.HttpToolDefinition.HeaderSettings,
			&i.HttpToolDefinition.QuerySettings,
			&i.HttpToolDefinition.PathSettings,
			&i.HttpToolDefinition.RequestContentType,
			&i.HttpToolDefinition.ResponseFilter,
			&i.HttpToolDefinition.CreatedAt,
			&i.HttpToolDefinition.UpdatedAt,
			&i.HttpToolDefinition.DeletedAt,
			&i.HttpToolDefinition.Deleted,
			&i.OwningDeploymentID,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPToolDefinitionByID = `-- name: GetHTTPToolDefinitionByID :one
WITH first_party AS (
  SELECT id
  FROM http_tool_definitions
  WHERE http_tool_definitions.id = $1
    AND http_tool_definitions.project_id = $2
    AND http_tool_definitions.deleted IS FALSE
  LIMIT 1
),
third_party AS (
  SELECT htd.id
  FROM deployments d
  INNER JOIN deployments_packages dp ON d.id =  dp.deployment_id
  INNER JOIN package_versions pv ON dp.version_id = pv.id
  INNER JOIN http_tool_definitions htd ON htd.deployment_id = pv.deployment_id
  WHERE d.project_id = $2
    AND htd.id = $1
    AND NOT EXISTS(SELECT 1 FROM first_party)
  LIMIT 1
)
SELECT id, project_id, deployment_id, openapiv3_document_id, confirm, confirm_prompt, summarizer, name, untruncated_name, summary, description, openapiv3_operation, tags, x_gram, original_name, original_summary, original_description, server_env_var, default_server_url, security, http_method, path, schema_version, schema, header_settings, query_settings, path_settings, request_content_type, response_filter, created_at, updated_at, deleted_at, deleted
FROM http_tool_definitions
WHERE id = COALESCE((SELECT id FROM first_party), (SELECT id FROM  third_party))
`

type GetHTTPToolDefinitionByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

// This CTE is for integrating third party tools by checking for tool definitions from external deployments/packages.
func (q *Queries) GetHTTPToolDefinitionByID(ctx context.Context, arg GetHTTPToolDefinitionByIDParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, getHTTPToolDefinitionByID, arg.ID, arg.ProjectID)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Confirm,
		&i.ConfirmPrompt,
		&i.Summarizer,
		&i.Name,
		&i.UntruncatedName,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.XGram,
		&i.OriginalName,
		&i.OriginalSummary,
		&i.OriginalDescription,
		&i.ServerEnvVar,
		&i.DefaultServerUrl,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.HeaderSettings,
		&i.QuerySettings,
		&i.PathSettings,
		&i.RequestContentType,
		&i.ResponseFilter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listTools = `-- name: ListTools :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
      AND ($4::uuid IS NOT NULL OR ds.status = 'completed')
      AND (
        $4::uuid IS NULL
        OR d.id = $4::uuid
      )
    ORDER BY d.seq DESC
    LIMIT 1
),
all_deployment_ids AS (
    SELECT id FROM deployment
    UNION
    SELECT DISTINCT pv.deployment_id
    FROM deployment d
    JOIN deployments_packages dp ON dp.deployment_id = d.id
    JOIN package_versions pv ON dp.version_id = pv.id
)
SELECT 
  (SELECT id FROM deployment) as deployment_id,
  htd.id,
  htd.name,
  htd.summary,
  htd.description,
  htd.http_method,
  htd.confirm,
  htd.confirm_prompt,
  htd.summarizer,
  htd.response_filter,
  htd.path,
  htd.openapiv3_document_id,
  htd.openapiv3_operation,
  htd.schema_version,
  htd.schema,
  htd.security,
  htd.default_server_url,
  htd.created_at,
  htd.updated_at,
  htd.tags,
  (CASE
    WHEN htd.project_id = $2 THEN ''
    WHEN packages.id IS NOT NULL THEN packages.name
    ELSE ''
  END) as package_name
FROM http_tool_definitions htd
LEFT JOIN packages ON htd.project_id = packages.project_id
WHERE
  htd.deployment_id IN (SELECT id FROM all_deployment_ids)
  AND htd.deleted IS FALSE
  AND ($3::uuid IS NULL OR htd.id < $3)
ORDER BY htd.id DESC
LIMIT $1
`

type ListToolsParams struct {
	Limit        int32
	ProjectID    uuid.UUID
	Cursor       uuid.NullUUID
	DeploymentID uuid.NullUUID
}

type ListToolsRow struct {
	DeploymentID        uuid.UUID
	ID                  uuid.UUID
	Name                string
	Summary             string
	Description         string
	HttpMethod          string
	Confirm             pgtype.Text
	ConfirmPrompt       pgtype.Text
	Summarizer          pgtype.Text
	ResponseFilter      *models.ResponseFilter
	Path                string
	Openapiv3DocumentID uuid.NullUUID
	Openapiv3Operation  pgtype.Text
	SchemaVersion       string
	Schema              []byte
	Security            []byte
	DefaultServerUrl    pgtype.Text
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	Tags                []string
	PackageName         string
}

// Two use cases:
// 1. List all tools from the latest successful deployment (when deployment_id is NULL)
// 2. List all tools for a specific deployment by ID (when deployment_id is provided)
func (q *Queries) ListTools(ctx context.Context, arg ListToolsParams) ([]ListToolsRow, error) {
	rows, err := q.db.Query(ctx, listTools,
		arg.Limit,
		arg.ProjectID,
		arg.Cursor,
		arg.DeploymentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListToolsRow
	for rows.Next() {
		var i ListToolsRow
		if err := rows.Scan(
			&i.DeploymentID,
			&i.ID,
			&i.Name,
			&i.Summary,
			&i.Description,
			&i.HttpMethod,
			&i.Confirm,
			&i.ConfirmPrompt,
			&i.Summarizer,
			&i.ResponseFilter,
			&i.Path,
			&i.Openapiv3DocumentID,
			&i.Openapiv3Operation,
			&i.SchemaVersion,
			&i.Schema,
			&i.Security,
			&i.DefaultServerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pokeHTTPToolDefinitionByName = `-- name: PokeHTTPToolDefinitionByName :one
WITH first_party AS (
  SELECT id
  FROM http_tool_definitions
  WHERE http_tool_definitions.name = $1
    AND http_tool_definitions.project_id = $2
    AND http_tool_definitions.deleted IS FALSE
  LIMIT 1
),
third_party AS (
  SELECT htd.id
  FROM deployments d
  INNER JOIN deployments_packages dp ON d.id =  dp.deployment_id
  INNER JOIN package_versions pv ON dp.version_id = pv.id
  INNER JOIN http_tool_definitions htd ON htd.deployment_id = pv.deployment_id
  WHERE d.project_id = $2
    AND htd.name = $1
    AND NOT EXISTS(SELECT 1 FROM first_party)
  LIMIT 1
)
SELECT id
FROM http_tool_definitions
WHERE id = COALESCE((SELECT id FROM first_party), (SELECT id FROM  third_party))
`

type PokeHTTPToolDefinitionByNameParams struct {
	Name      string
	ProjectID uuid.UUID
}

// This CTE is for integrating third party tools by checking for tool definitions from external deployments/packages.
func (q *Queries) PokeHTTPToolDefinitionByName(ctx context.Context, arg PokeHTTPToolDefinitionByNameParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, pokeHTTPToolDefinitionByName, arg.Name, arg.ProjectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
