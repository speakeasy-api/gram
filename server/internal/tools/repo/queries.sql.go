// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/conv"
	"github.com/speakeasy-api/gram/server/internal/tools/repo/models"
	"github.com/speakeasy-api/gram/server/internal/urn"
)

const findFunctionToolEntriesByUrn = `-- name: FindFunctionToolEntriesByUrn :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
)
SELECT
  ftd.id, ftd.tool_urn, ftd.deployment_id, ftd.name, ftd.variables
FROM function_tool_definitions ftd
WHERE
  ftd.deployment_id = (SELECT id FROM deployment)
  AND ftd.deleted IS FALSE
  AND ftd.tool_urn = ANY ($1::text[])
ORDER BY ftd.id DESC
`

type FindFunctionToolEntriesByUrnParams struct {
	Urns      []string
	ProjectID uuid.UUID
}

type FindFunctionToolEntriesByUrnRow struct {
	ID           uuid.UUID
	ToolUrn      urn.Tool
	DeploymentID uuid.UUID
	Name         string
	Variables    []byte
}

func (q *Queries) FindFunctionToolEntriesByUrn(ctx context.Context, arg FindFunctionToolEntriesByUrnParams) ([]FindFunctionToolEntriesByUrnRow, error) {
	rows, err := q.db.Query(ctx, findFunctionToolEntriesByUrn, arg.Urns, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindFunctionToolEntriesByUrnRow
	for rows.Next() {
		var i FindFunctionToolEntriesByUrnRow
		if err := rows.Scan(
			&i.ID,
			&i.ToolUrn,
			&i.DeploymentID,
			&i.Name,
			&i.Variables,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFunctionToolsByUrn = `-- name: FindFunctionToolsByUrn :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
)
SELECT
  function_tool_definitions.id, function_tool_definitions.tool_urn, function_tool_definitions.project_id, function_tool_definitions.deployment_id, function_tool_definitions.function_id, function_tool_definitions.runtime, function_tool_definitions.name, function_tool_definitions.description, function_tool_definitions.input_schema, function_tool_definitions.variables, function_tool_definitions.created_at, function_tool_definitions.updated_at, function_tool_definitions.deleted_at, function_tool_definitions.deleted,
  (select id from deployment) as owning_deployment_id
FROM function_tool_definitions
WHERE
  function_tool_definitions.deployment_id = (SELECT id FROM deployment)
  AND function_tool_definitions.deleted IS FALSE
  AND function_tool_definitions.tool_urn = ANY ($1::text[])
ORDER BY function_tool_definitions.id DESC
`

type FindFunctionToolsByUrnParams struct {
	Urns      []string
	ProjectID uuid.UUID
}

type FindFunctionToolsByUrnRow struct {
	FunctionToolDefinition FunctionToolDefinition
	OwningDeploymentID     uuid.UUID
}

func (q *Queries) FindFunctionToolsByUrn(ctx context.Context, arg FindFunctionToolsByUrnParams) ([]FindFunctionToolsByUrnRow, error) {
	rows, err := q.db.Query(ctx, findFunctionToolsByUrn, arg.Urns, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindFunctionToolsByUrnRow
	for rows.Next() {
		var i FindFunctionToolsByUrnRow
		if err := rows.Scan(
			&i.FunctionToolDefinition.ID,
			&i.FunctionToolDefinition.ToolUrn,
			&i.FunctionToolDefinition.ProjectID,
			&i.FunctionToolDefinition.DeploymentID,
			&i.FunctionToolDefinition.FunctionID,
			&i.FunctionToolDefinition.Runtime,
			&i.FunctionToolDefinition.Name,
			&i.FunctionToolDefinition.Description,
			&i.FunctionToolDefinition.InputSchema,
			&i.FunctionToolDefinition.Variables,
			&i.FunctionToolDefinition.CreatedAt,
			&i.FunctionToolDefinition.UpdatedAt,
			&i.FunctionToolDefinition.DeletedAt,
			&i.FunctionToolDefinition.Deleted,
			&i.OwningDeploymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findHttpToolEntriesByUrn = `-- name: FindHttpToolEntriesByUrn :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
),
external_deployments AS (
  SELECT package_versions.deployment_id as id
  FROM deployments_packages
  INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
  WHERE deployments_packages.deployment_id = (SELECT id FROM deployment)
)
SELECT 
  htd.id, htd.tool_urn, htd.deployment_id, htd.name, htd.security, htd.server_env_var
FROM http_tool_definitions htd
WHERE
  htd.deployment_id = ANY (SELECT id FROM deployment UNION ALL SELECT id FROM external_deployments)
  AND htd.deleted IS FALSE
  AND htd.tool_urn = ANY ($1::text[])
ORDER BY htd.id DESC
`

type FindHttpToolEntriesByUrnParams struct {
	Urns      []string
	ProjectID uuid.UUID
}

type FindHttpToolEntriesByUrnRow struct {
	ID           uuid.UUID
	ToolUrn      urn.Tool
	DeploymentID uuid.UUID
	Name         string
	Security     []byte
	ServerEnvVar string
}

func (q *Queries) FindHttpToolEntriesByUrn(ctx context.Context, arg FindHttpToolEntriesByUrnParams) ([]FindHttpToolEntriesByUrnRow, error) {
	rows, err := q.db.Query(ctx, findHttpToolEntriesByUrn, arg.Urns, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindHttpToolEntriesByUrnRow
	for rows.Next() {
		var i FindHttpToolEntriesByUrnRow
		if err := rows.Scan(
			&i.ID,
			&i.ToolUrn,
			&i.DeploymentID,
			&i.Name,
			&i.Security,
			&i.ServerEnvVar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findHttpToolsByUrn = `-- name: FindHttpToolsByUrn :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $1
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
),
external_deployments AS (
  SELECT package_versions.deployment_id as id
  FROM deployments_packages
  INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
  WHERE deployments_packages.deployment_id = (SELECT id FROM deployment)
)
SELECT 
  http_tool_definitions.id, http_tool_definitions.tool_urn, http_tool_definitions.project_id, http_tool_definitions.deployment_id, http_tool_definitions.openapiv3_document_id, http_tool_definitions.confirm, http_tool_definitions.confirm_prompt, http_tool_definitions.summarizer, http_tool_definitions.name, http_tool_definitions.untruncated_name, http_tool_definitions.summary, http_tool_definitions.description, http_tool_definitions.openapiv3_operation, http_tool_definitions.tags, http_tool_definitions.x_gram, http_tool_definitions.original_name, http_tool_definitions.original_summary, http_tool_definitions.original_description, http_tool_definitions.server_env_var, http_tool_definitions.default_server_url, http_tool_definitions.security, http_tool_definitions.http_method, http_tool_definitions.path, http_tool_definitions.schema_version, http_tool_definitions.schema, http_tool_definitions.header_settings, http_tool_definitions.query_settings, http_tool_definitions.path_settings, http_tool_definitions.request_content_type, http_tool_definitions.response_filter, http_tool_definitions.created_at, http_tool_definitions.updated_at, http_tool_definitions.deleted_at, http_tool_definitions.deleted,
  (select id from deployment) as owning_deployment_id,
  (CASE
    WHEN http_tool_definitions.project_id = $1 THEN ''
    WHEN packages.id IS NOT NULL THEN packages.name
    ELSE ''
  END) as package_name
FROM http_tool_definitions
LEFT JOIN packages ON http_tool_definitions.project_id = packages.project_id
WHERE
  http_tool_definitions.deployment_id = ANY (SELECT id FROM deployment UNION ALL SELECT id FROM external_deployments)
  AND http_tool_definitions.deleted IS FALSE
  AND http_tool_definitions.tool_urn = ANY ($2::text[])
ORDER BY http_tool_definitions.id DESC
`

type FindHttpToolsByUrnParams struct {
	ProjectID uuid.UUID
	Urns      []string
}

type FindHttpToolsByUrnRow struct {
	HttpToolDefinition HttpToolDefinition
	OwningDeploymentID uuid.UUID
	PackageName        string
}

func (q *Queries) FindHttpToolsByUrn(ctx context.Context, arg FindHttpToolsByUrnParams) ([]FindHttpToolsByUrnRow, error) {
	rows, err := q.db.Query(ctx, findHttpToolsByUrn, arg.ProjectID, arg.Urns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindHttpToolsByUrnRow
	for rows.Next() {
		var i FindHttpToolsByUrnRow
		if err := rows.Scan(
			&i.HttpToolDefinition.ID,
			&i.HttpToolDefinition.ToolUrn,
			&i.HttpToolDefinition.ProjectID,
			&i.HttpToolDefinition.DeploymentID,
			&i.HttpToolDefinition.Openapiv3DocumentID,
			&i.HttpToolDefinition.Confirm,
			&i.HttpToolDefinition.ConfirmPrompt,
			&i.HttpToolDefinition.Summarizer,
			&i.HttpToolDefinition.Name,
			&i.HttpToolDefinition.UntruncatedName,
			&i.HttpToolDefinition.Summary,
			&i.HttpToolDefinition.Description,
			&i.HttpToolDefinition.Openapiv3Operation,
			&i.HttpToolDefinition.Tags,
			&i.HttpToolDefinition.XGram,
			&i.HttpToolDefinition.OriginalName,
			&i.HttpToolDefinition.OriginalSummary,
			&i.HttpToolDefinition.OriginalDescription,
			&i.HttpToolDefinition.ServerEnvVar,
			&i.HttpToolDefinition.DefaultServerUrl,
			&i.HttpToolDefinition.Security,
			&i.HttpToolDefinition.HttpMethod,
			&i.HttpToolDefinition.Path,
			&i.HttpToolDefinition.SchemaVersion,
			&i.HttpToolDefinition.Schema,
			&i.HttpToolDefinition.HeaderSettings,
			&i.HttpToolDefinition.QuerySettings,
			&i.HttpToolDefinition.PathSettings,
			&i.HttpToolDefinition.RequestContentType,
			&i.HttpToolDefinition.ResponseFilter,
			&i.HttpToolDefinition.CreatedAt,
			&i.HttpToolDefinition.UpdatedAt,
			&i.HttpToolDefinition.DeletedAt,
			&i.HttpToolDefinition.Deleted,
			&i.OwningDeploymentID,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionToolByURN = `-- name: GetFunctionToolByURN :one
WITH deployment AS (
  SELECT d.id
  FROM deployments d
  JOIN deployment_statuses ds ON d.id = ds.deployment_id
  WHERE d.project_id = $2
  AND ds.status = 'completed'
  ORDER BY d.seq DESC LIMIT 1
)
SELECT
    tool.id
  , tool.tool_urn
  , tool.project_id
  , tool.deployment_id
  , tool.function_id
  , tool.runtime
  , tool.name
  , tool.description
  , tool.input_schema
  , tool.variables
  , access.id AS access_id
  , access.encryption_key
  , access.bearer_format
  , apps.id as fly_app_internal_id
  , apps.app_name as fly_app_name
  , apps.app_url as fly_app_url
  , apps.runner_version as fly_runner_version
FROM deployment dep
INNER JOIN function_tool_definitions tool
  ON tool.deployment_id = dep.id
  AND tool.tool_urn = $1
  AND tool.project_id = $2
  AND tool.deleted IS FALSE
LEFT JOIN fly_apps apps
  ON apps.project_id = $2
  AND apps.deployment_id = tool.deployment_id
  AND apps.function_id = tool.function_id
  AND apps.status = 'ready'
LEFT JOIN functions_access access
  ON access.id = apps.access_id
  AND access.deleted IS FALSE
ORDER BY apps.seq DESC NULLS LAST
LIMIT 1
`

type GetFunctionToolByURNParams struct {
	Urn       urn.Tool
	ProjectID uuid.UUID
}

type GetFunctionToolByURNRow struct {
	ID               uuid.UUID
	ToolUrn          urn.Tool
	ProjectID        uuid.UUID
	DeploymentID     uuid.UUID
	FunctionID       uuid.UUID
	Runtime          string
	Name             string
	Description      string
	InputSchema      []byte
	Variables        []byte
	AccessID         uuid.NullUUID
	EncryptionKey    conv.Secret
	BearerFormat     pgtype.Text
	FlyAppInternalID uuid.NullUUID
	FlyAppName       pgtype.Text
	FlyAppUrl        pgtype.Text
	FlyRunnerVersion pgtype.Text
}

func (q *Queries) GetFunctionToolByURN(ctx context.Context, arg GetFunctionToolByURNParams) (GetFunctionToolByURNRow, error) {
	row := q.db.QueryRow(ctx, getFunctionToolByURN, arg.Urn, arg.ProjectID)
	var i GetFunctionToolByURNRow
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.FunctionID,
		&i.Runtime,
		&i.Name,
		&i.Description,
		&i.InputSchema,
		&i.Variables,
		&i.AccessID,
		&i.EncryptionKey,
		&i.BearerFormat,
		&i.FlyAppInternalID,
		&i.FlyAppName,
		&i.FlyAppUrl,
		&i.FlyRunnerVersion,
	)
	return i, err
}

const getFunctionToolDefinitionByID = `-- name: GetFunctionToolDefinitionByID :one
SELECT id, tool_urn, project_id, deployment_id, function_id, runtime, name, description, input_schema, variables, created_at, updated_at, deleted_at, deleted
FROM function_tool_definitions
WHERE function_tool_definitions.id = $1
  AND function_tool_definitions.project_id = $2
  AND function_tool_definitions.deleted IS FALSE
LIMIT 1
`

type GetFunctionToolDefinitionByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetFunctionToolDefinitionByID(ctx context.Context, arg GetFunctionToolDefinitionByIDParams) (FunctionToolDefinition, error) {
	row := q.db.QueryRow(ctx, getFunctionToolDefinitionByID, arg.ID, arg.ProjectID)
	var i FunctionToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.FunctionID,
		&i.Runtime,
		&i.Name,
		&i.Description,
		&i.InputSchema,
		&i.Variables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getHTTPToolDefinitionByID = `-- name: GetHTTPToolDefinitionByID :one
WITH first_party AS (
  SELECT id
  FROM http_tool_definitions
  WHERE http_tool_definitions.id = $1
    AND http_tool_definitions.project_id = $2
    AND http_tool_definitions.deleted IS FALSE
  LIMIT 1
),
third_party AS (
  SELECT htd.id
  FROM deployments d
  INNER JOIN deployments_packages dp ON d.id =  dp.deployment_id
  INNER JOIN package_versions pv ON dp.version_id = pv.id
  INNER JOIN http_tool_definitions htd ON htd.deployment_id = pv.deployment_id
  WHERE d.project_id = $2
    AND htd.id = $1
    AND NOT EXISTS(SELECT 1 FROM first_party)
  LIMIT 1
)
SELECT id, tool_urn, project_id, deployment_id, openapiv3_document_id, confirm, confirm_prompt, summarizer, name, untruncated_name, summary, description, openapiv3_operation, tags, x_gram, original_name, original_summary, original_description, server_env_var, default_server_url, security, http_method, path, schema_version, schema, header_settings, query_settings, path_settings, request_content_type, response_filter, created_at, updated_at, deleted_at, deleted
FROM http_tool_definitions
WHERE id = COALESCE((SELECT id FROM first_party), (SELECT id FROM  third_party))
`

type GetHTTPToolDefinitionByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

// This CTE is for integrating third party tools by checking for tool definitions from external deployments/packages.
func (q *Queries) GetHTTPToolDefinitionByID(ctx context.Context, arg GetHTTPToolDefinitionByIDParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, getHTTPToolDefinitionByID, arg.ID, arg.ProjectID)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Confirm,
		&i.ConfirmPrompt,
		&i.Summarizer,
		&i.Name,
		&i.UntruncatedName,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.XGram,
		&i.OriginalName,
		&i.OriginalSummary,
		&i.OriginalDescription,
		&i.ServerEnvVar,
		&i.DefaultServerUrl,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.HeaderSettings,
		&i.QuerySettings,
		&i.PathSettings,
		&i.RequestContentType,
		&i.ResponseFilter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getHTTPToolDefinitionByURN = `-- name: GetHTTPToolDefinitionByURN :one
WITH deployment AS (
  SELECT d.id 
  FROM deployments d
  JOIN deployment_statuses ds ON d.id = ds.deployment_id
  WHERE d.project_id = $2
  AND ds.status = 'completed'
  ORDER BY d.seq DESC LIMIT 1
)
SELECT id, tool_urn, project_id, deployment_id, openapiv3_document_id, confirm, confirm_prompt, summarizer, name, untruncated_name, summary, description, openapiv3_operation, tags, x_gram, original_name, original_summary, original_description, server_env_var, default_server_url, security, http_method, path, schema_version, schema, header_settings, query_settings, path_settings, request_content_type, response_filter, created_at, updated_at, deleted_at, deleted
FROM http_tool_definitions
WHERE http_tool_definitions.tool_urn = $1
  AND http_tool_definitions.project_id = $2
  AND http_tool_definitions.deleted IS FALSE 
  AND http_tool_definitions.deployment_id = (SELECT id FROM deployment)
LIMIT 1
`

type GetHTTPToolDefinitionByURNParams struct {
	Urn       urn.Tool
	ProjectID uuid.UUID
}

func (q *Queries) GetHTTPToolDefinitionByURN(ctx context.Context, arg GetHTTPToolDefinitionByURNParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, getHTTPToolDefinitionByURN, arg.Urn, arg.ProjectID)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Confirm,
		&i.ConfirmPrompt,
		&i.Summarizer,
		&i.Name,
		&i.UntruncatedName,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.XGram,
		&i.OriginalName,
		&i.OriginalSummary,
		&i.OriginalDescription,
		&i.ServerEnvVar,
		&i.DefaultServerUrl,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.HeaderSettings,
		&i.QuerySettings,
		&i.PathSettings,
		&i.RequestContentType,
		&i.ResponseFilter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolUrnByID = `-- name: GetToolUrnByID :one
WITH first_party_http AS (
  SELECT tool_urn::text as tool_urn
  FROM http_tool_definitions
  WHERE http_tool_definitions.id = $1
    AND http_tool_definitions.project_id = $2
    AND http_tool_definitions.deleted IS FALSE
  LIMIT 1
),
third_party_http AS (
  SELECT htd.tool_urn::text as tool_urn
  FROM deployments d
  INNER JOIN deployments_packages dp ON d.id = dp.deployment_id
  INNER JOIN package_versions pv ON dp.version_id = pv.id
  INNER JOIN http_tool_definitions htd ON htd.deployment_id = pv.deployment_id
  WHERE d.project_id = $2
    AND htd.id = $1
    AND NOT EXISTS(SELECT 1 FROM first_party_http)
  LIMIT 1
),
function_tools AS (
  SELECT tool_urn::text as tool_urn
  FROM function_tool_definitions
  WHERE function_tool_definitions.id = $1
    AND function_tool_definitions.project_id = $2
    AND function_tool_definitions.deleted IS FALSE
    AND NOT EXISTS(SELECT 1 FROM first_party_http)
    AND NOT EXISTS(SELECT 1 FROM third_party_http)
  LIMIT 1
)
SELECT
  COALESCE(
    (SELECT tool_urn FROM first_party_http),
    (SELECT tool_urn FROM third_party_http),
    (SELECT tool_urn FROM function_tools)
  )::text AS tool_urn
`

type GetToolUrnByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

// This CTE is for integrating third party tools by checking for tool definitions from external deployments/packages.
func (q *Queries) GetToolUrnByID(ctx context.Context, arg GetToolUrnByIDParams) (string, error) {
	row := q.db.QueryRow(ctx, getToolUrnByID, arg.ID, arg.ProjectID)
	var tool_urn string
	err := row.Scan(&tool_urn)
	return tool_urn, err
}

const listFunctionTools = `-- name: ListFunctionTools :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $3
      AND ($4::uuid IS NOT NULL OR ds.status = 'completed')
      AND (
        $4::uuid IS NULL
        OR d.id = $4::uuid
      )
    ORDER BY d.seq DESC
    LIMIT 1
)
SELECT
  (SELECT id FROM deployment) as deployment_id,
  ftd.id,
  ftd.tool_urn,
  ftd.name,
  ftd.description,
  ftd.input_schema,
  ftd.variables,
  ftd.runtime,
  ftd.function_id,
  ftd.created_at,
  ftd.updated_at
FROM function_tool_definitions ftd
WHERE
  ftd.deployment_id = (SELECT id FROM deployment)
  AND ftd.deleted IS FALSE
  AND ($2::uuid IS NULL OR ftd.id < $2)
ORDER BY ftd.id DESC
LIMIT $1
`

type ListFunctionToolsParams struct {
	Limit        int32
	Cursor       uuid.NullUUID
	ProjectID    uuid.UUID
	DeploymentID uuid.NullUUID
}

type ListFunctionToolsRow struct {
	DeploymentID uuid.UUID
	ID           uuid.UUID
	ToolUrn      urn.Tool
	Name         string
	Description  string
	InputSchema  []byte
	Variables    []byte
	Runtime      string
	FunctionID   uuid.UUID
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

// Two use cases:
// 1. List all tools from the latest successful deployment (when deployment_id is NULL)
// 2. List all tools for a specific deployment by ID (when deployment_id is provided)
func (q *Queries) ListFunctionTools(ctx context.Context, arg ListFunctionToolsParams) ([]ListFunctionToolsRow, error) {
	rows, err := q.db.Query(ctx, listFunctionTools,
		arg.Limit,
		arg.Cursor,
		arg.ProjectID,
		arg.DeploymentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFunctionToolsRow
	for rows.Next() {
		var i ListFunctionToolsRow
		if err := rows.Scan(
			&i.DeploymentID,
			&i.ID,
			&i.ToolUrn,
			&i.Name,
			&i.Description,
			&i.InputSchema,
			&i.Variables,
			&i.Runtime,
			&i.FunctionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHttpTools = `-- name: ListHttpTools :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
      AND ($4::uuid IS NOT NULL OR ds.status = 'completed')
      AND (
        $4::uuid IS NULL
        OR d.id = $4::uuid
      )
    ORDER BY d.seq DESC
    LIMIT 1
),
all_deployment_ids AS (
    SELECT id FROM deployment
    UNION
    SELECT DISTINCT pv.deployment_id
    FROM deployment d
    JOIN deployments_packages dp ON dp.deployment_id = d.id
    JOIN package_versions pv ON dp.version_id = pv.id
)
SELECT 
  (SELECT id FROM deployment) as deployment_id,
  htd.id,
  htd.tool_urn,
  htd.name,
  htd.summary,
  htd.description,
  htd.http_method,
  htd.confirm,
  htd.confirm_prompt,
  htd.summarizer,
  htd.response_filter,
  htd.path,
  htd.openapiv3_document_id,
  htd.openapiv3_operation,
  htd.schema_version,
  htd.schema,
  htd.security,
  htd.default_server_url,
  htd.created_at,
  htd.updated_at,
  htd.tags,
  (CASE
    WHEN htd.project_id = $2 THEN ''
    WHEN packages.id IS NOT NULL THEN packages.name
    ELSE ''
  END) as package_name
FROM http_tool_definitions htd
LEFT JOIN packages ON htd.project_id = packages.project_id
WHERE
  htd.deployment_id IN (SELECT id FROM all_deployment_ids)
  AND htd.deleted IS FALSE
  AND ($3::uuid IS NULL OR htd.id < $3)
ORDER BY htd.id DESC
LIMIT $1
`

type ListHttpToolsParams struct {
	Limit        int32
	ProjectID    uuid.UUID
	Cursor       uuid.NullUUID
	DeploymentID uuid.NullUUID
}

type ListHttpToolsRow struct {
	DeploymentID        uuid.UUID
	ID                  uuid.UUID
	ToolUrn             urn.Tool
	Name                string
	Summary             string
	Description         string
	HttpMethod          string
	Confirm             pgtype.Text
	ConfirmPrompt       pgtype.Text
	Summarizer          pgtype.Text
	ResponseFilter      *models.ResponseFilter
	Path                string
	Openapiv3DocumentID uuid.NullUUID
	Openapiv3Operation  pgtype.Text
	SchemaVersion       string
	Schema              []byte
	Security            []byte
	DefaultServerUrl    pgtype.Text
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	Tags                []string
	PackageName         string
}

// Two use cases:
// 1. List all tools from the latest successful deployment (when deployment_id is NULL)
// 2. List all tools for a specific deployment by ID (when deployment_id is provided)
func (q *Queries) ListHttpTools(ctx context.Context, arg ListHttpToolsParams) ([]ListHttpToolsRow, error) {
	rows, err := q.db.Query(ctx, listHttpTools,
		arg.Limit,
		arg.ProjectID,
		arg.Cursor,
		arg.DeploymentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHttpToolsRow
	for rows.Next() {
		var i ListHttpToolsRow
		if err := rows.Scan(
			&i.DeploymentID,
			&i.ID,
			&i.ToolUrn,
			&i.Name,
			&i.Summary,
			&i.Description,
			&i.HttpMethod,
			&i.Confirm,
			&i.ConfirmPrompt,
			&i.Summarizer,
			&i.ResponseFilter,
			&i.Path,
			&i.Openapiv3DocumentID,
			&i.Openapiv3Operation,
			&i.SchemaVersion,
			&i.Schema,
			&i.Security,
			&i.DefaultServerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pokeToolDefinitionByUrn = `-- name: PokeToolDefinitionByUrn :one
WITH first_party AS (
  SELECT id
  FROM http_tool_definitions
  WHERE http_tool_definitions.tool_urn = $1
    AND http_tool_definitions.project_id = $2
    AND http_tool_definitions.deleted IS FALSE
  LIMIT 1
),
third_party AS (
  SELECT htd.id
  FROM deployments d
  INNER JOIN deployments_packages dp ON d.id =  dp.deployment_id
  INNER JOIN package_versions pv ON dp.version_id = pv.id
  INNER JOIN http_tool_definitions htd ON htd.deployment_id = pv.deployment_id
  WHERE d.project_id = $2
    AND htd.tool_urn = $1
    AND NOT EXISTS(SELECT 1 FROM first_party)
  LIMIT 1
),
function_tools AS (
  SELECT id
  FROM function_tool_definitions
  WHERE function_tool_definitions.tool_urn = $1
    AND function_tool_definitions.project_id = $2
    AND function_tool_definitions.deleted IS FALSE
    AND NOT EXISTS(SELECT 1 FROM first_party)
    AND NOT EXISTS(SELECT 1 FROM third_party)
  LIMIT 1
)
SELECT
  COALESCE(
    (SELECT id FROM first_party),
    (SELECT id FROM third_party),
    (SELECT id FROM function_tools)
  ) AS id
`

type PokeToolDefinitionByUrnParams struct {
	Urn       urn.Tool
	ProjectID uuid.UUID
}

// This CTE is for integrating third party tools by checking for tool definitions from external deployments/packages.
func (q *Queries) PokeToolDefinitionByUrn(ctx context.Context, arg PokeToolDefinitionByUrnParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, pokeToolDefinitionByUrn, arg.Urn, arg.ProjectID)
	var id interface{}
	err := row.Scan(&id)
	return id, err
}
