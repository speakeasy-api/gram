// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AddToolsetPromptTemplatesParams struct {
	ProjectID        uuid.UUID
	ToolsetID        uuid.UUID
	PromptHistoryID  uuid.UUID
	PromptTemplateID uuid.NullUUID
	PromptName       string
}

const checkMCPSlugAvailability = `-- name: CheckMCPSlugAvailability :one
SELECT EXISTS (
  SELECT 1
  FROM toolsets
  WHERE mcp_slug = $1
  AND deleted IS FALSE
)
`

func (q *Queries) CheckMCPSlugAvailability(ctx context.Context, mcpSlug pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkMCPSlugAvailability, mcpSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const clearToolsetOAuthServers = `-- name: ClearToolsetOAuthServers :one
UPDATE toolsets
SET 
    external_oauth_server_id = NULL
  , oauth_proxy_server_id = NULL
  , updated_at = clock_timestamp()
WHERE slug = $1 AND project_id = $2
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type ClearToolsetOAuthServersParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) ClearToolsetOAuthServers(ctx context.Context, arg ClearToolsetOAuthServersParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, clearToolsetOAuthServers, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const clearToolsetPromptTemplates = `-- name: ClearToolsetPromptTemplates :exec
DELETE FROM toolset_prompts
WHERE project_id = $1
  AND toolset_id = $2
`

type ClearToolsetPromptTemplatesParams struct {
	ProjectID uuid.UUID
	ToolsetID uuid.UUID
}

func (q *Queries) ClearToolsetPromptTemplates(ctx context.Context, arg ClearToolsetPromptTemplatesParams) error {
	_, err := q.db.Exec(ctx, clearToolsetPromptTemplates, arg.ProjectID, arg.ToolsetID)
	return err
}

const createToolset = `-- name: CreateToolset :one
INSERT INTO toolsets (
    organization_id
  , project_id
  , name
  , slug
  , description
  , http_tool_names
  , default_environment_slug
  , mcp_slug
  , mcp_enabled
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , COALESCE($6::text[], '{}'::text[])
  , $7
  , $8
  , $9
)
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type CreateToolsetParams struct {
	OrganizationID         string
	ProjectID              uuid.UUID
	Name                   string
	Slug                   string
	Description            pgtype.Text
	HttpToolNames          []string
	DefaultEnvironmentSlug pgtype.Text
	McpSlug                pgtype.Text
	McpEnabled             bool
}

func (q *Queries) CreateToolset(ctx context.Context, arg CreateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, createToolset,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.HttpToolNames,
		arg.DefaultEnvironmentSlug,
		arg.McpSlug,
		arg.McpEnabled,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteToolset = `-- name: DeleteToolset :exec
UPDATE toolsets
SET deleted_at = clock_timestamp()
WHERE slug = $1
  AND project_id = $2 AND deleted IS FALSE
`

type DeleteToolsetParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) DeleteToolset(ctx context.Context, arg DeleteToolsetParams) error {
	_, err := q.db.Exec(ctx, deleteToolset, arg.Slug, arg.ProjectID)
	return err
}

const getHTTPSecurityDefinitions = `-- name: GetHTTPSecurityDefinitions :many
SELECT id, deployment_id, project_id, openapiv3_document_id, key, type, name, in_placement, scheme, bearer_format, oauth_types, oauth_flows, env_variables, created_at, updated_at, deleted_at, deleted
FROM http_security
WHERE key = ANY($1::TEXT[]) AND deployment_id = ANY($2::UUID[])
`

type GetHTTPSecurityDefinitionsParams struct {
	SecurityKeys  []string
	DeploymentIds []uuid.UUID
}

func (q *Queries) GetHTTPSecurityDefinitions(ctx context.Context, arg GetHTTPSecurityDefinitionsParams) ([]HttpSecurity, error) {
	rows, err := q.db.Query(ctx, getHTTPSecurityDefinitions, arg.SecurityKeys, arg.DeploymentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HttpSecurity
	for rows.Next() {
		var i HttpSecurity
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.ProjectID,
			&i.Openapiv3DocumentID,
			&i.Key,
			&i.Type,
			&i.Name,
			&i.InPlacement,
			&i.Scheme,
			&i.BearerFormat,
			&i.OauthTypes,
			&i.OauthFlows,
			&i.EnvVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPromptTemplatesForToolset = `-- name: GetPromptTemplatesForToolset :many
WITH ranked_templates AS (
  SELECT 
    pt.id, pt.project_id, pt.history_id, pt.predecessor_id, pt.name, pt.description, pt.arguments, pt.prompt, pt.engine, pt.kind, pt.tools_hint, pt.created_at, pt.updated_at, pt.deleted_at, pt.deleted,
    ROW_NUMBER() OVER (PARTITION BY pt.history_id ORDER BY pt.id DESC) as rn
  FROM prompt_templates pt
  WHERE project_id = $2
    AND pt.deleted IS FALSE
)
SELECT rel.id as tp_id, rt.id, rt.project_id, rt.history_id, rt.predecessor_id, rt.name, rt.description, rt.arguments, rt.prompt, rt.engine, rt.kind, rt.tools_hint, rt.created_at, rt.updated_at, rt.deleted_at, rt.deleted, rt.rn
FROM toolset_prompts rel
JOIN ranked_templates rt ON (
  (rel.prompt_template_id IS NOT NULL AND rt.id = rel.prompt_template_id)
  OR 
  (rel.prompt_template_id IS NULL AND rt.history_id = rel.prompt_history_id AND rt.rn = 1)
)
WHERE rel.toolset_id = $1
  AND rel.project_id = $2
ORDER BY rel.prompt_name
`

type GetPromptTemplatesForToolsetParams struct {
	ToolsetID uuid.UUID
	ProjectID uuid.UUID
}

type GetPromptTemplatesForToolsetRow struct {
	TpID          uuid.UUID
	ID            uuid.UUID
	ProjectID     uuid.UUID
	HistoryID     uuid.UUID
	PredecessorID uuid.NullUUID
	Name          string
	Description   pgtype.Text
	Arguments     []byte
	Prompt        string
	Engine        pgtype.Text
	Kind          pgtype.Text
	ToolsHint     []string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	Deleted       bool
	Rn            int64
}

func (q *Queries) GetPromptTemplatesForToolset(ctx context.Context, arg GetPromptTemplatesForToolsetParams) ([]GetPromptTemplatesForToolsetRow, error) {
	rows, err := q.db.Query(ctx, getPromptTemplatesForToolset, arg.ToolsetID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPromptTemplatesForToolsetRow
	for rows.Next() {
		var i GetPromptTemplatesForToolsetRow
		if err := rows.Scan(
			&i.TpID,
			&i.ID,
			&i.ProjectID,
			&i.HistoryID,
			&i.PredecessorID,
			&i.Name,
			&i.Description,
			&i.Arguments,
			&i.Prompt,
			&i.Engine,
			&i.Kind,
			&i.ToolsHint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolset = `-- name: GetToolset :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE slug = $1 AND project_id = $2 AND deleted IS FALSE
`

type GetToolsetParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) GetToolset(ctx context.Context, arg GetToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolset, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMcpSlug = `-- name: GetToolsetByMcpSlug :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1
  AND custom_domain_id IS NULL
  AND deleted IS FALSE
`

func (q *Queries) GetToolsetByMcpSlug(ctx context.Context, mcpSlug pgtype.Text) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMcpSlug, mcpSlug)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMcpSlugAndCustomDomain = `-- name: GetToolsetByMcpSlugAndCustomDomain :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1
  AND custom_domain_id = $2
  AND deleted IS FALSE
`

type GetToolsetByMcpSlugAndCustomDomainParams struct {
	McpSlug        pgtype.Text
	CustomDomainID uuid.NullUUID
}

func (q *Queries) GetToolsetByMcpSlugAndCustomDomain(ctx context.Context, arg GetToolsetByMcpSlugAndCustomDomainParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMcpSlugAndCustomDomain, arg.McpSlug, arg.CustomDomainID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listPublicToolsetsByOrganization = `-- name: ListPublicToolsetsByOrganization :many
SELECT t.id, t.organization_id, t.project_id, t.name, t.slug, t.description, t.default_environment_slug, t.http_tool_names, t.mcp_slug, t.mcp_is_public, t.mcp_enabled, t.custom_domain_id, t.external_oauth_server_id, t.oauth_proxy_server_id, t.created_at, t.updated_at, t.deleted_at, t.deleted
FROM toolsets t
JOIN projects p ON t.project_id = p.id
WHERE p.organization_id = $1
  AND t.mcp_is_public IS TRUE
  AND t.deleted IS FALSE
  AND p.deleted IS FALSE
ORDER BY t.created_at DESC
`

func (q *Queries) ListPublicToolsetsByOrganization(ctx context.Context, organizationID string) ([]Toolset, error) {
	rows, err := q.db.Query(ctx, listPublicToolsetsByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Toolset
	for rows.Next() {
		var i Toolset
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.DefaultEnvironmentSlug,
			&i.HttpToolNames,
			&i.McpSlug,
			&i.McpIsPublic,
			&i.McpEnabled,
			&i.CustomDomainID,
			&i.ExternalOauthServerID,
			&i.OauthProxyServerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolsetsByProject = `-- name: ListToolsetsByProject :many
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE project_id = $1
  AND deleted IS FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListToolsetsByProject(ctx context.Context, projectID uuid.UUID) ([]Toolset, error) {
	rows, err := q.db.Query(ctx, listToolsetsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Toolset
	for rows.Next() {
		var i Toolset
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.DefaultEnvironmentSlug,
			&i.HttpToolNames,
			&i.McpSlug,
			&i.McpIsPublic,
			&i.McpEnabled,
			&i.CustomDomainID,
			&i.ExternalOauthServerID,
			&i.OauthProxyServerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolset = `-- name: UpdateToolset :one
UPDATE toolsets
SET 
    name = COALESCE($1, name)
  , description = COALESCE($2, description)
  , http_tool_names = COALESCE($3::text[], http_tool_names)
  , default_environment_slug = COALESCE($4, default_environment_slug)
  , mcp_slug = COALESCE($5, mcp_slug)
  , mcp_is_public = COALESCE($6, mcp_is_public)
  , custom_domain_id = COALESCE($7, custom_domain_id)
  , mcp_enabled = COALESCE($8, mcp_enabled)
  , updated_at = clock_timestamp()
WHERE slug = $9 AND project_id = $10
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type UpdateToolsetParams struct {
	Name                   string
	Description            pgtype.Text
	HttpToolNames          []string
	DefaultEnvironmentSlug pgtype.Text
	McpSlug                pgtype.Text
	McpIsPublic            bool
	CustomDomainID         uuid.NullUUID
	McpEnabled             bool
	Slug                   string
	ProjectID              uuid.UUID
}

func (q *Queries) UpdateToolset(ctx context.Context, arg UpdateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolset,
		arg.Name,
		arg.Description,
		arg.HttpToolNames,
		arg.DefaultEnvironmentSlug,
		arg.McpSlug,
		arg.McpIsPublic,
		arg.CustomDomainID,
		arg.McpEnabled,
		arg.Slug,
		arg.ProjectID,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const updateToolsetExternalOAuthServer = `-- name: UpdateToolsetExternalOAuthServer :one
UPDATE toolsets
SET 
    external_oauth_server_id = $1
  , updated_at = clock_timestamp()
WHERE slug = $2 AND project_id = $3
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, http_tool_names, mcp_slug, mcp_is_public, mcp_enabled, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type UpdateToolsetExternalOAuthServerParams struct {
	ExternalOauthServerID uuid.NullUUID
	Slug                  string
	ProjectID             uuid.UUID
}

func (q *Queries) UpdateToolsetExternalOAuthServer(ctx context.Context, arg UpdateToolsetExternalOAuthServerParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolsetExternalOAuthServer, arg.ExternalOauthServerID, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.HttpToolNames,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
