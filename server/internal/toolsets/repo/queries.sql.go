// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/urn"
)

type AddToolsetPromptTemplatesParams struct {
	ProjectID        uuid.UUID
	ToolsetID        uuid.UUID
	PromptHistoryID  uuid.UUID
	PromptTemplateID uuid.NullUUID
	PromptName       string
}

const checkMCPSlugAvailability = `-- name: CheckMCPSlugAvailability :one
SELECT EXISTS (
  SELECT 1
  FROM toolsets
  WHERE mcp_slug = $1
  AND deleted IS FALSE
)
`

func (q *Queries) CheckMCPSlugAvailability(ctx context.Context, mcpSlug pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkMCPSlugAvailability, mcpSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const clearToolsetOAuthServers = `-- name: ClearToolsetOAuthServers :one
UPDATE toolsets
SET
    external_oauth_server_id = NULL
  , oauth_proxy_server_id = NULL
  , updated_at = clock_timestamp()
WHERE slug = $1 AND project_id = $2
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type ClearToolsetOAuthServersParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) ClearToolsetOAuthServers(ctx context.Context, arg ClearToolsetOAuthServersParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, clearToolsetOAuthServers, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const clearToolsetPromptTemplates = `-- name: ClearToolsetPromptTemplates :exec
DELETE FROM toolset_prompts
WHERE project_id = $1
  AND toolset_id = $2
`

type ClearToolsetPromptTemplatesParams struct {
	ProjectID uuid.UUID
	ToolsetID uuid.UUID
}

func (q *Queries) ClearToolsetPromptTemplates(ctx context.Context, arg ClearToolsetPromptTemplatesParams) error {
	_, err := q.db.Exec(ctx, clearToolsetPromptTemplates, arg.ProjectID, arg.ToolsetID)
	return err
}

const createToolset = `-- name: CreateToolset :one
INSERT INTO toolsets (
    organization_id
  , project_id
  , name
  , slug
  , description
  , default_environment_slug
  , mcp_slug
  , mcp_enabled
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
)
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type CreateToolsetParams struct {
	OrganizationID         string
	ProjectID              uuid.UUID
	Name                   string
	Slug                   string
	Description            pgtype.Text
	DefaultEnvironmentSlug pgtype.Text
	McpSlug                pgtype.Text
	McpEnabled             bool
}

func (q *Queries) CreateToolset(ctx context.Context, arg CreateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, createToolset,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.DefaultEnvironmentSlug,
		arg.McpSlug,
		arg.McpEnabled,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createToolsetVersion = `-- name: CreateToolsetVersion :one
INSERT INTO toolset_versions (
    toolset_id
  , version
  , tool_urns
  , resource_urns
  , predecessor_id
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
)
RETURNING id, toolset_id, version, tool_urns, resource_urns, predecessor_id, created_at, updated_at, deleted_at, deleted
`

type CreateToolsetVersionParams struct {
	ToolsetID     uuid.UUID
	Version       int64
	ToolUrns      []urn.Tool
	ResourceUrns  []urn.Resource
	PredecessorID uuid.NullUUID
}

func (q *Queries) CreateToolsetVersion(ctx context.Context, arg CreateToolsetVersionParams) (ToolsetVersion, error) {
	row := q.db.QueryRow(ctx, createToolsetVersion,
		arg.ToolsetID,
		arg.Version,
		arg.ToolUrns,
		arg.ResourceUrns,
		arg.PredecessorID,
	)
	var i ToolsetVersion
	err := row.Scan(
		&i.ID,
		&i.ToolsetID,
		&i.Version,
		&i.ToolUrns,
		&i.ResourceUrns,
		&i.PredecessorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteToolset = `-- name: DeleteToolset :exec
UPDATE toolsets
SET deleted_at = clock_timestamp()
WHERE slug = $1
  AND project_id = $2 AND deleted IS FALSE
`

type DeleteToolsetParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) DeleteToolset(ctx context.Context, arg DeleteToolsetParams) error {
	_, err := q.db.Exec(ctx, deleteToolset, arg.Slug, arg.ProjectID)
	return err
}

const getHTTPSecurityDefinitions = `-- name: GetHTTPSecurityDefinitions :many
SELECT id, deployment_id, project_id, openapiv3_document_id, key, type, name, in_placement, scheme, bearer_format, oauth_types, oauth_flows, env_variables, created_at, updated_at, deleted_at, deleted
FROM http_security
WHERE key = ANY($1::TEXT[]) AND deployment_id = ANY($2::UUID[])
`

type GetHTTPSecurityDefinitionsParams struct {
	SecurityKeys  []string
	DeploymentIds []uuid.UUID
}

func (q *Queries) GetHTTPSecurityDefinitions(ctx context.Context, arg GetHTTPSecurityDefinitionsParams) ([]HttpSecurity, error) {
	rows, err := q.db.Query(ctx, getHTTPSecurityDefinitions, arg.SecurityKeys, arg.DeploymentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HttpSecurity
	for rows.Next() {
		var i HttpSecurity
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.ProjectID,
			&i.Openapiv3DocumentID,
			&i.Key,
			&i.Type,
			&i.Name,
			&i.InPlacement,
			&i.Scheme,
			&i.BearerFormat,
			&i.OauthTypes,
			&i.OauthFlows,
			&i.EnvVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestToolsetVersion = `-- name: GetLatestToolsetVersion :one
SELECT id, toolset_id, version, tool_urns, resource_urns, predecessor_id, created_at, updated_at, deleted_at, deleted
FROM toolset_versions
WHERE toolset_id = $1
  AND deleted IS FALSE
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetLatestToolsetVersion(ctx context.Context, toolsetID uuid.UUID) (ToolsetVersion, error) {
	row := q.db.QueryRow(ctx, getLatestToolsetVersion, toolsetID)
	var i ToolsetVersion
	err := row.Scan(
		&i.ID,
		&i.ToolsetID,
		&i.Version,
		&i.ToolUrns,
		&i.ResourceUrns,
		&i.PredecessorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getPromptTemplateUrnsByNames = `-- name: GetPromptTemplateUrnsByNames :many
SELECT DISTINCT pt.tool_urn
FROM prompt_templates pt
WHERE pt.name = ANY($1::TEXT[])
  AND pt.project_id = $2
  AND pt.deleted IS FALSE
  AND pt.tool_urn IS NOT NULL
ORDER BY pt.tool_urn
`

type GetPromptTemplateUrnsByNamesParams struct {
	TemplateNames []string
	ProjectID     uuid.UUID
}

func (q *Queries) GetPromptTemplateUrnsByNames(ctx context.Context, arg GetPromptTemplateUrnsByNamesParams) ([]urn.Tool, error) {
	rows, err := q.db.Query(ctx, getPromptTemplateUrnsByNames, arg.TemplateNames, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []urn.Tool
	for rows.Next() {
		var tool_urn urn.Tool
		if err := rows.Scan(&tool_urn); err != nil {
			return nil, err
		}
		items = append(items, tool_urn)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPromptTemplatesForToolset = `-- name: GetPromptTemplatesForToolset :many
WITH ranked_templates AS (
  SELECT
    pt.id, pt.tool_urn, pt.project_id, pt.history_id, pt.predecessor_id, pt.name, pt.description, pt.arguments, pt.prompt, pt.engine, pt.kind, pt.tools_hint, pt.tool_urns_hint, pt.created_at, pt.updated_at, pt.deleted_at, pt.deleted,
    ROW_NUMBER() OVER (PARTITION BY pt.history_id ORDER BY pt.id DESC) as rn
  FROM prompt_templates pt
  WHERE project_id = $2
    AND pt.deleted IS FALSE
)
SELECT rel.id as tp_id, rt.id, rt.tool_urn, rt.project_id, rt.history_id, rt.predecessor_id, rt.name, rt.description, rt.arguments, rt.prompt, rt.engine, rt.kind, rt.tools_hint, rt.tool_urns_hint, rt.created_at, rt.updated_at, rt.deleted_at, rt.deleted, rt.rn
FROM toolset_prompts rel
JOIN ranked_templates rt ON (
  (rel.prompt_template_id IS NOT NULL AND rt.id = rel.prompt_template_id)
  OR
  (rel.prompt_template_id IS NULL AND rt.history_id = rel.prompt_history_id AND rt.rn = 1)
)
WHERE rel.toolset_id = $1
  AND rel.project_id = $2
ORDER BY rel.prompt_name
`

type GetPromptTemplatesForToolsetParams struct {
	ToolsetID uuid.UUID
	ProjectID uuid.UUID
}

type GetPromptTemplatesForToolsetRow struct {
	TpID          uuid.UUID
	ID            uuid.UUID
	ToolUrn       string
	ProjectID     uuid.UUID
	HistoryID     uuid.UUID
	PredecessorID uuid.NullUUID
	Name          string
	Description   pgtype.Text
	Arguments     []byte
	Prompt        string
	Engine        pgtype.Text
	Kind          pgtype.Text
	ToolsHint     []string
	ToolUrnsHint  []string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
	Deleted       bool
	Rn            int64
}

func (q *Queries) GetPromptTemplatesForToolset(ctx context.Context, arg GetPromptTemplatesForToolsetParams) ([]GetPromptTemplatesForToolsetRow, error) {
	rows, err := q.db.Query(ctx, getPromptTemplatesForToolset, arg.ToolsetID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPromptTemplatesForToolsetRow
	for rows.Next() {
		var i GetPromptTemplatesForToolsetRow
		if err := rows.Scan(
			&i.TpID,
			&i.ID,
			&i.ToolUrn,
			&i.ProjectID,
			&i.HistoryID,
			&i.PredecessorID,
			&i.Name,
			&i.Description,
			&i.Arguments,
			&i.Prompt,
			&i.Engine,
			&i.Kind,
			&i.ToolsHint,
			&i.ToolUrnsHint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolset = `-- name: GetToolset :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE slug = $1 AND project_id = $2 AND deleted IS FALSE
`

type GetToolsetParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) GetToolset(ctx context.Context, arg GetToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolset, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByID = `-- name: GetToolsetByID :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE id = $1 AND deleted IS FALSE
`

func (q *Queries) GetToolsetByID(ctx context.Context, id uuid.UUID) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByID, id)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMCPSlug = `-- name: GetToolsetByMCPSlug :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1 AND project_id = $2 AND deleted IS FALSE
`

type GetToolsetByMCPSlugParams struct {
	McpSlug   pgtype.Text
	ProjectID uuid.UUID
}

// project_id is required to ensure uniqueness since mcp_slug is only unique within a project
func (q *Queries) GetToolsetByMCPSlug(ctx context.Context, arg GetToolsetByMCPSlugParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMCPSlug, arg.McpSlug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMcpSlug = `-- name: GetToolsetByMcpSlug :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1
  AND custom_domain_id IS NULL
  AND deleted IS FALSE
`

func (q *Queries) GetToolsetByMcpSlug(ctx context.Context, mcpSlug pgtype.Text) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMcpSlug, mcpSlug)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMcpSlugAndCustomDomain = `-- name: GetToolsetByMcpSlugAndCustomDomain :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1
  AND custom_domain_id = $2
  AND deleted IS FALSE
`

type GetToolsetByMcpSlugAndCustomDomainParams struct {
	McpSlug        pgtype.Text
	CustomDomainID uuid.NullUUID
}

func (q *Queries) GetToolsetByMcpSlugAndCustomDomain(ctx context.Context, arg GetToolsetByMcpSlugAndCustomDomainParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMcpSlugAndCustomDomain, arg.McpSlug, arg.CustomDomainID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetByMcpSlugAndProject = `-- name: GetToolsetByMcpSlugAndProject :one
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE mcp_slug = $1
  AND project_id = $2
  AND deleted IS FALSE
`

type GetToolsetByMcpSlugAndProjectParams struct {
	McpSlug   pgtype.Text
	ProjectID uuid.UUID
}

func (q *Queries) GetToolsetByMcpSlugAndProject(ctx context.Context, arg GetToolsetByMcpSlugAndProjectParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, getToolsetByMcpSlugAndProject, arg.McpSlug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getToolsetPromptTemplateNames = `-- name: GetToolsetPromptTemplateNames :many
SELECT tp.prompt_name
FROM toolset_prompts tp
WHERE tp.toolset_id = $1
  AND tp.project_id = $2
ORDER BY tp.prompt_name
`

type GetToolsetPromptTemplateNamesParams struct {
	ToolsetID uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetToolsetPromptTemplateNames(ctx context.Context, arg GetToolsetPromptTemplateNamesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getToolsetPromptTemplateNames, arg.ToolsetID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var prompt_name string
		if err := rows.Scan(&prompt_name); err != nil {
			return nil, err
		}
		items = append(items, prompt_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolsetsByToolURN = `-- name: GetToolsetsByToolURN :many
SELECT
    t.id, t.organization_id, t.project_id, t.name, t.slug, t.description, t.default_environment_slug, t.mcp_slug, t.mcp_is_public, t.mcp_enabled, t.tool_selection_mode, t.custom_domain_id, t.external_oauth_server_id, t.oauth_proxy_server_id, t.created_at, t.updated_at, t.deleted_at, t.deleted,
    tv.version as latest_version
FROM toolsets t
JOIN toolset_versions tv ON t.id = tv.toolset_id
WHERE t.project_id = $1
  AND t.deleted IS FALSE
  AND tv.deleted IS FALSE
  AND $2::TEXT = ANY(tv.tool_urns)
  AND tv.version = (
    SELECT MAX(version)
    FROM toolset_versions tv2
    WHERE tv2.toolset_id = t.id
      AND tv2.deleted IS FALSE
  )
`

type GetToolsetsByToolURNParams struct {
	ProjectID uuid.UUID
	ToolUrn   string
}

type GetToolsetsByToolURNRow struct {
	ID                     uuid.UUID
	OrganizationID         string
	ProjectID              uuid.UUID
	Name                   string
	Slug                   string
	Description            pgtype.Text
	DefaultEnvironmentSlug pgtype.Text
	McpSlug                pgtype.Text
	McpIsPublic            bool
	McpEnabled             bool
	ToolSelectionMode      string
	CustomDomainID         uuid.NullUUID
	ExternalOauthServerID  uuid.NullUUID
	OauthProxyServerID     uuid.NullUUID
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	DeletedAt              pgtype.Timestamptz
	Deleted                bool
	LatestVersion          int64
}

func (q *Queries) GetToolsetsByToolURN(ctx context.Context, arg GetToolsetsByToolURNParams) ([]GetToolsetsByToolURNRow, error) {
	rows, err := q.db.Query(ctx, getToolsetsByToolURN, arg.ProjectID, arg.ToolUrn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetToolsetsByToolURNRow
	for rows.Next() {
		var i GetToolsetsByToolURNRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.DefaultEnvironmentSlug,
			&i.McpSlug,
			&i.McpIsPublic,
			&i.McpEnabled,
			&i.ToolSelectionMode,
			&i.CustomDomainID,
			&i.ExternalOauthServerID,
			&i.OauthProxyServerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.LatestVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledToolsetsByOrganization = `-- name: ListEnabledToolsetsByOrganization :many
SELECT t.id, t.organization_id, t.project_id, t.name, t.slug, t.description, t.default_environment_slug, t.mcp_slug, t.mcp_is_public, t.mcp_enabled, t.tool_selection_mode, t.custom_domain_id, t.external_oauth_server_id, t.oauth_proxy_server_id, t.created_at, t.updated_at, t.deleted_at, t.deleted
FROM toolsets t
JOIN projects p ON t.project_id = p.id
WHERE p.organization_id = $1
  AND t.mcp_enabled IS TRUE
  AND t.deleted IS FALSE
  AND p.deleted IS FALSE
ORDER BY t.created_at DESC
`

func (q *Queries) ListEnabledToolsetsByOrganization(ctx context.Context, organizationID string) ([]Toolset, error) {
	rows, err := q.db.Query(ctx, listEnabledToolsetsByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Toolset
	for rows.Next() {
		var i Toolset
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.DefaultEnvironmentSlug,
			&i.McpSlug,
			&i.McpIsPublic,
			&i.McpEnabled,
			&i.ToolSelectionMode,
			&i.CustomDomainID,
			&i.ExternalOauthServerID,
			&i.OauthProxyServerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolsetsByProject = `-- name: ListToolsetsByProject :many
SELECT id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
FROM toolsets
WHERE project_id = $1
  AND deleted IS FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListToolsetsByProject(ctx context.Context, projectID uuid.UUID) ([]Toolset, error) {
	rows, err := q.db.Query(ctx, listToolsetsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Toolset
	for rows.Next() {
		var i Toolset
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.DefaultEnvironmentSlug,
			&i.McpSlug,
			&i.McpIsPublic,
			&i.McpEnabled,
			&i.ToolSelectionMode,
			&i.CustomDomainID,
			&i.ExternalOauthServerID,
			&i.OauthProxyServerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolset = `-- name: UpdateToolset :one
UPDATE toolsets
SET
    name = COALESCE($1, name)
  , description = COALESCE($2, description)
  , default_environment_slug = COALESCE($3, default_environment_slug)
  , mcp_slug = COALESCE($4, mcp_slug)
  , mcp_is_public = COALESCE($5, mcp_is_public)
  , custom_domain_id = COALESCE($6, custom_domain_id)
  , mcp_enabled = COALESCE($7, mcp_enabled)
  , tool_selection_mode = COALESCE($8, tool_selection_mode)
  , updated_at = clock_timestamp()
WHERE slug = $9 AND project_id = $10
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type UpdateToolsetParams struct {
	Name                   string
	Description            pgtype.Text
	DefaultEnvironmentSlug pgtype.Text
	McpSlug                pgtype.Text
	McpIsPublic            bool
	CustomDomainID         uuid.NullUUID
	McpEnabled             bool
	ToolSelectionMode      string
	Slug                   string
	ProjectID              uuid.UUID
}

func (q *Queries) UpdateToolset(ctx context.Context, arg UpdateToolsetParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolset,
		arg.Name,
		arg.Description,
		arg.DefaultEnvironmentSlug,
		arg.McpSlug,
		arg.McpIsPublic,
		arg.CustomDomainID,
		arg.McpEnabled,
		arg.ToolSelectionMode,
		arg.Slug,
		arg.ProjectID,
	)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const updateToolsetExternalOAuthServer = `-- name: UpdateToolsetExternalOAuthServer :one
UPDATE toolsets
SET
    external_oauth_server_id = $1
  , updated_at = clock_timestamp()
WHERE slug = $2 AND project_id = $3
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type UpdateToolsetExternalOAuthServerParams struct {
	ExternalOauthServerID uuid.NullUUID
	Slug                  string
	ProjectID             uuid.UUID
}

func (q *Queries) UpdateToolsetExternalOAuthServer(ctx context.Context, arg UpdateToolsetExternalOAuthServerParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolsetExternalOAuthServer, arg.ExternalOauthServerID, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const updateToolsetOAuthProxyServer = `-- name: UpdateToolsetOAuthProxyServer :one
UPDATE toolsets
SET
    oauth_proxy_server_id = $1
  , updated_at = clock_timestamp()
WHERE slug = $2 AND project_id = $3
RETURNING id, organization_id, project_id, name, slug, description, default_environment_slug, mcp_slug, mcp_is_public, mcp_enabled, tool_selection_mode, custom_domain_id, external_oauth_server_id, oauth_proxy_server_id, created_at, updated_at, deleted_at, deleted
`

type UpdateToolsetOAuthProxyServerParams struct {
	OauthProxyServerID uuid.NullUUID
	Slug               string
	ProjectID          uuid.UUID
}

func (q *Queries) UpdateToolsetOAuthProxyServer(ctx context.Context, arg UpdateToolsetOAuthProxyServerParams) (Toolset, error) {
	row := q.db.QueryRow(ctx, updateToolsetOAuthProxyServer, arg.OauthProxyServerID, arg.Slug, arg.ProjectID)
	var i Toolset
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.DefaultEnvironmentSlug,
		&i.McpSlug,
		&i.McpIsPublic,
		&i.McpEnabled,
		&i.ToolSelectionMode,
		&i.CustomDomainID,
		&i.ExternalOauthServerID,
		&i.OauthProxyServerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
