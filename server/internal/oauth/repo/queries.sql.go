// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createExternalOAuthServerMetadata = `-- name: CreateExternalOAuthServerMetadata :one

INSERT INTO external_oauth_server_metadata (
    project_id,
    slug,
    metadata
) VALUES (
    $1,
    $2,
    $3
) RETURNING id, project_id, slug, metadata, secrets, created_at, updated_at, deleted_at, deleted
`

type CreateExternalOAuthServerMetadataParams struct {
	ProjectID uuid.UUID
	Slug      string
	Metadata  []byte
}

// External OAuth Server Metadata Queries
func (q *Queries) CreateExternalOAuthServerMetadata(ctx context.Context, arg CreateExternalOAuthServerMetadataParams) (ExternalOauthServerMetadatum, error) {
	row := q.db.QueryRow(ctx, createExternalOAuthServerMetadata, arg.ProjectID, arg.Slug, arg.Metadata)
	var i ExternalOauthServerMetadatum
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.Metadata,
		&i.Secrets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteExternalOAuthServerMetadata = `-- name: DeleteExternalOAuthServerMetadata :exec
UPDATE external_oauth_server_metadata SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE project_id = $1 AND id = $2
`

type DeleteExternalOAuthServerMetadataParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteExternalOAuthServerMetadata(ctx context.Context, arg DeleteExternalOAuthServerMetadataParams) error {
	_, err := q.db.Exec(ctx, deleteExternalOAuthServerMetadata, arg.ProjectID, arg.ID)
	return err
}

const deleteOAuthProxyProvider = `-- name: DeleteOAuthProxyProvider :exec
UPDATE oauth_proxy_providers SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE project_id = $1 AND id = $2
`

type DeleteOAuthProxyProviderParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteOAuthProxyProvider(ctx context.Context, arg DeleteOAuthProxyProviderParams) error {
	_, err := q.db.Exec(ctx, deleteOAuthProxyProvider, arg.ProjectID, arg.ID)
	return err
}

const deleteOAuthProxyServer = `-- name: DeleteOAuthProxyServer :exec
UPDATE oauth_proxy_servers SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE project_id = $1 AND id = $2
`

type DeleteOAuthProxyServerParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteOAuthProxyServer(ctx context.Context, arg DeleteOAuthProxyServerParams) error {
	_, err := q.db.Exec(ctx, deleteOAuthProxyServer, arg.ProjectID, arg.ID)
	return err
}

const getExternalMCPOAuthClient = `-- name: GetExternalMCPOAuthClient :one
SELECT id, project_id, external_mcp_attachment_id, client_id_encrypted, client_secret_encrypted, client_id_expires_at, registration_access_token_encrypted, registration_client_uri, created_at, updated_at FROM external_mcp_oauth_clients
WHERE external_mcp_attachment_id = $1
`

func (q *Queries) GetExternalMCPOAuthClient(ctx context.Context, externalMcpAttachmentID uuid.UUID) (ExternalMcpOauthClient, error) {
	row := q.db.QueryRow(ctx, getExternalMCPOAuthClient, externalMcpAttachmentID)
	var i ExternalMcpOauthClient
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ExternalMcpAttachmentID,
		&i.ClientIDEncrypted,
		&i.ClientSecretEncrypted,
		&i.ClientIDExpiresAt,
		&i.RegistrationAccessTokenEncrypted,
		&i.RegistrationClientUri,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExternalOAuthServerMetadata = `-- name: GetExternalOAuthServerMetadata :one
SELECT id, project_id, slug, metadata, secrets, created_at, updated_at, deleted_at, deleted FROM external_oauth_server_metadata
WHERE project_id = $1 AND id = $2 AND deleted IS FALSE
`

type GetExternalOAuthServerMetadataParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) GetExternalOAuthServerMetadata(ctx context.Context, arg GetExternalOAuthServerMetadataParams) (ExternalOauthServerMetadatum, error) {
	row := q.db.QueryRow(ctx, getExternalOAuthServerMetadata, arg.ProjectID, arg.ID)
	var i ExternalOauthServerMetadatum
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.Metadata,
		&i.Secrets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getExternalOAuthServerWithSecrets = `-- name: GetExternalOAuthServerWithSecrets :one

SELECT id, project_id, slug, metadata, secrets, created_at, updated_at, deleted_at, deleted FROM external_oauth_server_metadata
WHERE project_id = $1 AND id = $2 AND deleted IS FALSE
`

type GetExternalOAuthServerWithSecretsParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

// External OAuth Server Secrets Queries
func (q *Queries) GetExternalOAuthServerWithSecrets(ctx context.Context, arg GetExternalOAuthServerWithSecretsParams) (ExternalOauthServerMetadatum, error) {
	row := q.db.QueryRow(ctx, getExternalOAuthServerWithSecrets, arg.ProjectID, arg.ID)
	var i ExternalOauthServerMetadatum
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.Metadata,
		&i.Secrets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getOAuthProxyServer = `-- name: GetOAuthProxyServer :one
SELECT id, project_id, slug, created_at, updated_at, deleted_at, deleted
FROM oauth_proxy_servers s
WHERE s.project_id = $1 AND s.id = $2 AND s.deleted IS FALSE
`

type GetOAuthProxyServerParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) GetOAuthProxyServer(ctx context.Context, arg GetOAuthProxyServerParams) (OauthProxyServer, error) {
	row := q.db.QueryRow(ctx, getOAuthProxyServer, arg.ProjectID, arg.ID)
	var i OauthProxyServer
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listOAuthProxyProvidersByServer = `-- name: ListOAuthProxyProvidersByServer :many
SELECT id, project_id, oauth_proxy_server_id, slug, provider_type, authorization_endpoint, token_endpoint, registration_endpoint, scopes_supported, response_types_supported, response_modes_supported, grant_types_supported, token_endpoint_auth_methods_supported, security_key_names, secrets, created_at, updated_at, deleted_at, deleted FROM oauth_proxy_providers
WHERE oauth_proxy_server_id = $1 AND project_id = $2 AND deleted IS FALSE
ORDER BY created_at ASC
`

type ListOAuthProxyProvidersByServerParams struct {
	OauthProxyServerID uuid.UUID
	ProjectID          uuid.UUID
}

func (q *Queries) ListOAuthProxyProvidersByServer(ctx context.Context, arg ListOAuthProxyProvidersByServerParams) ([]OauthProxyProvider, error) {
	rows, err := q.db.Query(ctx, listOAuthProxyProvidersByServer, arg.OauthProxyServerID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OauthProxyProvider
	for rows.Next() {
		var i OauthProxyProvider
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.OauthProxyServerID,
			&i.Slug,
			&i.ProviderType,
			&i.AuthorizationEndpoint,
			&i.TokenEndpoint,
			&i.RegistrationEndpoint,
			&i.ScopesSupported,
			&i.ResponseTypesSupported,
			&i.ResponseModesSupported,
			&i.GrantTypesSupported,
			&i.TokenEndpointAuthMethodsSupported,
			&i.SecurityKeyNames,
			&i.Secrets,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExternalOAuthServerSecrets = `-- name: UpdateExternalOAuthServerSecrets :exec
UPDATE external_oauth_server_metadata SET
    secrets = $1,
    updated_at = clock_timestamp()
WHERE project_id = $2 AND id = $3 AND deleted IS FALSE
`

type UpdateExternalOAuthServerSecretsParams struct {
	Secrets   []byte
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) UpdateExternalOAuthServerSecrets(ctx context.Context, arg UpdateExternalOAuthServerSecretsParams) error {
	_, err := q.db.Exec(ctx, updateExternalOAuthServerSecrets, arg.Secrets, arg.ProjectID, arg.ID)
	return err
}

const upsertExternalMCPOAuthClient = `-- name: UpsertExternalMCPOAuthClient :one

INSERT INTO external_mcp_oauth_clients (
    project_id,
    external_mcp_attachment_id,
    client_id_encrypted,
    client_secret_encrypted,
    client_id_expires_at,
    registration_access_token_encrypted,
    registration_client_uri
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
) ON CONFLICT (external_mcp_attachment_id) DO UPDATE SET
    client_id_encrypted = EXCLUDED.client_id_encrypted,
    client_secret_encrypted = EXCLUDED.client_secret_encrypted,
    client_id_expires_at = EXCLUDED.client_id_expires_at,
    registration_access_token_encrypted = EXCLUDED.registration_access_token_encrypted,
    registration_client_uri = EXCLUDED.registration_client_uri,
    updated_at = clock_timestamp()
RETURNING id, project_id, external_mcp_attachment_id, client_id_encrypted, client_secret_encrypted, client_id_expires_at, registration_access_token_encrypted, registration_client_uri, created_at, updated_at
`

type UpsertExternalMCPOAuthClientParams struct {
	ProjectID                        uuid.UUID
	ExternalMcpAttachmentID          uuid.UUID
	ClientIDEncrypted                []byte
	ClientSecretEncrypted            []byte
	ClientIDExpiresAt                pgtype.Timestamptz
	RegistrationAccessTokenEncrypted []byte
	RegistrationClientUri            pgtype.Text
}

// External MCP OAuth Clients Queries (for dynamic client registration)
func (q *Queries) UpsertExternalMCPOAuthClient(ctx context.Context, arg UpsertExternalMCPOAuthClientParams) (ExternalMcpOauthClient, error) {
	row := q.db.QueryRow(ctx, upsertExternalMCPOAuthClient,
		arg.ProjectID,
		arg.ExternalMcpAttachmentID,
		arg.ClientIDEncrypted,
		arg.ClientSecretEncrypted,
		arg.ClientIDExpiresAt,
		arg.RegistrationAccessTokenEncrypted,
		arg.RegistrationClientUri,
	)
	var i ExternalMcpOauthClient
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ExternalMcpAttachmentID,
		&i.ClientIDEncrypted,
		&i.ClientSecretEncrypted,
		&i.ClientIDExpiresAt,
		&i.RegistrationAccessTokenEncrypted,
		&i.RegistrationClientUri,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertOAuthProxyProvider = `-- name: UpsertOAuthProxyProvider :one

INSERT INTO oauth_proxy_providers (
    project_id,
    oauth_proxy_server_id,
    slug,
    provider_type,
    authorization_endpoint,
    token_endpoint,
    registration_endpoint,
    scopes_supported,
    response_types_supported,
    response_modes_supported,
    grant_types_supported,
    token_endpoint_auth_methods_supported,
    security_key_names,
    secrets
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
) ON CONFLICT (project_id, slug) WHERE deleted IS FALSE DO UPDATE SET
    oauth_proxy_server_id = EXCLUDED.oauth_proxy_server_id,
    provider_type = EXCLUDED.provider_type,
    authorization_endpoint = EXCLUDED.authorization_endpoint,
    token_endpoint = EXCLUDED.token_endpoint,
    registration_endpoint = EXCLUDED.registration_endpoint,
    scopes_supported = EXCLUDED.scopes_supported,
    response_types_supported = EXCLUDED.response_types_supported,
    response_modes_supported = EXCLUDED.response_modes_supported,
    grant_types_supported = EXCLUDED.grant_types_supported,
    token_endpoint_auth_methods_supported = EXCLUDED.token_endpoint_auth_methods_supported,
    security_key_names = EXCLUDED.security_key_names,
    secrets = EXCLUDED.secrets,
    updated_at = clock_timestamp()
RETURNING id, project_id, oauth_proxy_server_id, slug, provider_type, authorization_endpoint, token_endpoint, registration_endpoint, scopes_supported, response_types_supported, response_modes_supported, grant_types_supported, token_endpoint_auth_methods_supported, security_key_names, secrets, created_at, updated_at, deleted_at, deleted
`

type UpsertOAuthProxyProviderParams struct {
	ProjectID                         uuid.UUID
	OauthProxyServerID                uuid.UUID
	Slug                              string
	ProviderType                      string
	AuthorizationEndpoint             pgtype.Text
	TokenEndpoint                     pgtype.Text
	RegistrationEndpoint              pgtype.Text
	ScopesSupported                   []string
	ResponseTypesSupported            []string
	ResponseModesSupported            []string
	GrantTypesSupported               []string
	TokenEndpointAuthMethodsSupported []string
	SecurityKeyNames                  []string
	Secrets                           []byte
}

// OAuth Proxy Providers Queries
func (q *Queries) UpsertOAuthProxyProvider(ctx context.Context, arg UpsertOAuthProxyProviderParams) (OauthProxyProvider, error) {
	row := q.db.QueryRow(ctx, upsertOAuthProxyProvider,
		arg.ProjectID,
		arg.OauthProxyServerID,
		arg.Slug,
		arg.ProviderType,
		arg.AuthorizationEndpoint,
		arg.TokenEndpoint,
		arg.RegistrationEndpoint,
		arg.ScopesSupported,
		arg.ResponseTypesSupported,
		arg.ResponseModesSupported,
		arg.GrantTypesSupported,
		arg.TokenEndpointAuthMethodsSupported,
		arg.SecurityKeyNames,
		arg.Secrets,
	)
	var i OauthProxyProvider
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.OauthProxyServerID,
		&i.Slug,
		&i.ProviderType,
		&i.AuthorizationEndpoint,
		&i.TokenEndpoint,
		&i.RegistrationEndpoint,
		&i.ScopesSupported,
		&i.ResponseTypesSupported,
		&i.ResponseModesSupported,
		&i.GrantTypesSupported,
		&i.TokenEndpointAuthMethodsSupported,
		&i.SecurityKeyNames,
		&i.Secrets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertOAuthProxyServer = `-- name: UpsertOAuthProxyServer :one

INSERT INTO oauth_proxy_servers (
    project_id,
    slug
) VALUES (
    $1,
    $2
) ON CONFLICT (project_id, slug) WHERE deleted IS FALSE DO UPDATE SET
    updated_at = clock_timestamp()
RETURNING id, project_id, slug, created_at, updated_at, deleted_at, deleted
`

type UpsertOAuthProxyServerParams struct {
	ProjectID uuid.UUID
	Slug      string
}

// OAuth Proxy Servers Queries
func (q *Queries) UpsertOAuthProxyServer(ctx context.Context, arg UpsertOAuthProxyServerParams) (OauthProxyServer, error) {
	row := q.db.QueryRow(ctx, upsertOAuthProxyServer, arg.ProjectID, arg.Slug)
	var i OauthProxyServer
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
