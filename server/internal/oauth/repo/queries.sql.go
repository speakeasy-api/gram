// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createExternalOAuthServerMetadata = `-- name: CreateExternalOAuthServerMetadata :one

INSERT INTO external_oauth_server_metadata (
    project_id,
    slug,
    metadata
) VALUES (
    $1,
    $2,
    $3
) RETURNING id, project_id, slug, metadata, created_at, updated_at, deleted_at, deleted
`

type CreateExternalOAuthServerMetadataParams struct {
	ProjectID uuid.UUID
	Slug      string
	Metadata  []byte
}

// External OAuth Server Metadata Queries
func (q *Queries) CreateExternalOAuthServerMetadata(ctx context.Context, arg CreateExternalOAuthServerMetadataParams) (ExternalOauthServerMetadatum, error) {
	row := q.db.QueryRow(ctx, createExternalOAuthServerMetadata, arg.ProjectID, arg.Slug, arg.Metadata)
	var i ExternalOauthServerMetadatum
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteExternalOAuthClientRegistration = `-- name: DeleteExternalOAuthClientRegistration :exec
UPDATE external_oauth_client_registrations SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE organization_id = $1
  AND oauth_server_issuer = $2
`

type DeleteExternalOAuthClientRegistrationParams struct {
	OrganizationID    string
	OauthServerIssuer string
}

func (q *Queries) DeleteExternalOAuthClientRegistration(ctx context.Context, arg DeleteExternalOAuthClientRegistrationParams) error {
	_, err := q.db.Exec(ctx, deleteExternalOAuthClientRegistration, arg.OrganizationID, arg.OauthServerIssuer)
	return err
}

const deleteExternalOAuthServerMetadata = `-- name: DeleteExternalOAuthServerMetadata :exec
UPDATE external_oauth_server_metadata SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE project_id = $1 AND id = $2
`

type DeleteExternalOAuthServerMetadataParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteExternalOAuthServerMetadata(ctx context.Context, arg DeleteExternalOAuthServerMetadataParams) error {
	_, err := q.db.Exec(ctx, deleteExternalOAuthServerMetadata, arg.ProjectID, arg.ID)
	return err
}

const deleteOAuthProxyProvider = `-- name: DeleteOAuthProxyProvider :exec
UPDATE oauth_proxy_providers SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE project_id = $1 AND id = $2
`

type DeleteOAuthProxyProviderParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteOAuthProxyProvider(ctx context.Context, arg DeleteOAuthProxyProviderParams) error {
	_, err := q.db.Exec(ctx, deleteOAuthProxyProvider, arg.ProjectID, arg.ID)
	return err
}

const deleteOAuthProxyServer = `-- name: DeleteOAuthProxyServer :exec
UPDATE oauth_proxy_servers SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE project_id = $1 AND id = $2
`

type DeleteOAuthProxyServerParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteOAuthProxyServer(ctx context.Context, arg DeleteOAuthProxyServerParams) error {
	_, err := q.db.Exec(ctx, deleteOAuthProxyServer, arg.ProjectID, arg.ID)
	return err
}

const deleteUserOAuthToken = `-- name: DeleteUserOAuthToken :exec
UPDATE user_oauth_tokens SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE id = $1
`

func (q *Queries) DeleteUserOAuthToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserOAuthToken, id)
	return err
}

const deleteUserOAuthTokenByIssuer = `-- name: DeleteUserOAuthTokenByIssuer :exec
UPDATE user_oauth_tokens SET
    deleted_at = clock_timestamp(),
    updated_at = clock_timestamp()
WHERE user_id = $1
  AND organization_id = $2
  AND oauth_server_issuer = $3
`

type DeleteUserOAuthTokenByIssuerParams struct {
	UserID            string
	OrganizationID    string
	OauthServerIssuer string
}

func (q *Queries) DeleteUserOAuthTokenByIssuer(ctx context.Context, arg DeleteUserOAuthTokenByIssuerParams) error {
	_, err := q.db.Exec(ctx, deleteUserOAuthTokenByIssuer, arg.UserID, arg.OrganizationID, arg.OauthServerIssuer)
	return err
}

const getExternalOAuthClientRegistration = `-- name: GetExternalOAuthClientRegistration :one
SELECT id, organization_id, oauth_server_issuer, client_id, client_secret_encrypted, client_id_issued_at, client_secret_expires_at, created_at, updated_at, deleted_at, deleted FROM external_oauth_client_registrations
WHERE organization_id = $1
  AND oauth_server_issuer = $2
  AND deleted IS FALSE
`

type GetExternalOAuthClientRegistrationParams struct {
	OrganizationID    string
	OauthServerIssuer string
}

func (q *Queries) GetExternalOAuthClientRegistration(ctx context.Context, arg GetExternalOAuthClientRegistrationParams) (ExternalOauthClientRegistration, error) {
	row := q.db.QueryRow(ctx, getExternalOAuthClientRegistration, arg.OrganizationID, arg.OauthServerIssuer)
	var i ExternalOauthClientRegistration
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.OauthServerIssuer,
		&i.ClientID,
		&i.ClientSecretEncrypted,
		&i.ClientIDIssuedAt,
		&i.ClientSecretExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getExternalOAuthServerMetadata = `-- name: GetExternalOAuthServerMetadata :one
SELECT id, project_id, slug, metadata, created_at, updated_at, deleted_at, deleted FROM external_oauth_server_metadata
WHERE project_id = $1 AND id = $2 AND deleted IS FALSE
`

type GetExternalOAuthServerMetadataParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) GetExternalOAuthServerMetadata(ctx context.Context, arg GetExternalOAuthServerMetadataParams) (ExternalOauthServerMetadatum, error) {
	row := q.db.QueryRow(ctx, getExternalOAuthServerMetadata, arg.ProjectID, arg.ID)
	var i ExternalOauthServerMetadatum
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getOAuthProxyServer = `-- name: GetOAuthProxyServer :one
SELECT id, project_id, slug, created_at, updated_at, deleted_at, deleted
FROM oauth_proxy_servers s
WHERE s.project_id = $1 AND s.id = $2 AND s.deleted IS FALSE
`

type GetOAuthProxyServerParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) GetOAuthProxyServer(ctx context.Context, arg GetOAuthProxyServerParams) (OauthProxyServer, error) {
	row := q.db.QueryRow(ctx, getOAuthProxyServer, arg.ProjectID, arg.ID)
	var i OauthProxyServer
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getUserOAuthToken = `-- name: GetUserOAuthToken :one
SELECT id, user_id, organization_id, oauth_server_issuer, access_token_encrypted, refresh_token_encrypted, token_type, expires_at, scope, provider_name, created_at, updated_at, deleted_at, deleted FROM user_oauth_tokens
WHERE user_id = $1
  AND organization_id = $2
  AND oauth_server_issuer = $3
  AND deleted IS FALSE
`

type GetUserOAuthTokenParams struct {
	UserID            string
	OrganizationID    string
	OauthServerIssuer string
}

func (q *Queries) GetUserOAuthToken(ctx context.Context, arg GetUserOAuthTokenParams) (UserOauthToken, error) {
	row := q.db.QueryRow(ctx, getUserOAuthToken, arg.UserID, arg.OrganizationID, arg.OauthServerIssuer)
	var i UserOauthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrganizationID,
		&i.OauthServerIssuer,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scope,
		&i.ProviderName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getUserOAuthTokenByID = `-- name: GetUserOAuthTokenByID :one
SELECT id, user_id, organization_id, oauth_server_issuer, access_token_encrypted, refresh_token_encrypted, token_type, expires_at, scope, provider_name, created_at, updated_at, deleted_at, deleted FROM user_oauth_tokens
WHERE id = $1 AND deleted IS FALSE
`

func (q *Queries) GetUserOAuthTokenByID(ctx context.Context, id uuid.UUID) (UserOauthToken, error) {
	row := q.db.QueryRow(ctx, getUserOAuthTokenByID, id)
	var i UserOauthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrganizationID,
		&i.OauthServerIssuer,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scope,
		&i.ProviderName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listOAuthProxyProvidersByServer = `-- name: ListOAuthProxyProvidersByServer :many
SELECT id, project_id, oauth_proxy_server_id, slug, provider_type, authorization_endpoint, token_endpoint, registration_endpoint, scopes_supported, response_types_supported, response_modes_supported, grant_types_supported, token_endpoint_auth_methods_supported, security_key_names, secrets, created_at, updated_at, deleted_at, deleted FROM oauth_proxy_providers
WHERE oauth_proxy_server_id = $1 AND project_id = $2 AND deleted IS FALSE
ORDER BY created_at ASC
`

type ListOAuthProxyProvidersByServerParams struct {
	OauthProxyServerID uuid.UUID
	ProjectID          uuid.UUID
}

func (q *Queries) ListOAuthProxyProvidersByServer(ctx context.Context, arg ListOAuthProxyProvidersByServerParams) ([]OauthProxyProvider, error) {
	rows, err := q.db.Query(ctx, listOAuthProxyProvidersByServer, arg.OauthProxyServerID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OauthProxyProvider
	for rows.Next() {
		var i OauthProxyProvider
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.OauthProxyServerID,
			&i.Slug,
			&i.ProviderType,
			&i.AuthorizationEndpoint,
			&i.TokenEndpoint,
			&i.RegistrationEndpoint,
			&i.ScopesSupported,
			&i.ResponseTypesSupported,
			&i.ResponseModesSupported,
			&i.GrantTypesSupported,
			&i.TokenEndpointAuthMethodsSupported,
			&i.SecurityKeyNames,
			&i.Secrets,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOAuthTokens = `-- name: ListUserOAuthTokens :many
SELECT id, user_id, organization_id, oauth_server_issuer, access_token_encrypted, refresh_token_encrypted, token_type, expires_at, scope, provider_name, created_at, updated_at, deleted_at, deleted FROM user_oauth_tokens
WHERE user_id = $1
  AND organization_id = $2
  AND deleted IS FALSE
ORDER BY created_at DESC
`

type ListUserOAuthTokensParams struct {
	UserID         string
	OrganizationID string
}

func (q *Queries) ListUserOAuthTokens(ctx context.Context, arg ListUserOAuthTokensParams) ([]UserOauthToken, error) {
	rows, err := q.db.Query(ctx, listUserOAuthTokens, arg.UserID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserOauthToken
	for rows.Next() {
		var i UserOauthToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrganizationID,
			&i.OauthServerIssuer,
			&i.AccessTokenEncrypted,
			&i.RefreshTokenEncrypted,
			&i.TokenType,
			&i.ExpiresAt,
			&i.Scope,
			&i.ProviderName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertExternalOAuthClientRegistration = `-- name: UpsertExternalOAuthClientRegistration :one

INSERT INTO external_oauth_client_registrations (
    organization_id,
    oauth_server_issuer,
    client_id,
    client_secret_encrypted,
    client_id_issued_at,
    client_secret_expires_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) ON CONFLICT (organization_id, oauth_server_issuer) WHERE deleted IS FALSE DO UPDATE SET
    client_id = EXCLUDED.client_id,
    client_secret_encrypted = EXCLUDED.client_secret_encrypted,
    client_id_issued_at = EXCLUDED.client_id_issued_at,
    client_secret_expires_at = EXCLUDED.client_secret_expires_at,
    updated_at = clock_timestamp()
RETURNING id, organization_id, oauth_server_issuer, client_id, client_secret_encrypted, client_id_issued_at, client_secret_expires_at, created_at, updated_at, deleted_at, deleted
`

type UpsertExternalOAuthClientRegistrationParams struct {
	OrganizationID        string
	OauthServerIssuer     string
	ClientID              string
	ClientSecretEncrypted pgtype.Text
	ClientIDIssuedAt      pgtype.Timestamptz
	ClientSecretExpiresAt pgtype.Timestamptz
}

// External OAuth Client Registrations Queries
// Stores client credentials from Dynamic Client Registration (DCR)
// These are organization-level credentials, not user-level
func (q *Queries) UpsertExternalOAuthClientRegistration(ctx context.Context, arg UpsertExternalOAuthClientRegistrationParams) (ExternalOauthClientRegistration, error) {
	row := q.db.QueryRow(ctx, upsertExternalOAuthClientRegistration,
		arg.OrganizationID,
		arg.OauthServerIssuer,
		arg.ClientID,
		arg.ClientSecretEncrypted,
		arg.ClientIDIssuedAt,
		arg.ClientSecretExpiresAt,
	)
	var i ExternalOauthClientRegistration
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.OauthServerIssuer,
		&i.ClientID,
		&i.ClientSecretEncrypted,
		&i.ClientIDIssuedAt,
		&i.ClientSecretExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertOAuthProxyProvider = `-- name: UpsertOAuthProxyProvider :one

INSERT INTO oauth_proxy_providers (
    project_id,
    oauth_proxy_server_id,
    slug,
    provider_type,
    authorization_endpoint,
    token_endpoint,
    registration_endpoint,
    scopes_supported,
    response_types_supported,
    response_modes_supported,
    grant_types_supported,
    token_endpoint_auth_methods_supported,
    security_key_names,
    secrets
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
) ON CONFLICT (project_id, slug) WHERE deleted IS FALSE DO UPDATE SET
    oauth_proxy_server_id = EXCLUDED.oauth_proxy_server_id,
    provider_type = EXCLUDED.provider_type,
    authorization_endpoint = EXCLUDED.authorization_endpoint,
    token_endpoint = EXCLUDED.token_endpoint,
    registration_endpoint = EXCLUDED.registration_endpoint,
    scopes_supported = EXCLUDED.scopes_supported,
    response_types_supported = EXCLUDED.response_types_supported,
    response_modes_supported = EXCLUDED.response_modes_supported,
    grant_types_supported = EXCLUDED.grant_types_supported,
    token_endpoint_auth_methods_supported = EXCLUDED.token_endpoint_auth_methods_supported,
    security_key_names = EXCLUDED.security_key_names,
    secrets = EXCLUDED.secrets,
    updated_at = clock_timestamp()
RETURNING id, project_id, oauth_proxy_server_id, slug, provider_type, authorization_endpoint, token_endpoint, registration_endpoint, scopes_supported, response_types_supported, response_modes_supported, grant_types_supported, token_endpoint_auth_methods_supported, security_key_names, secrets, created_at, updated_at, deleted_at, deleted
`

type UpsertOAuthProxyProviderParams struct {
	ProjectID                         uuid.UUID
	OauthProxyServerID                uuid.UUID
	Slug                              string
	ProviderType                      string
	AuthorizationEndpoint             pgtype.Text
	TokenEndpoint                     pgtype.Text
	RegistrationEndpoint              pgtype.Text
	ScopesSupported                   []string
	ResponseTypesSupported            []string
	ResponseModesSupported            []string
	GrantTypesSupported               []string
	TokenEndpointAuthMethodsSupported []string
	SecurityKeyNames                  []string
	Secrets                           []byte
}

// OAuth Proxy Providers Queries
func (q *Queries) UpsertOAuthProxyProvider(ctx context.Context, arg UpsertOAuthProxyProviderParams) (OauthProxyProvider, error) {
	row := q.db.QueryRow(ctx, upsertOAuthProxyProvider,
		arg.ProjectID,
		arg.OauthProxyServerID,
		arg.Slug,
		arg.ProviderType,
		arg.AuthorizationEndpoint,
		arg.TokenEndpoint,
		arg.RegistrationEndpoint,
		arg.ScopesSupported,
		arg.ResponseTypesSupported,
		arg.ResponseModesSupported,
		arg.GrantTypesSupported,
		arg.TokenEndpointAuthMethodsSupported,
		arg.SecurityKeyNames,
		arg.Secrets,
	)
	var i OauthProxyProvider
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.OauthProxyServerID,
		&i.Slug,
		&i.ProviderType,
		&i.AuthorizationEndpoint,
		&i.TokenEndpoint,
		&i.RegistrationEndpoint,
		&i.ScopesSupported,
		&i.ResponseTypesSupported,
		&i.ResponseModesSupported,
		&i.GrantTypesSupported,
		&i.TokenEndpointAuthMethodsSupported,
		&i.SecurityKeyNames,
		&i.Secrets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertOAuthProxyServer = `-- name: UpsertOAuthProxyServer :one

INSERT INTO oauth_proxy_servers (
    project_id,
    slug
) VALUES (
    $1,
    $2
) ON CONFLICT (project_id, slug) WHERE deleted IS FALSE DO UPDATE SET
    updated_at = clock_timestamp()
RETURNING id, project_id, slug, created_at, updated_at, deleted_at, deleted
`

type UpsertOAuthProxyServerParams struct {
	ProjectID uuid.UUID
	Slug      string
}

// OAuth Proxy Servers Queries
func (q *Queries) UpsertOAuthProxyServer(ctx context.Context, arg UpsertOAuthProxyServerParams) (OauthProxyServer, error) {
	row := q.db.QueryRow(ctx, upsertOAuthProxyServer, arg.ProjectID, arg.Slug)
	var i OauthProxyServer
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertUserOAuthToken = `-- name: UpsertUserOAuthToken :one

INSERT INTO user_oauth_tokens (
    user_id,
    organization_id,
    oauth_server_issuer,
    access_token_encrypted,
    refresh_token_encrypted,
    token_type,
    expires_at,
    scope,
    provider_name
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
) ON CONFLICT (user_id, organization_id, oauth_server_issuer) WHERE deleted IS FALSE DO UPDATE SET
    access_token_encrypted = EXCLUDED.access_token_encrypted,
    refresh_token_encrypted = EXCLUDED.refresh_token_encrypted,
    token_type = EXCLUDED.token_type,
    expires_at = EXCLUDED.expires_at,
    scope = EXCLUDED.scope,
    provider_name = EXCLUDED.provider_name,
    updated_at = clock_timestamp()
RETURNING id, user_id, organization_id, oauth_server_issuer, access_token_encrypted, refresh_token_encrypted, token_type, expires_at, scope, provider_name, created_at, updated_at, deleted_at, deleted
`

type UpsertUserOAuthTokenParams struct {
	UserID                string
	OrganizationID        string
	OauthServerIssuer     string
	AccessTokenEncrypted  string
	RefreshTokenEncrypted pgtype.Text
	TokenType             string
	ExpiresAt             pgtype.Timestamptz
	Scope                 pgtype.Text
	ProviderName          pgtype.Text
}

// User OAuth Tokens Queries
// Stores tokens obtained from external OAuth providers for users authenticating to external MCP servers
func (q *Queries) UpsertUserOAuthToken(ctx context.Context, arg UpsertUserOAuthTokenParams) (UserOauthToken, error) {
	row := q.db.QueryRow(ctx, upsertUserOAuthToken,
		arg.UserID,
		arg.OrganizationID,
		arg.OauthServerIssuer,
		arg.AccessTokenEncrypted,
		arg.RefreshTokenEncrypted,
		arg.TokenType,
		arg.ExpiresAt,
		arg.Scope,
		arg.ProviderName,
	)
	var i UserOauthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrganizationID,
		&i.OauthServerIssuer,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scope,
		&i.ProviderName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
