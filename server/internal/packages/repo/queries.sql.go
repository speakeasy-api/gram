// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPackage = `-- name: CreatePackage :one
INSERT INTO packages (
    name
  , title
  , summary
  , url
  , description_raw
  , description_html
  , keywords
  , organization_id
  , project_id
  , image_asset_id
)
VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9, $10
)
RETURNING id
`

type CreatePackageParams struct {
	Name            string
	Title           pgtype.Text
	Summary         pgtype.Text
	Url             pgtype.Text
	DescriptionRaw  pgtype.Text
	DescriptionHtml pgtype.Text
	Keywords        []string
	OrganizationID  string
	ProjectID       uuid.UUID
	ImageAssetID    uuid.NullUUID
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createPackage,
		arg.Name,
		arg.Title,
		arg.Summary,
		arg.Url,
		arg.DescriptionRaw,
		arg.DescriptionHtml,
		arg.Keywords,
		arg.OrganizationID,
		arg.ProjectID,
		arg.ImageAssetID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPackageVersion = `-- name: CreatePackageVersion :one
INSERT INTO package_versions (
    package_id
  , deployment_id
  , major
  , minor
  , patch
  , prerelease
  , build
  , visibility
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, package_id, deployment_id, visibility, major, minor, patch, prerelease, build, created_at, updated_at, deleted_at, deleted
`

type CreatePackageVersionParams struct {
	PackageID    uuid.UUID
	DeploymentID uuid.UUID
	Major        int64
	Minor        int64
	Patch        int64
	Prerelease   pgtype.Text
	Build        pgtype.Text
	Visibility   string
}

func (q *Queries) CreatePackageVersion(ctx context.Context, arg CreatePackageVersionParams) (PackageVersion, error) {
	row := q.db.QueryRow(ctx, createPackageVersion,
		arg.PackageID,
		arg.DeploymentID,
		arg.Major,
		arg.Minor,
		arg.Patch,
		arg.Prerelease,
		arg.Build,
		arg.Visibility,
	)
	var i PackageVersion
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.DeploymentID,
		&i.Visibility,
		&i.Major,
		&i.Minor,
		&i.Patch,
		&i.Prerelease,
		&i.Build,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getPackageWithLatestVersion = `-- name: GetPackageWithLatestVersion :one
WITH package_id_lookup as (
  SELECT id
  FROM packages
  WHERE (
      ($2::UUID IS NOT NULL AND packages.id = $2::UUID)
      OR ($3::TEXT IS NOT NULL AND packages.name = $3::TEXT)
    )
    AND packages.project_id = $1
  LIMIT 1
),
latest_version as (
  SELECT
    id,
    package_id,
    deployment_id,
    major,
    minor,
    patch,
    prerelease,
    build,
    created_at
  FROM package_versions
  WHERE package_versions.package_id = (SELECT id FROM package_id_lookup)
    AND package_versions.visibility = 'public'
    AND package_versions.prerelease IS NULL
  ORDER BY major DESC, minor DESC, patch DESC
  LIMIT 1
)
SELECT
    packages.id, packages.name, packages.title, packages.summary, packages.description_raw, packages.description_html, packages.url, packages.keywords, packages.image_asset_id, packages.organization_id, packages.project_id, packages.created_at, packages.updated_at, packages.deleted_at, packages.deleted
  , latest_version.id as version_id
  , latest_version.deployment_id as version_deployment_id
  , latest_version.major as version_major
  , latest_version.minor as version_minor
  , latest_version.patch as version_patch
  , latest_version.prerelease as version_prerelease
  , latest_version.build as version_build
  , latest_version.created_at as version_created_at
FROM packages
LEFT JOIN latest_version ON packages.id = latest_version.package_id
WHERE packages.id = (SELECT id FROM package_id_lookup) AND packages.project_id = $1
`

type GetPackageWithLatestVersionParams struct {
	ProjectID   uuid.UUID
	PackageID   uuid.NullUUID
	PackageName pgtype.Text
}

type GetPackageWithLatestVersionRow struct {
	Package             Package
	VersionID           uuid.NullUUID
	VersionDeploymentID uuid.NullUUID
	VersionMajor        pgtype.Int8
	VersionMinor        pgtype.Int8
	VersionPatch        pgtype.Int8
	VersionPrerelease   pgtype.Text
	VersionBuild        pgtype.Text
	VersionCreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetPackageWithLatestVersion(ctx context.Context, arg GetPackageWithLatestVersionParams) (GetPackageWithLatestVersionRow, error) {
	row := q.db.QueryRow(ctx, getPackageWithLatestVersion, arg.ProjectID, arg.PackageID, arg.PackageName)
	var i GetPackageWithLatestVersionRow
	err := row.Scan(
		&i.Package.ID,
		&i.Package.Name,
		&i.Package.Title,
		&i.Package.Summary,
		&i.Package.DescriptionRaw,
		&i.Package.DescriptionHtml,
		&i.Package.Url,
		&i.Package.Keywords,
		&i.Package.ImageAssetID,
		&i.Package.OrganizationID,
		&i.Package.ProjectID,
		&i.Package.CreatedAt,
		&i.Package.UpdatedAt,
		&i.Package.DeletedAt,
		&i.Package.Deleted,
		&i.VersionID,
		&i.VersionDeploymentID,
		&i.VersionMajor,
		&i.VersionMinor,
		&i.VersionPatch,
		&i.VersionPrerelease,
		&i.VersionBuild,
		&i.VersionCreatedAt,
	)
	return i, err
}

const listPackages = `-- name: ListPackages :many
WITH latest_versions as (
  SELECT DISTINCT ON (package_versions.package_id)
    package_versions.id,
    package_versions.package_id,
    package_versions.deployment_id,
    package_versions.major,
    package_versions.minor,
    package_versions.patch,
    package_versions.prerelease,
    package_versions.build,
    package_versions.created_at
  FROM package_versions
  WHERE package_versions.visibility = 'public'
    AND package_versions.prerelease IS NULL
  ORDER BY package_versions.package_id, major DESC, minor DESC, patch DESC
)
SELECT
    packages.id, packages.name, packages.title, packages.summary, packages.description_raw, packages.description_html, packages.url, packages.keywords, packages.image_asset_id, packages.organization_id, packages.project_id, packages.created_at, packages.updated_at, packages.deleted_at, packages.deleted
  , latest_versions.id as version_id
  , latest_versions.deployment_id as version_deployment_id
  , latest_versions.major as version_major
  , latest_versions.minor as version_minor
  , latest_versions.patch as version_patch
  , latest_versions.prerelease as version_prerelease
  , latest_versions.build as version_build
  , latest_versions.created_at as version_created_at
FROM packages
LEFT JOIN latest_versions ON packages.id = latest_versions.package_id
WHERE packages.project_id = $1
`

type ListPackagesRow struct {
	Package             Package
	VersionID           uuid.NullUUID
	VersionDeploymentID uuid.NullUUID
	VersionMajor        pgtype.Int8
	VersionMinor        pgtype.Int8
	VersionPatch        pgtype.Int8
	VersionPrerelease   pgtype.Text
	VersionBuild        pgtype.Text
	VersionCreatedAt    pgtype.Timestamptz
}

func (q *Queries) ListPackages(ctx context.Context, projectID uuid.UUID) ([]ListPackagesRow, error) {
	rows, err := q.db.Query(ctx, listPackages, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPackagesRow
	for rows.Next() {
		var i ListPackagesRow
		if err := rows.Scan(
			&i.Package.ID,
			&i.Package.Name,
			&i.Package.Title,
			&i.Package.Summary,
			&i.Package.DescriptionRaw,
			&i.Package.DescriptionHtml,
			&i.Package.Url,
			&i.Package.Keywords,
			&i.Package.ImageAssetID,
			&i.Package.OrganizationID,
			&i.Package.ProjectID,
			&i.Package.CreatedAt,
			&i.Package.UpdatedAt,
			&i.Package.DeletedAt,
			&i.Package.Deleted,
			&i.VersionID,
			&i.VersionDeploymentID,
			&i.VersionMajor,
			&i.VersionMinor,
			&i.VersionPatch,
			&i.VersionPrerelease,
			&i.VersionBuild,
			&i.VersionCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackagesByVersionIDs = `-- name: ListPackagesByVersionIDs :many
SELECT packages.id as package_id, packages.name as package_name, package_versions.id, package_versions.package_id, package_versions.deployment_id, package_versions.visibility, package_versions.major, package_versions.minor, package_versions.patch, package_versions.prerelease, package_versions.build, package_versions.created_at, package_versions.updated_at, package_versions.deleted_at, package_versions.deleted
FROM package_versions
INNER JOIN packages ON package_versions.package_id = packages.id
WHERE package_versions.id = ANY($1::uuid[])
`

type ListPackagesByVersionIDsRow struct {
	PackageID      uuid.UUID
	PackageName    string
	PackageVersion PackageVersion
}

func (q *Queries) ListPackagesByVersionIDs(ctx context.Context, ids []uuid.UUID) ([]ListPackagesByVersionIDsRow, error) {
	rows, err := q.db.Query(ctx, listPackagesByVersionIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPackagesByVersionIDsRow
	for rows.Next() {
		var i ListPackagesByVersionIDsRow
		if err := rows.Scan(
			&i.PackageID,
			&i.PackageName,
			&i.PackageVersion.ID,
			&i.PackageVersion.PackageID,
			&i.PackageVersion.DeploymentID,
			&i.PackageVersion.Visibility,
			&i.PackageVersion.Major,
			&i.PackageVersion.Minor,
			&i.PackageVersion.Patch,
			&i.PackageVersion.Prerelease,
			&i.PackageVersion.Build,
			&i.PackageVersion.CreatedAt,
			&i.PackageVersion.UpdatedAt,
			&i.PackageVersion.DeletedAt,
			&i.PackageVersion.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVersions = `-- name: ListVersions :many
WITH package_id_lookup as (
  SELECT id
  FROM packages
  WHERE (
      ($2::UUID IS NOT NULL AND packages.id = $2::UUID)
      OR ($3::TEXT IS NOT NULL AND packages.name = $3::TEXT)
    )
    AND packages.project_id = $1
  LIMIT 1
)
SELECT 
    packages.id, packages.name, packages.title, packages.summary, packages.description_raw, packages.description_html, packages.url, packages.keywords, packages.image_asset_id, packages.organization_id, packages.project_id, packages.created_at, packages.updated_at, packages.deleted_at, packages.deleted
  , pv.id as version_id
  , pv.deployment_id as version_deployment_id
  , pv.major as version_major
  , pv.minor as version_minor
  , pv.patch as version_patch
  , pv.prerelease as version_prerelease
  , pv.build as version_build
  , pv.visibility as version_visibility
  , pv.created_at as version_created_at
FROM package_versions as pv
INNER JOIN packages ON pv.package_id = packages.id
WHERE packages.id = (SELECT id FROM package_id_lookup) AND packages.project_id = $1
`

type ListVersionsParams struct {
	ProjectID   uuid.UUID
	PackageID   uuid.NullUUID
	PackageName pgtype.Text
}

type ListVersionsRow struct {
	Package             Package
	VersionID           uuid.UUID
	VersionDeploymentID uuid.UUID
	VersionMajor        int64
	VersionMinor        int64
	VersionPatch        int64
	VersionPrerelease   pgtype.Text
	VersionBuild        pgtype.Text
	VersionVisibility   string
	VersionCreatedAt    pgtype.Timestamptz
}

func (q *Queries) ListVersions(ctx context.Context, arg ListVersionsParams) ([]ListVersionsRow, error) {
	rows, err := q.db.Query(ctx, listVersions, arg.ProjectID, arg.PackageID, arg.PackageName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVersionsRow
	for rows.Next() {
		var i ListVersionsRow
		if err := rows.Scan(
			&i.Package.ID,
			&i.Package.Name,
			&i.Package.Title,
			&i.Package.Summary,
			&i.Package.DescriptionRaw,
			&i.Package.DescriptionHtml,
			&i.Package.Url,
			&i.Package.Keywords,
			&i.Package.ImageAssetID,
			&i.Package.OrganizationID,
			&i.Package.ProjectID,
			&i.Package.CreatedAt,
			&i.Package.UpdatedAt,
			&i.Package.DeletedAt,
			&i.Package.Deleted,
			&i.VersionID,
			&i.VersionDeploymentID,
			&i.VersionMajor,
			&i.VersionMinor,
			&i.VersionPatch,
			&i.VersionPrerelease,
			&i.VersionBuild,
			&i.VersionVisibility,
			&i.VersionCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const peekLatestPackageVersionByName = `-- name: PeekLatestPackageVersionByName :one
SELECT packages.id as package_id, packages.project_id as project_id, package_versions.id as package_version_id
FROM packages
INNER JOIN package_versions ON packages.id = package_versions.package_id
WHERE packages.name = $1
ORDER BY package_versions.major DESC, package_versions.minor DESC, package_versions.patch DESC, package_versions.id DESC
LIMIT 1
`

type PeekLatestPackageVersionByNameRow struct {
	PackageID        uuid.UUID
	ProjectID        uuid.UUID
	PackageVersionID uuid.UUID
}

func (q *Queries) PeekLatestPackageVersionByName(ctx context.Context, name string) (PeekLatestPackageVersionByNameRow, error) {
	row := q.db.QueryRow(ctx, peekLatestPackageVersionByName, name)
	var i PeekLatestPackageVersionByNameRow
	err := row.Scan(&i.PackageID, &i.ProjectID, &i.PackageVersionID)
	return i, err
}

const peekPackageByNameAndVersion = `-- name: PeekPackageByNameAndVersion :one
SELECT packages.id as package_id, packages.project_id as project_id, package_versions.id as package_version_id
FROM packages
INNER JOIN package_versions ON packages.id = package_versions.package_id
WHERE packages.name = $1
  AND package_versions.major = $2
  AND package_versions.minor = $3
  AND package_versions.patch = $4
  AND package_versions.prerelease IS NOT DISTINCT FROM $5
  AND package_versions.build IS NOT DISTINCT FROM $6
LIMIT 1
`

type PeekPackageByNameAndVersionParams struct {
	Name       string
	Major      int64
	Minor      int64
	Patch      int64
	Prerelease pgtype.Text
	Build      pgtype.Text
}

type PeekPackageByNameAndVersionRow struct {
	PackageID        uuid.UUID
	ProjectID        uuid.UUID
	PackageVersionID uuid.UUID
}

func (q *Queries) PeekPackageByNameAndVersion(ctx context.Context, arg PeekPackageByNameAndVersionParams) (PeekPackageByNameAndVersionRow, error) {
	row := q.db.QueryRow(ctx, peekPackageByNameAndVersion,
		arg.Name,
		arg.Major,
		arg.Minor,
		arg.Patch,
		arg.Prerelease,
		arg.Build,
	)
	var i PeekPackageByNameAndVersionRow
	err := row.Scan(&i.PackageID, &i.ProjectID, &i.PackageVersionID)
	return i, err
}

const pokePackageByName = `-- name: PokePackageByName :one
SELECT id 
FROM packages
WHERE name = $1
  AND project_id = $2
LIMIT 1
`

type PokePackageByNameParams struct {
	Name      string
	ProjectID uuid.UUID
}

func (q *Queries) PokePackageByName(ctx context.Context, arg PokePackageByNameParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, pokePackageByName, arg.Name, arg.ProjectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updatePackage = `-- name: UpdatePackage :one
UPDATE packages
SET
    title = coalesce($1, title)
  , summary = coalesce($2, summary)
  , description_raw = coalesce($3, description_raw)
  , description_html = coalesce($4, description_html)
  , keywords = coalesce($5, keywords)
  , url = coalesce($6, url)
  , image_asset_id = coalesce($7, image_asset_id)
  , updated_at = clock_timestamp()
WHERE id = $8 AND project_id = $9
RETURNING id
`

type UpdatePackageParams struct {
	Title           pgtype.Text
	Summary         pgtype.Text
	DescriptionRaw  pgtype.Text
	DescriptionHtml pgtype.Text
	Keywords        []string
	Url             pgtype.Text
	ImageAssetID    uuid.NullUUID
	ID              uuid.UUID
	ProjectID       uuid.UUID
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updatePackage,
		arg.Title,
		arg.Summary,
		arg.DescriptionRaw,
		arg.DescriptionHtml,
		arg.Keywords,
		arg.Url,
		arg.ImageAssetID,
		arg.ID,
		arg.ProjectID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
