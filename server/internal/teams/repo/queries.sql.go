// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptTeamInvite = `-- name: AcceptTeamInvite :exec
UPDATE team_invites
SET status = 'accepted', updated_at = clock_timestamp()
WHERE id = $1 AND deleted IS FALSE
`

func (q *Queries) AcceptTeamInvite(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, acceptTeamInvite, id)
	return err
}

const cancelTeamInvite = `-- name: CancelTeamInvite :exec
UPDATE team_invites
SET status = 'cancelled', deleted_at = clock_timestamp(), updated_at = clock_timestamp()
WHERE id = $1 AND deleted IS FALSE
`

func (q *Queries) CancelTeamInvite(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, cancelTeamInvite, id)
	return err
}

const createTeamInvite = `-- name: CreateTeamInvite :one
INSERT INTO team_invites (organization_id, email, invited_by_user_id, status, token, expires_at)
VALUES ($1, $2, $3, 'pending', $4, $5)
RETURNING id, organization_id, email, invited_by_user_id, status, token, expires_at, created_at, updated_at, deleted_at, deleted
`

type CreateTeamInviteParams struct {
	OrganizationID  string
	Email           string
	InvitedByUserID string
	Token           string
	ExpiresAt       pgtype.Timestamptz
}

func (q *Queries) CreateTeamInvite(ctx context.Context, arg CreateTeamInviteParams) (TeamInvite, error) {
	row := q.db.QueryRow(ctx, createTeamInvite,
		arg.OrganizationID,
		arg.Email,
		arg.InvitedByUserID,
		arg.Token,
		arg.ExpiresAt,
	)
	var i TeamInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.InvitedByUserID,
		&i.Status,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getPendingInviteByEmail = `-- name: GetPendingInviteByEmail :one
SELECT id, organization_id, email, invited_by_user_id, status, token, expires_at, created_at, updated_at, deleted_at, deleted FROM team_invites
WHERE organization_id = $1
  AND email = $2
  AND status = 'pending'
  AND deleted IS FALSE
`

type GetPendingInviteByEmailParams struct {
	OrganizationID string
	Email          string
}

func (q *Queries) GetPendingInviteByEmail(ctx context.Context, arg GetPendingInviteByEmailParams) (TeamInvite, error) {
	row := q.db.QueryRow(ctx, getPendingInviteByEmail, arg.OrganizationID, arg.Email)
	var i TeamInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.InvitedByUserID,
		&i.Status,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getTeamInviteByID = `-- name: GetTeamInviteByID :one
SELECT id, organization_id, email, invited_by_user_id, status, token, expires_at, created_at, updated_at, deleted_at, deleted FROM team_invites
WHERE id = $1 AND deleted IS FALSE
`

func (q *Queries) GetTeamInviteByID(ctx context.Context, id uuid.UUID) (TeamInvite, error) {
	row := q.db.QueryRow(ctx, getTeamInviteByID, id)
	var i TeamInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.InvitedByUserID,
		&i.Status,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getTeamInviteByToken = `-- name: GetTeamInviteByToken :one
SELECT id, organization_id, email, invited_by_user_id, status, token, expires_at, created_at, updated_at, deleted_at, deleted FROM team_invites
WHERE token = $1 AND deleted IS FALSE
`

func (q *Queries) GetTeamInviteByToken(ctx context.Context, token string) (TeamInvite, error) {
	row := q.db.QueryRow(ctx, getTeamInviteByToken, token)
	var i TeamInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.InvitedByUserID,
		&i.Status,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT
  u.id,
  u.email,
  u.display_name,
  u.photo_url,
  our.created_at as joined_at
FROM organization_user_relationships our
JOIN users u ON u.id = our.user_id
WHERE our.organization_id = $1
  AND our.deleted IS FALSE
ORDER BY our.created_at ASC
`

type ListOrganizationMembersRow struct {
	ID          string
	Email       string
	DisplayName string
	PhotoUrl    pgtype.Text
	JoinedAt    pgtype.Timestamptz
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID string) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.Query(ctx, listOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationMembersRow
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.PhotoUrl,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTeamInvites = `-- name: ListPendingTeamInvites :many
SELECT ti.id, ti.organization_id, ti.email, ti.invited_by_user_id, ti.status, ti.token, ti.expires_at, ti.created_at, ti.updated_at, ti.deleted_at, ti.deleted, u.display_name as invited_by_name
FROM team_invites ti
JOIN users u ON u.id = ti.invited_by_user_id
WHERE ti.organization_id = $1
  AND ti.status = 'pending'
  AND ti.deleted IS FALSE
ORDER BY ti.created_at DESC
`

type ListPendingTeamInvitesRow struct {
	ID              uuid.UUID
	OrganizationID  string
	Email           string
	InvitedByUserID string
	Status          string
	Token           string
	ExpiresAt       pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	DeletedAt       pgtype.Timestamptz
	Deleted         bool
	InvitedByName   string
}

func (q *Queries) ListPendingTeamInvites(ctx context.Context, organizationID string) ([]ListPendingTeamInvitesRow, error) {
	rows, err := q.db.Query(ctx, listPendingTeamInvites, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingTeamInvitesRow
	for rows.Next() {
		var i ListPendingTeamInvitesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Email,
			&i.InvitedByUserID,
			&i.Status,
			&i.Token,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.InvitedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOrganizationMember = `-- name: RemoveOrganizationMember :exec
UPDATE organization_user_relationships
SET deleted_at = clock_timestamp(), updated_at = clock_timestamp()
WHERE organization_id = $1
  AND user_id = $2
  AND deleted IS FALSE
`

type RemoveOrganizationMemberParams struct {
	OrganizationID string
	UserID         string
}

func (q *Queries) RemoveOrganizationMember(ctx context.Context, arg RemoveOrganizationMemberParams) error {
	_, err := q.db.Exec(ctx, removeOrganizationMember, arg.OrganizationID, arg.UserID)
	return err
}

const updateTeamInviteExpiry = `-- name: UpdateTeamInviteExpiry :one
UPDATE team_invites
SET expires_at = $1, updated_at = clock_timestamp()
WHERE id = $2 AND deleted IS FALSE
RETURNING id, organization_id, email, invited_by_user_id, status, token, expires_at, created_at, updated_at, deleted_at, deleted
`

type UpdateTeamInviteExpiryParams struct {
	ExpiresAt pgtype.Timestamptz
	ID        uuid.UUID
}

func (q *Queries) UpdateTeamInviteExpiry(ctx context.Context, arg UpdateTeamInviteExpiryParams) (TeamInvite, error) {
	row := q.db.QueryRow(ctx, updateTeamInviteExpiry, arg.ExpiresAt, arg.ID)
	var i TeamInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.InvitedByUserID,
		&i.Status,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
