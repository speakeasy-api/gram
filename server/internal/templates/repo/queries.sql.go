// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/urn"
)

const createTemplate = `-- name: CreateTemplate :one
INSERT INTO prompt_templates (
  project_id,
  history_id,
  tool_urn,
  name,
  prompt,
  description,
  arguments,
  engine,
  kind,
  tools_hint,
  tool_urns_hint
)
SELECT
  $1,
  generate_uuidv7(),
  $2,
  $3,
  $4,
  NULLIF($5, ''),
  $6,
  $7,
  $8,
  $9,
  $10
RETURNING id
`

type CreateTemplateParams struct {
	ProjectID    uuid.UUID
	ToolUrn      urn.Tool
	Name         string
	Prompt       string
	Description  pgtype.Text
	Arguments    []byte
	Engine       pgtype.Text
	Kind         pgtype.Text
	ToolsHint    []string
	ToolUrnsHint []string
}

func (q *Queries) CreateTemplate(ctx context.Context, arg CreateTemplateParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createTemplate,
		arg.ProjectID,
		arg.ToolUrn,
		arg.Name,
		arg.Prompt,
		arg.Description,
		arg.Arguments,
		arg.Engine,
		arg.Kind,
		arg.ToolsHint,
		arg.ToolUrnsHint,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteTemplateByID = `-- name: DeleteTemplateByID :exec
UPDATE prompt_templates
SET deleted_at = clock_timestamp()
WHERE project_id = $1
  AND id = $2
`

type DeleteTemplateByIDParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) DeleteTemplateByID(ctx context.Context, arg DeleteTemplateByIDParams) error {
	_, err := q.db.Exec(ctx, deleteTemplateByID, arg.ProjectID, arg.ID)
	return err
}

const deleteTemplateByName = `-- name: DeleteTemplateByName :exec
UPDATE prompt_templates
SET deleted_at = clock_timestamp()
WHERE project_id = $1
  AND name = $2
`

type DeleteTemplateByNameParams struct {
	ProjectID uuid.UUID
	Name      string
}

func (q *Queries) DeleteTemplateByName(ctx context.Context, arg DeleteTemplateByNameParams) error {
	_, err := q.db.Exec(ctx, deleteTemplateByName, arg.ProjectID, arg.Name)
	return err
}

const findPromptTemplatesByUrns = `-- name: FindPromptTemplatesByUrns :many
SELECT DISTINCT ON (pt.project_id, pt.tool_urn) id, tool_urn, project_id, history_id, predecessor_id, name, description, arguments, prompt, engine, kind, tools_hint, tool_urns_hint, created_at, updated_at, deleted_at, deleted
FROM prompt_templates pt
WHERE pt.project_id = $1
  AND pt.tool_urn = ANY($2::TEXT[])
  AND pt.deleted IS FALSE
ORDER BY pt.project_id, pt.tool_urn, pt.id DESC
`

type FindPromptTemplatesByUrnsParams struct {
	ProjectID uuid.UUID
	Urns      []string
}

func (q *Queries) FindPromptTemplatesByUrns(ctx context.Context, arg FindPromptTemplatesByUrnsParams) ([]PromptTemplate, error) {
	rows, err := q.db.Query(ctx, findPromptTemplatesByUrns, arg.ProjectID, arg.Urns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PromptTemplate
	for rows.Next() {
		var i PromptTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ToolUrn,
			&i.ProjectID,
			&i.HistoryID,
			&i.PredecessorID,
			&i.Name,
			&i.Description,
			&i.Arguments,
			&i.Prompt,
			&i.Engine,
			&i.Kind,
			&i.ToolsHint,
			&i.ToolUrnsHint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplateByID = `-- name: GetTemplateByID :one
SELECT id, tool_urn, project_id, history_id, predecessor_id, name, description, arguments, prompt, engine, kind, tools_hint, tool_urns_hint, created_at, updated_at, deleted_at, deleted
FROM prompt_templates pt
WHERE
  pt.project_id = $1
  AND pt.id = $2
  AND pt.deleted IS FALSE
ORDER BY pt.created_at DESC
LIMIT 1
`

type GetTemplateByIDParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

func (q *Queries) GetTemplateByID(ctx context.Context, arg GetTemplateByIDParams) (PromptTemplate, error) {
	row := q.db.QueryRow(ctx, getTemplateByID, arg.ProjectID, arg.ID)
	var i PromptTemplate
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.HistoryID,
		&i.PredecessorID,
		&i.Name,
		&i.Description,
		&i.Arguments,
		&i.Prompt,
		&i.Engine,
		&i.Kind,
		&i.ToolsHint,
		&i.ToolUrnsHint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getTemplateByName = `-- name: GetTemplateByName :one
SELECT id, tool_urn, project_id, history_id, predecessor_id, name, description, arguments, prompt, engine, kind, tools_hint, tool_urns_hint, created_at, updated_at, deleted_at, deleted
FROM prompt_templates pt
WHERE
  pt.project_id = $1
  AND pt.name = $2
  AND pt.deleted IS FALSE
ORDER BY pt.created_at DESC
LIMIT 1
`

type GetTemplateByNameParams struct {
	ProjectID uuid.UUID
	Name      string
}

func (q *Queries) GetTemplateByName(ctx context.Context, arg GetTemplateByNameParams) (PromptTemplate, error) {
	row := q.db.QueryRow(ctx, getTemplateByName, arg.ProjectID, arg.Name)
	var i PromptTemplate
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.HistoryID,
		&i.PredecessorID,
		&i.Name,
		&i.Description,
		&i.Arguments,
		&i.Prompt,
		&i.Engine,
		&i.Kind,
		&i.ToolsHint,
		&i.ToolUrnsHint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getTemplateByURN = `-- name: GetTemplateByURN :one
SELECT DISTINCT ON (pt.project_id, pt.tool_urn) id, tool_urn, project_id, history_id, predecessor_id, name, description, arguments, prompt, engine, kind, tools_hint, tool_urns_hint, created_at, updated_at, deleted_at, deleted
FROM prompt_templates pt
WHERE pt.project_id = $1
  AND pt.tool_urn = $2::TEXT
  AND pt.deleted IS FALSE
ORDER BY pt.project_id, pt.tool_urn, pt.id DESC
`

type GetTemplateByURNParams struct {
	ProjectID uuid.UUID
	Urn       string
}

func (q *Queries) GetTemplateByURN(ctx context.Context, arg GetTemplateByURNParams) (PromptTemplate, error) {
	row := q.db.QueryRow(ctx, getTemplateByURN, arg.ProjectID, arg.Urn)
	var i PromptTemplate
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.HistoryID,
		&i.PredecessorID,
		&i.Name,
		&i.Description,
		&i.Arguments,
		&i.Prompt,
		&i.Engine,
		&i.Kind,
		&i.ToolsHint,
		&i.ToolUrnsHint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listTemplates = `-- name: ListTemplates :many
SELECT DISTINCT ON (pt.project_id, pt.name) id, tool_urn, project_id, history_id, predecessor_id, name, description, arguments, prompt, engine, kind, tools_hint, tool_urns_hint, created_at, updated_at, deleted_at, deleted
FROM prompt_templates pt
WHERE pt.project_id = $1
  AND pt.deleted IS FALSE
ORDER BY pt.project_id, pt.name, pt.created_at DESC, pt.id DESC
`

func (q *Queries) ListTemplates(ctx context.Context, projectID uuid.UUID) ([]PromptTemplate, error) {
	rows, err := q.db.Query(ctx, listTemplates, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PromptTemplate
	for rows.Next() {
		var i PromptTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ToolUrn,
			&i.ProjectID,
			&i.HistoryID,
			&i.PredecessorID,
			&i.Name,
			&i.Description,
			&i.Arguments,
			&i.Prompt,
			&i.Engine,
			&i.Kind,
			&i.ToolsHint,
			&i.ToolUrnsHint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const peekTemplateByID = `-- name: PeekTemplateByID :one
SELECT id, history_id, name
FROM prompt_templates
WHERE project_id = $1
  AND id = $2
  AND deleted IS FALSE
ORDER BY id DESC
LIMIT 1
`

type PeekTemplateByIDParams struct {
	ProjectID uuid.UUID
	ID        uuid.UUID
}

type PeekTemplateByIDRow struct {
	ID        uuid.UUID
	HistoryID uuid.UUID
	Name      string
}

func (q *Queries) PeekTemplateByID(ctx context.Context, arg PeekTemplateByIDParams) (PeekTemplateByIDRow, error) {
	row := q.db.QueryRow(ctx, peekTemplateByID, arg.ProjectID, arg.ID)
	var i PeekTemplateByIDRow
	err := row.Scan(&i.ID, &i.HistoryID, &i.Name)
	return i, err
}

const peekTemplatesByNames = `-- name: PeekTemplatesByNames :many
SELECT DISTINCT ON (pt.project_id, pt.name) pt.id, pt.history_id, pt.name
FROM prompt_templates pt
WHERE pt.project_id = $1
  AND pt.name = ANY($2::TEXT[])
  AND pt.deleted IS FALSE
ORDER BY pt.project_id, pt.name, pt.id DESC
`

type PeekTemplatesByNamesParams struct {
	ProjectID uuid.UUID
	Names     []string
}

type PeekTemplatesByNamesRow struct {
	ID        uuid.UUID
	HistoryID uuid.UUID
	Name      string
}

func (q *Queries) PeekTemplatesByNames(ctx context.Context, arg PeekTemplatesByNamesParams) ([]PeekTemplatesByNamesRow, error) {
	rows, err := q.db.Query(ctx, peekTemplatesByNames, arg.ProjectID, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PeekTemplatesByNamesRow
	for rows.Next() {
		var i PeekTemplatesByNamesRow
		if err := rows.Scan(&i.ID, &i.HistoryID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const peekTemplatesByUrns = `-- name: PeekTemplatesByUrns :many
SELECT DISTINCT ON (pt.project_id, pt.tool_urn) pt.id, pt.tool_urn, pt.history_id, pt.name
FROM prompt_templates pt
WHERE pt.project_id = $1
  AND pt.tool_urn = ANY($2::TEXT[])
  AND pt.deleted IS FALSE
ORDER BY pt.project_id, pt.tool_urn, pt.id DESC
`

type PeekTemplatesByUrnsParams struct {
	ProjectID uuid.UUID
	Urns      []string
}

type PeekTemplatesByUrnsRow struct {
	ID        uuid.UUID
	ToolUrn   urn.Tool
	HistoryID uuid.UUID
	Name      string
}

func (q *Queries) PeekTemplatesByUrns(ctx context.Context, arg PeekTemplatesByUrnsParams) ([]PeekTemplatesByUrnsRow, error) {
	rows, err := q.db.Query(ctx, peekTemplatesByUrns, arg.ProjectID, arg.Urns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PeekTemplatesByUrnsRow
	for rows.Next() {
		var i PeekTemplatesByUrnsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToolUrn,
			&i.HistoryID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTemplate = `-- name: UpdateTemplate :one
INSERT INTO prompt_templates (
  project_id,
  history_id,
  predecessor_id,
  tool_urn,
  name,
  prompt,
  description,
  arguments,
  engine,
  kind,
  tools_hint,
  tool_urns_hint
)
SELECT
  c.project_id,
  c.history_id,
  c.id,
  COALESCE($1, c.tool_urn),
  c.name,
  COALESCE($2, c.prompt),
  COALESCE(NULLIF($3, ''), c.description),
  $4,
  COALESCE(NULLIF($5, ''), c.engine),
  COALESCE(NULLIF($6, ''), c.kind),
  COALESCE($7, ARRAY[]::TEXT[]),
  COALESCE($8, ARRAY[]::TEXT[])
FROM prompt_templates c
WHERE project_id = $9
  AND id = $10
  AND (
    (NULLIF($2, '') IS NOT NULL AND $2 != c.prompt)
    OR (NULLIF($3, '') IS NOT NULL AND $3 != c.description)
    OR ($4 != c.arguments)
    OR (NULLIF($5, '') IS NOT NULL AND $5 != c.engine)
    OR (NULLIF($6, '') IS NOT NULL AND NULLIF($6, '') != c.kind)
    OR ($7 IS DISTINCT FROM c.tools_hint)
    OR ($8 IS DISTINCT FROM c.tool_urns_hint)
  )
RETURNING id
`

type UpdateTemplateParams struct {
	ToolUrn      pgtype.Text
	Prompt       pgtype.Text
	Description  pgtype.Text
	Arguments    []byte
	Engine       pgtype.Text
	Kind         pgtype.Text
	ToolsHint    []string
	ToolUrnsHint []string
	ProjectID    uuid.NullUUID
	ID           uuid.NullUUID
}

func (q *Queries) UpdateTemplate(ctx context.Context, arg UpdateTemplateParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateTemplate,
		arg.ToolUrn,
		arg.Prompt,
		arg.Description,
		arg.Arguments,
		arg.Engine,
		arg.Kind,
		arg.ToolsHint,
		arg.ToolUrnsHint,
		arg.ProjectID,
		arg.ID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
