// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countChatMessages = `-- name: CountChatMessages :one
SELECT COUNT(*) FROM chat_messages WHERE chat_id = $1
`

func (q *Queries) CountChatMessages(ctx context.Context, chatID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChatMessages, chatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateChatMessageParams struct {
	ChatID           uuid.UUID
	Role             string
	ProjectID        uuid.UUID
	Content          string
	ContentRaw       []byte
	ContentAssetUrl  pgtype.Text
	StorageError     pgtype.Text
	Model            pgtype.Text
	MessageID        pgtype.Text
	ToolCallID       pgtype.Text
	UserID           pgtype.Text
	ExternalUserID   pgtype.Text
	FinishReason     pgtype.Text
	ToolCalls        []byte
	PromptTokens     int64
	CompletionTokens int64
	TotalTokens      int64
	Origin           pgtype.Text
	UserAgent        pgtype.Text
	IpAddress        pgtype.Text
	Source           pgtype.Text
}

const getChat = `-- name: GetChat :one
SELECT id, project_id, organization_id, user_id, external_user_id, title, created_at, updated_at, deleted_at, deleted FROM chats WHERE id = $1
`

func (q *Queries) GetChat(ctx context.Context, id uuid.UUID) (Chat, error) {
	row := q.db.QueryRow(ctx, getChat, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.OrganizationID,
		&i.UserID,
		&i.ExternalUserID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getFirstUserChatMessage = `-- name: GetFirstUserChatMessage :one
SELECT content FROM chat_messages
WHERE chat_id = $1
  AND role = 'user'
  AND content IS NOT NULL
  AND content != ''
ORDER BY created_at ASC
LIMIT 1
`

func (q *Queries) GetFirstUserChatMessage(ctx context.Context, chatID uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getFirstUserChatMessage, chatID)
	var content string
	err := row.Scan(&content)
	return content, err
}

const listAllChats = `-- name: ListAllChats :many
SELECT 
    c.id, c.project_id, c.organization_id, c.user_id, c.external_user_id, c.title, c.created_at, c.updated_at, c.deleted_at, c.deleted,
    (
        COALESCE(
            (SELECT COUNT(*) FROM chat_messages WHERE chat_id = c.id),
            0
        )
    )::integer as num_messages 
    , (
        COALESCE(
            (SELECT SUM(total_tokens) FROM chat_messages WHERE chat_id = c.id),
            0
        )
    )::integer as total_tokens
FROM chats c 
WHERE c.project_id = $1
`

type ListAllChatsRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	OrganizationID string
	UserID         pgtype.Text
	ExternalUserID pgtype.Text
	Title          pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	Deleted        bool
	NumMessages    int32
	TotalTokens    int32
}

func (q *Queries) ListAllChats(ctx context.Context, projectID uuid.UUID) ([]ListAllChatsRow, error) {
	rows, err := q.db.Query(ctx, listAllChats, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllChatsRow
	for rows.Next() {
		var i ListAllChatsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.OrganizationID,
			&i.UserID,
			&i.ExternalUserID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.NumMessages,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatMessages = `-- name: ListChatMessages :many
SELECT id, seq, chat_id, project_id, role, content, content_raw, content_asset_url, model, message_id, finish_reason, tool_calls, prompt_tokens, completion_tokens, total_tokens, storage_error, user_id, external_user_id, origin, user_agent, ip_address, source, tool_call_id, tool_urn, tool_outcome, tool_outcome_notes, created_at FROM chat_messages WHERE chat_id = $1 AND (project_id IS NULL OR project_id = $2::uuid)
`

type ListChatMessagesParams struct {
	ChatID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) ListChatMessages(ctx context.Context, arg ListChatMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessages, arg.ChatID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.Seq,
			&i.ChatID,
			&i.ProjectID,
			&i.Role,
			&i.Content,
			&i.ContentRaw,
			&i.ContentAssetUrl,
			&i.Model,
			&i.MessageID,
			&i.FinishReason,
			&i.ToolCalls,
			&i.PromptTokens,
			&i.CompletionTokens,
			&i.TotalTokens,
			&i.StorageError,
			&i.UserID,
			&i.ExternalUserID,
			&i.Origin,
			&i.UserAgent,
			&i.IpAddress,
			&i.Source,
			&i.ToolCallID,
			&i.ToolUrn,
			&i.ToolOutcome,
			&i.ToolOutcomeNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsForExternalUser = `-- name: ListChatsForExternalUser :many
SELECT 
    c.id, c.project_id, c.organization_id, c.user_id, c.external_user_id, c.title, c.created_at, c.updated_at, c.deleted_at, c.deleted,
    (
        COALESCE(
            (SELECT COUNT(*) FROM chat_messages WHERE chat_id = c.id),
            0
        )
    )::integer as num_messages 
    , (
        COALESCE(
            (SELECT SUM(total_tokens) FROM chat_messages WHERE chat_id = c.id),
            0
        )
    )::integer as total_tokens
FROM chats c 
WHERE c.project_id = $1 AND c.external_user_id = $2
`

type ListChatsForExternalUserParams struct {
	ProjectID      uuid.UUID
	ExternalUserID pgtype.Text
}

type ListChatsForExternalUserRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	OrganizationID string
	UserID         pgtype.Text
	ExternalUserID pgtype.Text
	Title          pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	Deleted        bool
	NumMessages    int32
	TotalTokens    int32
}

func (q *Queries) ListChatsForExternalUser(ctx context.Context, arg ListChatsForExternalUserParams) ([]ListChatsForExternalUserRow, error) {
	rows, err := q.db.Query(ctx, listChatsForExternalUser, arg.ProjectID, arg.ExternalUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChatsForExternalUserRow
	for rows.Next() {
		var i ListChatsForExternalUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.OrganizationID,
			&i.UserID,
			&i.ExternalUserID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.NumMessages,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsForUser = `-- name: ListChatsForUser :many
SELECT 
    c.id, c.project_id, c.organization_id, c.user_id, c.external_user_id, c.title, c.created_at, c.updated_at, c.deleted_at, c.deleted,
    (
        COALESCE(
            (SELECT COUNT(*) FROM chat_messages WHERE chat_id = c.id),
            0
        )
    )::integer as num_messages 
    , (
        COALESCE(
            (SELECT SUM(total_tokens) FROM chat_messages WHERE chat_id = c.id),
            0
        )
    )::integer as total_tokens
FROM chats c 
WHERE c.project_id = $1 AND c.user_id = $2
`

type ListChatsForUserParams struct {
	ProjectID uuid.UUID
	UserID    pgtype.Text
}

type ListChatsForUserRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	OrganizationID string
	UserID         pgtype.Text
	ExternalUserID pgtype.Text
	Title          pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	Deleted        bool
	NumMessages    int32
	TotalTokens    int32
}

func (q *Queries) ListChatsForUser(ctx context.Context, arg ListChatsForUserParams) ([]ListChatsForUserRow, error) {
	rows, err := q.db.Query(ctx, listChatsForUser, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChatsForUserRow
	for rows.Next() {
		var i ListChatsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.OrganizationID,
			&i.UserID,
			&i.ExternalUserID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.NumMessages,
			&i.TotalTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatTitle = `-- name: UpdateChatTitle :exec
UPDATE chats SET title = $1, updated_at = NOW() WHERE id = $2
`

type UpdateChatTitleParams struct {
	Title pgtype.Text
	ID    uuid.UUID
}

func (q *Queries) UpdateChatTitle(ctx context.Context, arg UpdateChatTitleParams) error {
	_, err := q.db.Exec(ctx, updateChatTitle, arg.Title, arg.ID)
	return err
}

const upsertChat = `-- name: UpsertChat :one
INSERT INTO chats (
    id
  , project_id
  , organization_id
  , user_id
  , external_user_id
  , title
  , created_at
  , updated_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    NOW(),
    NOW()
)
ON CONFLICT (id) DO UPDATE SET id = EXCLUDED.id
RETURNING id
`

type UpsertChatParams struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	OrganizationID string
	UserID         pgtype.Text
	ExternalUserID pgtype.Text
	Title          pgtype.Text
}

// Use no-op update (id = EXCLUDED.id) to ensure RETURNING always returns a row,
// whether the chat was newly inserted or already existed.
func (q *Queries) UpsertChat(ctx context.Context, arg UpsertChatParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertChat,
		arg.ID,
		arg.ProjectID,
		arg.OrganizationID,
		arg.UserID,
		arg.ExternalUserID,
		arg.Title,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
