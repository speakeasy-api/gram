// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/urn"
)

const findFunctionResourceEntriesByUrn = `-- name: FindFunctionResourceEntriesByUrn :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
)
SELECT
  frd.id, frd.resource_urn, frd.deployment_id, frd.name, frd.variables
FROM function_resource_definitions frd
WHERE
  frd.deployment_id = (SELECT id FROM deployment)
  AND frd.deleted IS FALSE
  AND frd.resource_urn = ANY ($1::text[])
ORDER BY frd.id DESC
`

type FindFunctionResourceEntriesByUrnParams struct {
	Urns      []string
	ProjectID uuid.UUID
}

type FindFunctionResourceEntriesByUrnRow struct {
	ID           uuid.UUID
	ResourceUrn  urn.Resource
	DeploymentID uuid.UUID
	Name         string
	Variables    []byte
}

func (q *Queries) FindFunctionResourceEntriesByUrn(ctx context.Context, arg FindFunctionResourceEntriesByUrnParams) ([]FindFunctionResourceEntriesByUrnRow, error) {
	rows, err := q.db.Query(ctx, findFunctionResourceEntriesByUrn, arg.Urns, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindFunctionResourceEntriesByUrnRow
	for rows.Next() {
		var i FindFunctionResourceEntriesByUrnRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceUrn,
			&i.DeploymentID,
			&i.Name,
			&i.Variables,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFunctionResourcesByUrn = `-- name: FindFunctionResourcesByUrn :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $2
    AND ds.status = 'completed'
    ORDER BY d.seq DESC
    LIMIT 1
)
SELECT
  function_resource_definitions.id, function_resource_definitions.resource_urn, function_resource_definitions.project_id, function_resource_definitions.deployment_id, function_resource_definitions.function_id, function_resource_definitions.runtime, function_resource_definitions.name, function_resource_definitions.description, function_resource_definitions.uri, function_resource_definitions.title, function_resource_definitions.mime_type, function_resource_definitions.variables, function_resource_definitions.created_at, function_resource_definitions.updated_at, function_resource_definitions.deleted_at, function_resource_definitions.deleted,
  (select id from deployment) as owning_deployment_id
FROM function_resource_definitions
WHERE
  function_resource_definitions.deployment_id = (SELECT id FROM deployment)
  AND function_resource_definitions.deleted IS FALSE
  AND function_resource_definitions.resource_urn = ANY ($1::text[])
ORDER BY function_resource_definitions.id DESC
`

type FindFunctionResourcesByUrnParams struct {
	Urns      []string
	ProjectID uuid.UUID
}

type FindFunctionResourcesByUrnRow struct {
	FunctionResourceDefinition FunctionResourceDefinition
	OwningDeploymentID         uuid.UUID
}

func (q *Queries) FindFunctionResourcesByUrn(ctx context.Context, arg FindFunctionResourcesByUrnParams) ([]FindFunctionResourcesByUrnRow, error) {
	rows, err := q.db.Query(ctx, findFunctionResourcesByUrn, arg.Urns, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindFunctionResourcesByUrnRow
	for rows.Next() {
		var i FindFunctionResourcesByUrnRow
		if err := rows.Scan(
			&i.FunctionResourceDefinition.ID,
			&i.FunctionResourceDefinition.ResourceUrn,
			&i.FunctionResourceDefinition.ProjectID,
			&i.FunctionResourceDefinition.DeploymentID,
			&i.FunctionResourceDefinition.FunctionID,
			&i.FunctionResourceDefinition.Runtime,
			&i.FunctionResourceDefinition.Name,
			&i.FunctionResourceDefinition.Description,
			&i.FunctionResourceDefinition.Uri,
			&i.FunctionResourceDefinition.Title,
			&i.FunctionResourceDefinition.MimeType,
			&i.FunctionResourceDefinition.Variables,
			&i.FunctionResourceDefinition.CreatedAt,
			&i.FunctionResourceDefinition.UpdatedAt,
			&i.FunctionResourceDefinition.DeletedAt,
			&i.FunctionResourceDefinition.Deleted,
			&i.OwningDeploymentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionResourceByURN = `-- name: GetFunctionResourceByURN :one
WITH deployment AS (
  SELECT d.id
  FROM deployments d
  JOIN deployment_statuses ds ON d.id = ds.deployment_id
  WHERE d.project_id = $2
  AND ds.status = 'completed'
  ORDER BY d.seq DESC LIMIT 1
)
SELECT
    resource.id
  , resource.resource_urn
  , resource.project_id
  , resource.deployment_id
  , resource.function_id
  , resource.runtime
  , resource.name
  , resource.description
  , resource.uri
  , resource.title
  , resource.mime_type
  , resource.variables
  , access.id AS access_id
FROM deployment dep
INNER JOIN function_resource_definitions resource
  ON resource.deployment_id = dep.id
  AND resource.resource_urn = $1
  AND resource.project_id = $2
  AND resource.deleted IS FALSE
LEFT JOIN functions_access access
  ON access.project_id = $2
  AND access.deployment_id = dep.id
  AND access.function_id = resource.function_id
  AND access.deleted IS FALSE
ORDER BY access.seq DESC NULLS LAST
LIMIT 1
`

type GetFunctionResourceByURNParams struct {
	Urn       urn.Resource
	ProjectID uuid.UUID
}

type GetFunctionResourceByURNRow struct {
	ID           uuid.UUID
	ResourceUrn  urn.Resource
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
	Runtime      string
	Name         string
	Description  string
	Uri          string
	Title        pgtype.Text
	MimeType     pgtype.Text
	Variables    []byte
	AccessID     uuid.NullUUID
}

func (q *Queries) GetFunctionResourceByURN(ctx context.Context, arg GetFunctionResourceByURNParams) (GetFunctionResourceByURNRow, error) {
	row := q.db.QueryRow(ctx, getFunctionResourceByURN, arg.Urn, arg.ProjectID)
	var i GetFunctionResourceByURNRow
	err := row.Scan(
		&i.ID,
		&i.ResourceUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.FunctionID,
		&i.Runtime,
		&i.Name,
		&i.Description,
		&i.Uri,
		&i.Title,
		&i.MimeType,
		&i.Variables,
		&i.AccessID,
	)
	return i, err
}

const listFunctionResources = `-- name: ListFunctionResources :many
WITH deployment AS (
    SELECT d.id
    FROM deployments d
    JOIN deployment_statuses ds ON d.id = ds.deployment_id
    WHERE d.project_id = $3
      AND ($4::uuid IS NOT NULL OR ds.status = 'completed')
      AND (
        $4::uuid IS NULL
        OR d.id = $4::uuid
      )
    ORDER BY d.seq DESC
    LIMIT 1
)
SELECT
  (SELECT id FROM deployment) as deployment_id,
  frd.id,
  frd.resource_urn,
  frd.name,
  frd.description,
  frd.uri,
  frd.title,
  frd.mime_type,
  frd.variables,
  frd.runtime,
  frd.function_id,
  frd.created_at,
  frd.updated_at
FROM function_resource_definitions frd
WHERE
  frd.deployment_id = (SELECT id FROM deployment)
  AND frd.deleted IS FALSE
  AND ($2::uuid IS NULL OR frd.id < $2)
ORDER BY frd.id DESC
LIMIT $1
`

type ListFunctionResourcesParams struct {
	Limit        int32
	Cursor       uuid.NullUUID
	ProjectID    uuid.UUID
	DeploymentID uuid.NullUUID
}

type ListFunctionResourcesRow struct {
	DeploymentID uuid.UUID
	ID           uuid.UUID
	ResourceUrn  urn.Resource
	Name         string
	Description  string
	Uri          string
	Title        pgtype.Text
	MimeType     pgtype.Text
	Variables    []byte
	Runtime      string
	FunctionID   uuid.UUID
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

// Two use cases:
// 1. List all resources from the latest successful deployment (when deployment_id is NULL)
// 2. List all resources for a specific deployment by ID (when deployment_id is provided)
func (q *Queries) ListFunctionResources(ctx context.Context, arg ListFunctionResourcesParams) ([]ListFunctionResourcesRow, error) {
	rows, err := q.db.Query(ctx, listFunctionResources,
		arg.Limit,
		arg.Cursor,
		arg.ProjectID,
		arg.DeploymentID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFunctionResourcesRow
	for rows.Next() {
		var i ListFunctionResourcesRow
		if err := rows.Scan(
			&i.DeploymentID,
			&i.ID,
			&i.ResourceUrn,
			&i.Name,
			&i.Description,
			&i.Uri,
			&i.Title,
			&i.MimeType,
			&i.Variables,
			&i.Runtime,
			&i.FunctionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
