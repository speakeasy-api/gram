// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const archiveNotification = `-- name: ArchiveNotification :one
UPDATE notifications
SET archived_at = now(), updated_at = now()
WHERE id = $1 AND project_id = $2 AND deleted IS FALSE
RETURNING id, project_id, type, level, title, message, actor_user_id, resource_type, resource_id, archived_at, created_at, updated_at, deleted_at, deleted
`

type ArchiveNotificationParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) ArchiveNotification(ctx context.Context, arg ArchiveNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, archiveNotification, arg.ID, arg.ProjectID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Type,
		&i.Level,
		&i.Title,
		&i.Message,
		&i.ActorUserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const countAllNotifications = `-- name: CountAllNotifications :one
SELECT COUNT(*)::integer
FROM notifications
WHERE project_id = $1
  AND deleted IS FALSE
  AND archived_at IS NULL
`

func (q *Queries) CountAllNotifications(ctx context.Context, projectID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countAllNotifications, projectID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countNotificationsSince = `-- name: CountNotificationsSince :one
SELECT COUNT(*)::integer
FROM notifications
WHERE project_id = $1
  AND deleted IS FALSE
  AND archived_at IS NULL
  AND created_at > $2
`

type CountNotificationsSinceParams struct {
	ProjectID uuid.UUID
	Since     pgtype.Timestamptz
}

func (q *Queries) CountNotificationsSince(ctx context.Context, arg CountNotificationsSinceParams) (int32, error) {
	row := q.db.QueryRow(ctx, countNotificationsSince, arg.ProjectID, arg.Since)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
    project_id,
    type,
    level,
    title,
    message,
    actor_user_id,
    resource_type,
    resource_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id, project_id, type, level, title, message, actor_user_id, resource_type, resource_id, archived_at, created_at, updated_at, deleted_at, deleted
`

type CreateNotificationParams struct {
	ProjectID    uuid.UUID
	Type         string
	Level        string
	Title        string
	Message      pgtype.Text
	ActorUserID  pgtype.Text
	ResourceType pgtype.Text
	ResourceID   pgtype.Text
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.ProjectID,
		arg.Type,
		arg.Level,
		arg.Title,
		arg.Message,
		arg.ActorUserID,
		arg.ResourceType,
		arg.ResourceID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Type,
		&i.Level,
		&i.Title,
		&i.Message,
		&i.ActorUserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, project_id, type, level, title, message, actor_user_id, resource_type, resource_id, archived_at, created_at, updated_at, deleted_at, deleted
FROM notifications
WHERE id = $1 AND project_id = $2 AND deleted IS FALSE
`

type GetNotificationByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetNotificationByID(ctx context.Context, arg GetNotificationByIDParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, arg.ID, arg.ProjectID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Type,
		&i.Level,
		&i.Title,
		&i.Message,
		&i.ActorUserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, project_id, type, level, title, message, actor_user_id, resource_type, resource_id, archived_at, created_at, updated_at, deleted_at, deleted
FROM notifications
WHERE project_id = $1
  AND deleted IS FALSE
  AND (
    ($2 IS TRUE AND archived_at IS NOT NULL)
    OR ($2 IS FALSE AND archived_at IS NULL)
  )
ORDER BY created_at DESC
LIMIT $3
`

type ListNotificationsParams struct {
	ProjectID  uuid.UUID
	Archived   interface{}
	LimitCount int32
}

func (q *Queries) ListNotifications(ctx context.Context, arg ListNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, listNotifications, arg.ProjectID, arg.Archived, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Type,
			&i.Level,
			&i.Title,
			&i.Message,
			&i.ActorUserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.ArchivedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsByCursor = `-- name: ListNotificationsByCursor :many
SELECT id, project_id, type, level, title, message, actor_user_id, resource_type, resource_id, archived_at, created_at, updated_at, deleted_at, deleted
FROM notifications
WHERE project_id = $1
  AND deleted IS FALSE
  AND id < $2
  AND (
    ($3 IS TRUE AND archived_at IS NOT NULL)
    OR ($3 IS FALSE AND archived_at IS NULL)
  )
ORDER BY created_at DESC
LIMIT $4
`

type ListNotificationsByCursorParams struct {
	ProjectID  uuid.UUID
	Cursor     uuid.UUID
	Archived   interface{}
	LimitCount int32
}

func (q *Queries) ListNotificationsByCursor(ctx context.Context, arg ListNotificationsByCursorParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, listNotificationsByCursor,
		arg.ProjectID,
		arg.Cursor,
		arg.Archived,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Type,
			&i.Level,
			&i.Title,
			&i.Message,
			&i.ActorUserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.ArchivedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
