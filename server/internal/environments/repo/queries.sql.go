// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (
    organization_id,
    project_id,
    name,
    slug,
    description
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
`

type CreateEnvironmentParams struct {
	OrganizationID string
	ProjectID      uuid.UUID
	Name           string
	Slug           string
	Description    pgtype.Text
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, createEnvironment,
		arg.OrganizationID,
		arg.ProjectID,
		arg.Name,
		arg.Slug,
		arg.Description,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createEnvironmentEntries = `-- name: CreateEnvironmentEntries :many
INSERT INTO environment_entries (
    environment_id,
    name,
    value
)
/*
 Parameters:
 - environment_id: uuid
 - names: text[]
 - values: text[]
*/
VALUES (
    $1::uuid,
    unnest($2::text[]),
    unnest($3::text[])
)
RETURNING name, value, environment_id, created_at, updated_at
`

type CreateEnvironmentEntriesParams struct {
	EnvironmentID uuid.UUID
	Names         []string
	Values        []string
}

func (q *Queries) CreateEnvironmentEntries(ctx context.Context, arg CreateEnvironmentEntriesParams) ([]EnvironmentEntry, error) {
	rows, err := q.db.Query(ctx, createEnvironmentEntries, arg.EnvironmentID, arg.Names, arg.Values)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnvironmentEntry
	for rows.Next() {
		var i EnvironmentEntry
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteEnvironment = `-- name: DeleteEnvironment :exec
WITH deleted_env AS (
    UPDATE environments
    SET deleted_at = now()
    WHERE environments.slug = $1 AND environments.project_id = $2 AND environments.deleted IS FALSE
    RETURNING slug, project_id
)
UPDATE toolsets
SET default_environment_slug = NULL
FROM deleted_env
WHERE toolsets.default_environment_slug = deleted_env.slug AND toolsets.project_id = deleted_env.project_id
`

type DeleteEnvironmentParams struct {
	Slug      string
	ProjectID uuid.UUID
}

func (q *Queries) DeleteEnvironment(ctx context.Context, arg DeleteEnvironmentParams) error {
	_, err := q.db.Exec(ctx, deleteEnvironment, arg.Slug, arg.ProjectID)
	return err
}

const deleteEnvironmentEntry = `-- name: DeleteEnvironmentEntry :exec
DELETE FROM environment_entries
WHERE environment_id = $1 AND name = $2
`

type DeleteEnvironmentEntryParams struct {
	EnvironmentID uuid.UUID
	Name          string
}

func (q *Queries) DeleteEnvironmentEntry(ctx context.Context, arg DeleteEnvironmentEntryParams) error {
	_, err := q.db.Exec(ctx, deleteEnvironmentEntry, arg.EnvironmentID, arg.Name)
	return err
}

const deleteSourceEnvironment = `-- name: DeleteSourceEnvironment :exec
DELETE FROM source_environments
WHERE source_kind = $1 AND source_slug = $2 AND project_id = $3
`

type DeleteSourceEnvironmentParams struct {
	SourceKind string
	SourceSlug string
	ProjectID  uuid.UUID
}

func (q *Queries) DeleteSourceEnvironment(ctx context.Context, arg DeleteSourceEnvironmentParams) error {
	_, err := q.db.Exec(ctx, deleteSourceEnvironment, arg.SourceKind, arg.SourceSlug, arg.ProjectID)
	return err
}

const deleteToolsetEnvironment = `-- name: DeleteToolsetEnvironment :exec
DELETE FROM toolset_environments
WHERE toolset_id = $1 AND project_id = $2
`

type DeleteToolsetEnvironmentParams struct {
	ToolsetID uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) DeleteToolsetEnvironment(ctx context.Context, arg DeleteToolsetEnvironmentParams) error {
	_, err := q.db.Exec(ctx, deleteToolsetEnvironment, arg.ToolsetID, arg.ProjectID)
	return err
}

const getEnvironmentByID = `-- name: GetEnvironmentByID :one
SELECT id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
FROM environments e
WHERE e.id = $1 AND e.project_id = $2 AND e.deleted IS FALSE
`

type GetEnvironmentByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetEnvironmentByID(ctx context.Context, arg GetEnvironmentByIDParams) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentByID, arg.ID, arg.ProjectID)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getEnvironmentBySlug = `-- name: GetEnvironmentBySlug :one
SELECT id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
FROM environments e
WHERE e.slug = $1 AND e.project_id = $2 AND e.deleted IS FALSE
`

type GetEnvironmentBySlugParams struct {
	Slug      string
	ProjectID uuid.UUID
}

// returns: GetEnvironmentByIDRow
func (q *Queries) GetEnvironmentBySlug(ctx context.Context, arg GetEnvironmentBySlugParams) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentBySlug, arg.Slug, arg.ProjectID)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getEnvironmentForSource = `-- name: GetEnvironmentForSource :one
SELECT e.id, e.organization_id, e.project_id, e.name, e.slug, e.description, e.created_at, e.updated_at, e.deleted_at, e.deleted
FROM environments e
INNER JOIN source_environments se ON se.environment_id = e.id
WHERE se.source_kind = $1
    AND se.source_slug = $2
    AND se.project_id = $3
    AND e.deleted IS FALSE
`

type GetEnvironmentForSourceParams struct {
	SourceKind string
	SourceSlug string
	ProjectID  uuid.UUID
}

func (q *Queries) GetEnvironmentForSource(ctx context.Context, arg GetEnvironmentForSourceParams) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentForSource, arg.SourceKind, arg.SourceSlug, arg.ProjectID)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const getEnvironmentForToolset = `-- name: GetEnvironmentForToolset :one
SELECT e.id, e.organization_id, e.project_id, e.name, e.slug, e.description, e.created_at, e.updated_at, e.deleted_at, e.deleted
FROM environments e
INNER JOIN toolset_environments te ON te.environment_id = e.id
WHERE te.toolset_id = $1
    AND te.project_id = $2
    AND e.deleted IS FALSE
`

type GetEnvironmentForToolsetParams struct {
	ToolsetID uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetEnvironmentForToolset(ctx context.Context, arg GetEnvironmentForToolsetParams) (Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentForToolset, arg.ToolsetID, arg.ProjectID)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const listEnvironmentEntries = `-- name: ListEnvironmentEntries :many
SELECT ee.name, ee.value, ee.environment_id, ee.created_at, ee.updated_at
FROM environment_entries ee
INNER JOIN environments e ON ee.environment_id = e.id
WHERE
    e.project_id = $1 AND
    ee.environment_id = $2
ORDER BY ee.name ASC
`

type ListEnvironmentEntriesParams struct {
	ProjectID     uuid.UUID
	EnvironmentID uuid.UUID
}

func (q *Queries) ListEnvironmentEntries(ctx context.Context, arg ListEnvironmentEntriesParams) ([]EnvironmentEntry, error) {
	rows, err := q.db.Query(ctx, listEnvironmentEntries, arg.ProjectID, arg.EnvironmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EnvironmentEntry
	for rows.Next() {
		var i EnvironmentEntry
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
FROM environments e
WHERE e.project_id = $1 AND e.deleted IS FALSE
ORDER BY e.created_at DESC
`

func (q *Queries) ListEnvironments(ctx context.Context, projectID uuid.UUID) ([]Environment, error) {
	rows, err := q.db.Query(ctx, listEnvironments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Environment
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setSourceEnvironment = `-- name: SetSourceEnvironment :one
INSERT INTO source_environments (
    source_kind,
    source_slug,
    project_id,
    environment_id
) VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (source_kind, source_slug, project_id)
DO UPDATE SET
    environment_id = EXCLUDED.environment_id,
    updated_at = now()
RETURNING id, source_kind, source_slug, project_id, environment_id, created_at, updated_at
`

type SetSourceEnvironmentParams struct {
	SourceKind    string
	SourceSlug    string
	ProjectID     uuid.UUID
	EnvironmentID uuid.UUID
}

func (q *Queries) SetSourceEnvironment(ctx context.Context, arg SetSourceEnvironmentParams) (SourceEnvironment, error) {
	row := q.db.QueryRow(ctx, setSourceEnvironment,
		arg.SourceKind,
		arg.SourceSlug,
		arg.ProjectID,
		arg.EnvironmentID,
	)
	var i SourceEnvironment
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceSlug,
		&i.ProjectID,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setToolsetEnvironment = `-- name: SetToolsetEnvironment :one
INSERT INTO toolset_environments (
    toolset_id,
    project_id,
    environment_id
) VALUES (
    $1,
    $2,
    $3
)
ON CONFLICT (toolset_id)
DO UPDATE SET
    environment_id = EXCLUDED.environment_id,
    updated_at = now()
RETURNING id, toolset_id, project_id, environment_id, created_at, updated_at
`

type SetToolsetEnvironmentParams struct {
	ToolsetID     uuid.UUID
	ProjectID     uuid.UUID
	EnvironmentID uuid.UUID
}

func (q *Queries) SetToolsetEnvironment(ctx context.Context, arg SetToolsetEnvironmentParams) (ToolsetEnvironment, error) {
	row := q.db.QueryRow(ctx, setToolsetEnvironment, arg.ToolsetID, arg.ProjectID, arg.EnvironmentID)
	var i ToolsetEnvironment
	err := row.Scan(
		&i.ID,
		&i.ToolsetID,
		&i.ProjectID,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEnvironment = `-- name: UpdateEnvironment :one
UPDATE environments
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    updated_at = now()
WHERE slug = $3 AND project_id = $4 AND deleted IS FALSE
RETURNING id, organization_id, project_id, name, slug, description, created_at, updated_at, deleted_at, deleted
`

type UpdateEnvironmentParams struct {
	Name        string
	Description pgtype.Text
	Slug        string
	ProjectID   uuid.UUID
}

func (q *Queries) UpdateEnvironment(ctx context.Context, arg UpdateEnvironmentParams) (Environment, error) {
	row := q.db.QueryRow(ctx, updateEnvironment,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.ProjectID,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const upsertEnvironmentEntry = `-- name: UpsertEnvironmentEntry :one
INSERT INTO environment_entries (environment_id, name, value, updated_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (environment_id, name)
DO UPDATE SET
    value = EXCLUDED.value,
    updated_at = now()
RETURNING name, value, environment_id, created_at, updated_at
`

type UpsertEnvironmentEntryParams struct {
	EnvironmentID uuid.UUID
	Name          string
	Value         string
}

func (q *Queries) UpsertEnvironmentEntry(ctx context.Context, arg UpsertEnvironmentEntryParams) (EnvironmentEntry, error) {
	row := q.db.QueryRow(ctx, upsertEnvironmentEntry, arg.EnvironmentID, arg.Name, arg.Value)
	var i EnvironmentEntry
	err := row.Scan(
		&i.Name,
		&i.Value,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
