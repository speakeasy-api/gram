// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"
)

const getAllOrganizationsWithToolsets = `-- name: GetAllOrganizationsWithToolsets :many
SELECT
    organization_metadata.id,
    organization_metadata.name,
    organization_metadata.slug,
    gram_account_type
FROM organization_metadata
JOIN toolsets ON organization_metadata.id = toolsets.organization_id
WHERE toolsets.deleted = false
GROUP BY organization_metadata.id
HAVING COUNT(toolsets.id) > 0
`

type GetAllOrganizationsWithToolsetsRow struct {
	ID              string
	Name            string
	Slug            string
	GramAccountType string
}

func (q *Queries) GetAllOrganizationsWithToolsets(ctx context.Context) ([]GetAllOrganizationsWithToolsetsRow, error) {
	rows, err := q.db.Query(ctx, getAllOrganizationsWithToolsets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOrganizationsWithToolsetsRow
	for rows.Next() {
		var i GetAllOrganizationsWithToolsetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.GramAccountType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformUsageMetrics = `-- name: GetPlatformUsageMetrics :many
WITH latest_deployments AS (
  SELECT DISTINCT ON (project_id) project_id, d.id as deployment_id
  FROM deployments d
  JOIN deployment_statuses ds ON d.id = ds.deployment_id
  WHERE ds.status = 'completed'
  ORDER BY project_id, d.created_at DESC
),
toolset_metrics AS (
  SELECT 
    p.organization_id,
    COUNT(CASE WHEN t.mcp_is_public = true AND t.mcp_slug IS NOT NULL THEN 1 END) as public_mcp_servers,
    COUNT(CASE WHEN t.mcp_is_public = false AND t.mcp_slug IS NOT NULL THEN 1 END) as private_mcp_servers,
    COUNT(CASE WHEN t.mcp_enabled = true THEN 1 END) as total_enabled_servers,
    COUNT(t.id) as total_toolsets
  FROM projects p
  LEFT JOIN toolsets t ON p.id = t.project_id AND t.deleted = false
  GROUP BY p.organization_id
),
tool_metrics AS (
  SELECT 
    p.organization_id,
    COUNT(DISTINCT htd.id) as total_tools
  FROM projects p
  LEFT JOIN latest_deployments ld ON p.id = ld.project_id
  LEFT JOIN http_tool_definitions htd ON ld.deployment_id = htd.deployment_id AND htd.deleted = false
  GROUP BY p.organization_id
)
SELECT 
  COALESCE(tm.organization_id, tlm.organization_id) as organization_id,
  COALESCE(tm.public_mcp_servers, 0) as public_mcp_servers,
  COALESCE(tm.private_mcp_servers, 0) as private_mcp_servers,
  COALESCE(tm.total_enabled_servers, 0) as total_enabled_servers,
  COALESCE(tm.total_toolsets, 0) as total_toolsets,
  COALESCE(tlm.total_tools, 0) as total_tools
FROM toolset_metrics tm
FULL OUTER JOIN tool_metrics tlm ON tm.organization_id = tlm.organization_id
`

type GetPlatformUsageMetricsRow struct {
	OrganizationID      string
	PublicMcpServers    int64
	PrivateMcpServers   int64
	TotalEnabledServers int64
	TotalToolsets       int64
	TotalTools          int64
}

// Get comprehensive platform usage metrics per organization
func (q *Queries) GetPlatformUsageMetrics(ctx context.Context) ([]GetPlatformUsageMetricsRow, error) {
	rows, err := q.db.Query(ctx, getPlatformUsageMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformUsageMetricsRow
	for rows.Next() {
		var i GetPlatformUsageMetricsRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.PublicMcpServers,
			&i.PrivateMcpServers,
			&i.TotalEnabledServers,
			&i.TotalToolsets,
			&i.TotalTools,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEmailsByOrgIDs = `-- name: GetUserEmailsByOrgIDs :many
SELECT DISTINCT
    d.organization_id,
    u.email
FROM deployments d
JOIN users u ON d.user_id = u.id
WHERE d.organization_id = ANY($1::text[])
  AND d.id IN (
    SELECT DISTINCT ON (organization_id) id
    FROM deployments 
    WHERE organization_id = ANY($1::text[])
    ORDER BY organization_id, created_at DESC
  )
`

type GetUserEmailsByOrgIDsRow struct {
	OrganizationID string
	Email          string
}

// Get user emails for organization IDs by looking up the latest deployment for each org
func (q *Queries) GetUserEmailsByOrgIDs(ctx context.Context, dollar_1 []string) ([]GetUserEmailsByOrgIDsRow, error) {
	rows, err := q.db.Query(ctx, getUserEmailsByOrgIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEmailsByOrgIDsRow
	for rows.Next() {
		var i GetUserEmailsByOrgIDsRow
		if err := rows.Scan(&i.OrganizationID, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
