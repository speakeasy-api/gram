// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/conv"
	"github.com/speakeasy-api/gram/server/internal/tools/repo/models"
	"github.com/speakeasy-api/gram/server/internal/urn"
)

type BatchLogEventsParams struct {
	DeploymentID   uuid.UUID
	ProjectID      uuid.UUID
	Event          string
	Message        string
	AttachmentID   uuid.NullUUID
	AttachmentType pgtype.Text
}

const cloneDeployment = `-- name: CloneDeployment :one
INSERT INTO deployments (
  cloned_from
  , idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , github_sha
  , external_id
  , external_url
)
SELECT
  current.id
  , gen_random_uuid()
  , current.user_id
  , current.organization_id
  , current.project_id
  , current.github_repo
  , current.github_pr
  , current.github_sha
  , current.external_id
  , current.external_url
FROM deployments as current
WHERE current.id = $1 AND current.project_id = $2
RETURNING id
`

type CloneDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) CloneDeployment(ctx context.Context, arg CloneDeploymentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, cloneDeployment, arg.ID, arg.ProjectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const cloneDeploymentExternalMCPs = `-- name: CloneDeploymentExternalMCPs :many
INSERT INTO external_mcp_attachments (deployment_id, registry_id, name, slug, registry_server_specifier)
SELECT
  $1
  , current.registry_id
  , current.name
  , current.slug
  , current.registry_server_specifier
FROM external_mcp_attachments as current
WHERE current.deployment_id = $2
  AND current.deleted IS FALSE
  AND current.slug <> ALL ($3::text[])
RETURNING id, deployment_id, registry_id, name, slug, registry_server_specifier
`

type CloneDeploymentExternalMCPsParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedSlugs        []string
}

type CloneDeploymentExternalMCPsRow struct {
	ID                      uuid.UUID
	DeploymentID            uuid.UUID
	RegistryID              uuid.UUID
	Name                    string
	Slug                    string
	RegistryServerSpecifier string
}

func (q *Queries) CloneDeploymentExternalMCPs(ctx context.Context, arg CloneDeploymentExternalMCPsParams) ([]CloneDeploymentExternalMCPsRow, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentExternalMCPs, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedSlugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CloneDeploymentExternalMCPsRow
	for rows.Next() {
		var i CloneDeploymentExternalMCPsRow
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.RegistryID,
			&i.Name,
			&i.Slug,
			&i.RegistryServerSpecifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cloneDeploymentFunctionsAssets = `-- name: CloneDeploymentFunctionsAssets :many
INSERT INTO deployments_functions (
  deployment_id
  , asset_id
  , name
  , slug
  , runtime
)
SELECT 
  $1
  , current.asset_id
  , current.name
  , current.slug
  , current.runtime
FROM deployments_functions as current
WHERE current.deployment_id = $2
  AND current.asset_id <> ALL ($3::uuid[])
RETURNING id
`

type CloneDeploymentFunctionsAssetsParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

func (q *Queries) CloneDeploymentFunctionsAssets(ctx context.Context, arg CloneDeploymentFunctionsAssetsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentFunctionsAssets, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cloneDeploymentOpenAPIv3Assets = `-- name: CloneDeploymentOpenAPIv3Assets :many
INSERT INTO deployments_openapiv3_assets (
  deployment_id
  , asset_id
  , name
  , slug
)
SELECT 
  $1
  , current.asset_id
  , current.name
  , current.slug
FROM deployments_openapiv3_assets as current
WHERE current.deployment_id = $2
  AND current.asset_id <> ALL ($3::uuid[])
RETURNING id
`

type CloneDeploymentOpenAPIv3AssetsParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

func (q *Queries) CloneDeploymentOpenAPIv3Assets(ctx context.Context, arg CloneDeploymentOpenAPIv3AssetsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentOpenAPIv3Assets, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cloneDeploymentPackages = `-- name: CloneDeploymentPackages :many
INSERT INTO deployments_packages (
  deployment_id
  , package_id
  , version_id
)
SELECT 
  $1
  , current.package_id
  , current.version_id
FROM deployments_packages as current
WHERE current.deployment_id = $2
  AND current.package_id <> ALL ($3::uuid[])
RETURNING id, package_id, version_id
`

type CloneDeploymentPackagesParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

type CloneDeploymentPackagesRow struct {
	ID        uuid.UUID
	PackageID uuid.UUID
	VersionID uuid.UUID
}

func (q *Queries) CloneDeploymentPackages(ctx context.Context, arg CloneDeploymentPackagesParams) ([]CloneDeploymentPackagesRow, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentPackages, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CloneDeploymentPackagesRow
	for rows.Next() {
		var i CloneDeploymentPackagesRow
		if err := rows.Scan(&i.ID, &i.PackageID, &i.VersionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cloneDeploymentToolFunctions = `-- name: CloneDeploymentToolFunctions :many
INSERT INTO function_tool_definitions (
  deployment_id
  , function_id
  , tool_urn
  , project_id
  , name
  , description
  , runtime
  , variables
  , auth_input
  , input_schema
)
SELECT 
  $1
  , current.function_id
  , current.tool_urn
  , current.project_id
  , current.name
  , current.description
  , current.runtime
  , current.variables
  , current.auth_input
  , current.input_schema
FROM function_tool_definitions as current
WHERE current.deployment_id = $2
  AND current.name <> ALL ($3::text[])
RETURNING id
`

type CloneDeploymentToolFunctionsParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedNames        []string
}

func (q *Queries) CloneDeploymentToolFunctions(ctx context.Context, arg CloneDeploymentToolFunctionsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentToolFunctions, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createDeployment = `-- name: CreateDeployment :execresult
INSERT INTO deployments (
  idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , github_sha
  , external_id
  , external_url
) VALUES (
  $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
)
ON CONFLICT (project_id, idempotency_key) DO NOTHING
`

type CreateDeploymentParams struct {
	IdempotencyKey string
	UserID         string
	OrganizationID string
	ProjectID      uuid.UUID
	GithubRepo     pgtype.Text
	GithubPr       pgtype.Text
	GithubSha      pgtype.Text
	ExternalID     pgtype.Text
	ExternalUrl    pgtype.Text
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createDeployment,
		arg.IdempotencyKey,
		arg.UserID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.GithubRepo,
		arg.GithubPr,
		arg.GithubSha,
		arg.ExternalID,
		arg.ExternalUrl,
	)
}

const createDeploymentFunctionsAccess = `-- name: CreateDeploymentFunctionsAccess :one
INSERT INTO functions_access (
    project_id
  , deployment_id
  , function_id
  , encryption_key
  , bearer_format
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
)
RETURNING id
`

type CreateDeploymentFunctionsAccessParams struct {
	ProjectID     uuid.UUID
	DeploymentID  uuid.UUID
	FunctionID    uuid.UUID
	EncryptionKey conv.Secret
	BearerFormat  pgtype.Text
}

func (q *Queries) CreateDeploymentFunctionsAccess(ctx context.Context, arg CreateDeploymentFunctionsAccessParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createDeploymentFunctionsAccess,
		arg.ProjectID,
		arg.DeploymentID,
		arg.FunctionID,
		arg.EncryptionKey,
		arg.BearerFormat,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createFunctionsResource = `-- name: CreateFunctionsResource :one
INSERT INTO function_resource_definitions (
    deployment_id
  , function_id
  , resource_urn
  , project_id
  , runtime
  , name
  , description
  , uri
  , title
  , mime_type
  , variables
  , meta
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
)
RETURNING id, resource_urn, project_id, deployment_id, function_id, runtime, name, description, uri, title, mime_type, variables, meta, created_at, updated_at, deleted_at, deleted
`

type CreateFunctionsResourceParams struct {
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
	ResourceUrn  urn.Resource
	ProjectID    uuid.UUID
	Runtime      string
	Name         string
	Description  string
	Uri          string
	Title        pgtype.Text
	MimeType     pgtype.Text
	Variables    []byte
	Meta         []byte
}

func (q *Queries) CreateFunctionsResource(ctx context.Context, arg CreateFunctionsResourceParams) (FunctionResourceDefinition, error) {
	row := q.db.QueryRow(ctx, createFunctionsResource,
		arg.DeploymentID,
		arg.FunctionID,
		arg.ResourceUrn,
		arg.ProjectID,
		arg.Runtime,
		arg.Name,
		arg.Description,
		arg.Uri,
		arg.Title,
		arg.MimeType,
		arg.Variables,
		arg.Meta,
	)
	var i FunctionResourceDefinition
	err := row.Scan(
		&i.ID,
		&i.ResourceUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.FunctionID,
		&i.Runtime,
		&i.Name,
		&i.Description,
		&i.Uri,
		&i.Title,
		&i.MimeType,
		&i.Variables,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createFunctionsTool = `-- name: CreateFunctionsTool :one
INSERT INTO function_tool_definitions (
    deployment_id
  , function_id
  , tool_urn
  , project_id
  , runtime
  , name
  , description
  , input_schema
  , variables
  , auth_input
  , meta
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
)
RETURNING id, tool_urn, project_id, deployment_id, function_id, runtime, name, description, input_schema, variables, auth_input, meta, created_at, updated_at, deleted_at, deleted
`

type CreateFunctionsToolParams struct {
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
	ToolUrn      urn.Tool
	ProjectID    uuid.UUID
	Runtime      string
	Name         string
	Description  string
	InputSchema  []byte
	Variables    []byte
	AuthInput    []byte
	Meta         []byte
}

func (q *Queries) CreateFunctionsTool(ctx context.Context, arg CreateFunctionsToolParams) (FunctionToolDefinition, error) {
	row := q.db.QueryRow(ctx, createFunctionsTool,
		arg.DeploymentID,
		arg.FunctionID,
		arg.ToolUrn,
		arg.ProjectID,
		arg.Runtime,
		arg.Name,
		arg.Description,
		arg.InputSchema,
		arg.Variables,
		arg.AuthInput,
		arg.Meta,
	)
	var i FunctionToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.FunctionID,
		&i.Runtime,
		&i.Name,
		&i.Description,
		&i.InputSchema,
		&i.Variables,
		&i.AuthInput,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createHTTPSecurity = `-- name: CreateHTTPSecurity :one
INSERT INTO http_security (
    key
  , deployment_id
  , project_id
  , openapiv3_document_id
  , type
  , name
  , in_placement
  , scheme
  , bearer_format
  , env_variables
  , oauth_types
  , oauth_flows
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
)
RETURNING id, deployment_id, project_id, openapiv3_document_id, key, type, name, in_placement, scheme, bearer_format, oauth_types, oauth_flows, env_variables, created_at, updated_at, deleted_at, deleted
`

type CreateHTTPSecurityParams struct {
	Key                 string
	DeploymentID        uuid.UUID
	ProjectID           uuid.NullUUID
	Openapiv3DocumentID uuid.NullUUID
	Type                pgtype.Text
	Name                pgtype.Text
	InPlacement         pgtype.Text
	Scheme              pgtype.Text
	BearerFormat        pgtype.Text
	EnvVariables        []string
	OauthTypes          []string
	OauthFlows          []byte
}

func (q *Queries) CreateHTTPSecurity(ctx context.Context, arg CreateHTTPSecurityParams) (HttpSecurity, error) {
	row := q.db.QueryRow(ctx, createHTTPSecurity,
		arg.Key,
		arg.DeploymentID,
		arg.ProjectID,
		arg.Openapiv3DocumentID,
		arg.Type,
		arg.Name,
		arg.InPlacement,
		arg.Scheme,
		arg.BearerFormat,
		arg.EnvVariables,
		arg.OauthTypes,
		arg.OauthFlows,
	)
	var i HttpSecurity
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.ProjectID,
		&i.Openapiv3DocumentID,
		&i.Key,
		&i.Type,
		&i.Name,
		&i.InPlacement,
		&i.Scheme,
		&i.BearerFormat,
		&i.OauthTypes,
		&i.OauthFlows,
		&i.EnvVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createOpenAPIv3ToolDefinition = `-- name: CreateOpenAPIv3ToolDefinition :one
INSERT INTO http_tool_definitions (
    project_id
  , deployment_id
  , openapiv3_document_id
  , tool_urn
  , name
  , untruncated_name
  , openapiv3_operation
  , summary
  , description
  , tags
  , confirm
  , confirm_prompt
  , x_gram
  , original_name
  , original_summary
  , original_description
  , security
  , http_method
  , path
  , schema_version
  , schema
  , header_settings
  , query_settings
  , path_settings
  , server_env_var
  , default_server_url
  , request_content_type
  , response_filter
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
  , $13
  , $14
  , $15
  , $16
  , $17
  , $18
  , $19
  , $20
  , $21
  , $22
  , $23
  , $24
  , $25
  , $26
  , $27
  , $28
)
RETURNING id, tool_urn, project_id, deployment_id, openapiv3_document_id, confirm, confirm_prompt, summarizer, name, untruncated_name, summary, description, openapiv3_operation, tags, x_gram, original_name, original_summary, original_description, server_env_var, default_server_url, security, http_method, path, schema_version, schema, header_settings, query_settings, path_settings, request_content_type, response_filter, created_at, updated_at, deleted_at, deleted
`

type CreateOpenAPIv3ToolDefinitionParams struct {
	ProjectID           uuid.UUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.NullUUID
	ToolUrn             urn.Tool
	Name                string
	UntruncatedName     pgtype.Text
	Openapiv3Operation  pgtype.Text
	Summary             string
	Description         string
	Tags                []string
	Confirm             pgtype.Text
	ConfirmPrompt       pgtype.Text
	XGram               pgtype.Bool
	OriginalName        pgtype.Text
	OriginalSummary     pgtype.Text
	OriginalDescription pgtype.Text
	Security            []byte
	HttpMethod          string
	Path                string
	SchemaVersion       string
	Schema              []byte
	HeaderSettings      []byte
	QuerySettings       []byte
	PathSettings        []byte
	ServerEnvVar        string
	DefaultServerUrl    pgtype.Text
	RequestContentType  pgtype.Text
	ResponseFilter      *models.ResponseFilter
}

func (q *Queries) CreateOpenAPIv3ToolDefinition(ctx context.Context, arg CreateOpenAPIv3ToolDefinitionParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, createOpenAPIv3ToolDefinition,
		arg.ProjectID,
		arg.DeploymentID,
		arg.Openapiv3DocumentID,
		arg.ToolUrn,
		arg.Name,
		arg.UntruncatedName,
		arg.Openapiv3Operation,
		arg.Summary,
		arg.Description,
		arg.Tags,
		arg.Confirm,
		arg.ConfirmPrompt,
		arg.XGram,
		arg.OriginalName,
		arg.OriginalSummary,
		arg.OriginalDescription,
		arg.Security,
		arg.HttpMethod,
		arg.Path,
		arg.SchemaVersion,
		arg.Schema,
		arg.HeaderSettings,
		arg.QuerySettings,
		arg.PathSettings,
		arg.ServerEnvVar,
		arg.DefaultServerUrl,
		arg.RequestContentType,
		arg.ResponseFilter,
	)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ToolUrn,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Confirm,
		&i.ConfirmPrompt,
		&i.Summarizer,
		&i.Name,
		&i.UntruncatedName,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.XGram,
		&i.OriginalName,
		&i.OriginalSummary,
		&i.OriginalDescription,
		&i.ServerEnvVar,
		&i.DefaultServerUrl,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.HeaderSettings,
		&i.QuerySettings,
		&i.PathSettings,
		&i.RequestContentType,
		&i.ResponseFilter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const dangerouslyClearDeploymentHTTPSecurity = `-- name: DangerouslyClearDeploymentHTTPSecurity :execrows
DELETE FROM http_security
WHERE
  project_id = $1
  AND (deployment_id = $2 AND deployment_id IS NOT NULL)
  AND (openapiv3_document_id = $3 AND openapiv3_document_id IS NOT NULL)
`

type DangerouslyClearDeploymentHTTPSecurityParams struct {
	ProjectID           uuid.NullUUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.NullUUID
}

func (q *Queries) DangerouslyClearDeploymentHTTPSecurity(ctx context.Context, arg DangerouslyClearDeploymentHTTPSecurityParams) (int64, error) {
	result, err := q.db.Exec(ctx, dangerouslyClearDeploymentHTTPSecurity, arg.ProjectID, arg.DeploymentID, arg.Openapiv3DocumentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dangerouslyClearDeploymentTools = `-- name: DangerouslyClearDeploymentTools :execrows
DELETE FROM http_tool_definitions
WHERE
  project_id = $1
  AND deployment_id = $2
  AND openapiv3_document_id = $3::uuid
`

type DangerouslyClearDeploymentToolsParams struct {
	ProjectID           uuid.UUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.UUID
}

func (q *Queries) DangerouslyClearDeploymentTools(ctx context.Context, arg DangerouslyClearDeploymentToolsParams) (int64, error) {
	result, err := q.db.Exec(ctx, dangerouslyClearDeploymentTools, arg.ProjectID, arg.DeploymentID, arg.Openapiv3DocumentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const describeDeploymentPackages = `-- name: DescribeDeploymentPackages :many
SELECT 
  deployments_packages.id as deployment_package_id
  , packages.name as package_name
  , package_versions.id, package_versions.package_id, package_versions.deployment_id, package_versions.visibility, package_versions.major, package_versions.minor, package_versions.patch, package_versions.prerelease, package_versions.build, package_versions.created_at, package_versions.updated_at, package_versions.deleted_at, package_versions.deleted
FROM deployments_packages
INNER JOIN packages ON deployments_packages.package_id = packages.id
INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
WHERE deployments_packages.deployment_id = $1
`

type DescribeDeploymentPackagesRow struct {
	DeploymentPackageID uuid.UUID
	PackageName         string
	PackageVersion      PackageVersion
}

func (q *Queries) DescribeDeploymentPackages(ctx context.Context, deploymentID uuid.UUID) ([]DescribeDeploymentPackagesRow, error) {
	rows, err := q.db.Query(ctx, describeDeploymentPackages, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DescribeDeploymentPackagesRow
	for rows.Next() {
		var i DescribeDeploymentPackagesRow
		if err := rows.Scan(
			&i.DeploymentPackageID,
			&i.PackageName,
			&i.PackageVersion.ID,
			&i.PackageVersion.PackageID,
			&i.PackageVersion.DeploymentID,
			&i.PackageVersion.Visibility,
			&i.PackageVersion.Major,
			&i.PackageVersion.Minor,
			&i.PackageVersion.Patch,
			&i.PackageVersion.Prerelease,
			&i.PackageVersion.Build,
			&i.PackageVersion.CreatedAt,
			&i.PackageVersion.UpdatedAt,
			&i.PackageVersion.DeletedAt,
			&i.PackageVersion.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveDeploymentID = `-- name: GetActiveDeploymentID :one
SELECT d.id
FROM deployments d
INNER JOIN deployment_statuses ds
ON d.id = ds.deployment_id
WHERE d.project_id = $1
AND ds.status = 'completed'
ORDER BY d.id DESC
LIMIT 1
`

func (q *Queries) GetActiveDeploymentID(ctx context.Context, projectID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getActiveDeploymentID, projectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getDeployment = `-- name: GetDeployment :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeployment(ctx context.Context, arg GetDeploymentParams) (GetDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getDeployment, arg.ID, arg.ProjectID)
	var i GetDeploymentRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.ClonedFrom,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentByIdempotencyKey = `-- name: GetDeploymentByIdempotencyKey :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    INNER JOIN deployments ON deployment_statuses.deployment_id = deployments.id
    WHERE deployments.idempotency_key = $1
    ORDER BY deployment_statuses.seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.idempotency_key = $1
 AND deployments.project_id = $2
`

type GetDeploymentByIdempotencyKeyParams struct {
	IdempotencyKey string
	ProjectID      uuid.UUID
}

type GetDeploymentByIdempotencyKeyRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeploymentByIdempotencyKey(ctx context.Context, arg GetDeploymentByIdempotencyKeyParams) (GetDeploymentByIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getDeploymentByIdempotencyKey, arg.IdempotencyKey, arg.ProjectID)
	var i GetDeploymentByIdempotencyKeyRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.ClonedFrom,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentFunctions = `-- name: GetDeploymentFunctions :many
SELECT df.id, df.deployment_id, df.asset_id, df.name, df.slug, df.runtime, df.runner_version
FROM deployments_functions df
INNER JOIN deployments d ON df.deployment_id = d.id
WHERE 
  d.project_id = $1
  AND df.deployment_id = $2
`

type GetDeploymentFunctionsParams struct {
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
}

func (q *Queries) GetDeploymentFunctions(ctx context.Context, arg GetDeploymentFunctionsParams) ([]DeploymentsFunction, error) {
	rows, err := q.db.Query(ctx, getDeploymentFunctions, arg.ProjectID, arg.DeploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentsFunction
	for rows.Next() {
		var i DeploymentsFunction
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.AssetID,
			&i.Name,
			&i.Slug,
			&i.Runtime,
			&i.RunnerVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentFunctionsWithoutAccess = `-- name: GetDeploymentFunctionsWithoutAccess :many
SELECT df.id
FROM deployments_functions df
LEFT JOIN functions_access fm ON df.id = fm.function_id AND fm.deleted IS FALSE
WHERE df.deployment_id = $1 
  AND df.deployment_id IN (
    SELECT id FROM deployments d WHERE d.project_id = $2
  )
  AND fm.function_id IS NULL
`

type GetDeploymentFunctionsWithoutAccessParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
}

func (q *Queries) GetDeploymentFunctionsWithoutAccess(ctx context.Context, arg GetDeploymentFunctionsWithoutAccessParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getDeploymentFunctionsWithoutAccess, arg.DeploymentID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentLogs = `-- name: GetDeploymentLogs :many
WITH latest_status as (
    SELECT s.status
    FROM deployment_statuses s
    WHERE s.deployment_id = $1
    ORDER BY s.seq DESC
    LIMIT 1
)
SELECT
  coalesce((select status from latest_status), 'unknown')::text as status,
  log.id,
  log.seq,
  log.event,
  log.message,
  log.attachment_id,
  log.attachment_type,
  log.created_at
FROM deployment_logs log
WHERE
  log.deployment_id = $1 AND log.project_id = $2
  AND log.seq >= CASE
    WHEN $3::int8 IS NOT NULL THEN $3::int8
    ELSE (
      SELECT dl.seq
      FROM deployment_logs dl
      WHERE dl.deployment_id = $1 AND dl.project_id = $2
      ORDER BY dl.seq ASC LIMIT 1
    )
  END
ORDER BY log.seq ASC
LIMIT 51
`

type GetDeploymentLogsParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
	CursorSeq    pgtype.Int8
}

type GetDeploymentLogsRow struct {
	Status         string
	ID             uuid.UUID
	Seq            int64
	Event          string
	Message        string
	AttachmentID   uuid.NullUUID
	AttachmentType pgtype.Text
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) GetDeploymentLogs(ctx context.Context, arg GetDeploymentLogsParams) ([]GetDeploymentLogsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentLogs, arg.DeploymentID, arg.ProjectID, arg.CursorSeq)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentLogsRow
	for rows.Next() {
		var i GetDeploymentLogsRow
		if err := rows.Scan(
			&i.Status,
			&i.ID,
			&i.Seq,
			&i.Event,
			&i.Message,
			&i.AttachmentID,
			&i.AttachmentType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentOpenAPIv3 = `-- name: GetDeploymentOpenAPIv3 :many
SELECT id, deployment_id, asset_id, name, slug
FROM deployments_openapiv3_assets
WHERE deployment_id = $1
`

func (q *Queries) GetDeploymentOpenAPIv3(ctx context.Context, deploymentID uuid.UUID) ([]DeploymentsOpenapiv3Asset, error) {
	rows, err := q.db.Query(ctx, getDeploymentOpenAPIv3, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentsOpenapiv3Asset
	for rows.Next() {
		var i DeploymentsOpenapiv3Asset
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.AssetID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentWithAssets = `-- name: GetDeploymentWithAssets :many
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
),
openapiv3_tool_counts as (
    SELECT
        deployment_id,
        COUNT(DISTINCT id) as tool_count
    FROM http_tool_definitions
    WHERE deployment_id = $1 AND deleted IS FALSE
    GROUP BY deployment_id
),
functions_tool_counts as (
    SELECT
        deployment_id,
        COUNT(DISTINCT id) as tool_count
    FROM function_tool_definitions
    WHERE deployment_id = $1 AND deleted IS FALSE
    GROUP BY deployment_id
)
SELECT
  deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at,
  coalesce(latest_status.status, 'unknown') as status,
  deployments_openapiv3_assets.id as deployments_openapiv3_asset_id,
  deployments_openapiv3_assets.asset_id as deployments_openapiv3_asset_store_id,
  deployments_openapiv3_assets.name as deployments_openapiv3_asset_name,
  deployments_openapiv3_assets.slug as deployments_openapiv3_asset_slug,
  deployments_functions.id as deployments_functions_id,
  deployments_functions.asset_id as deployments_functions_asset_id,
  deployments_functions.name as deployments_functions_name,
  deployments_functions.slug as deployments_functions_slug,
  deployments_functions.runtime as deployments_functions_runtime,
  deployments_packages.package_id as deployment_package_id,
  packages.name as package_name,
  package_versions.major as package_version_major,
  package_versions.minor as package_version_minor,
  package_versions.patch as package_version_patch,
  package_versions.prerelease as package_version_prerelease,
  package_versions.build as package_version_build,
  COALESCE(openapiv3_tool_counts.tool_count, 0) as openapiv3_tool_count,
  COALESCE(functions_tool_counts.tool_count, 0) as functions_tool_count,
  external_mcp_attachments.id as external_mcp_id,
  external_mcp_attachments.registry_id as external_mcp_registry_id,
  external_mcp_attachments.name as external_mcp_name,
  external_mcp_attachments.slug as external_mcp_slug,
  external_mcp_attachments.registry_server_specifier as external_mcp_registry_server_specifier
FROM deployments
LEFT JOIN deployments_openapiv3_assets ON deployments.id = deployments_openapiv3_assets.deployment_id
LEFT JOIN deployments_functions ON deployments.id = deployments_functions.deployment_id
LEFT JOIN deployments_packages ON deployments.id = deployments_packages.deployment_id
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
LEFT JOIN packages ON deployments_packages.package_id = packages.id
LEFT JOIN package_versions ON deployments_packages.version_id = package_versions.id
LEFT JOIN openapiv3_tool_counts ON deployments.id = openapiv3_tool_counts.deployment_id
LEFT JOIN functions_tool_counts ON deployments.id = functions_tool_counts.deployment_id
LEFT JOIN external_mcp_attachments ON deployments.id = external_mcp_attachments.deployment_id AND external_mcp_attachments.deleted IS FALSE
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentWithAssetsParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentWithAssetsRow struct {
	Deployment                         Deployment
	Status                             string
	DeploymentsOpenapiv3AssetID        uuid.NullUUID
	DeploymentsOpenapiv3AssetStoreID   uuid.NullUUID
	DeploymentsOpenapiv3AssetName      pgtype.Text
	DeploymentsOpenapiv3AssetSlug      pgtype.Text
	DeploymentsFunctionsID             uuid.NullUUID
	DeploymentsFunctionsAssetID        uuid.NullUUID
	DeploymentsFunctionsName           pgtype.Text
	DeploymentsFunctionsSlug           pgtype.Text
	DeploymentsFunctionsRuntime        pgtype.Text
	DeploymentPackageID                uuid.NullUUID
	PackageName                        pgtype.Text
	PackageVersionMajor                pgtype.Int8
	PackageVersionMinor                pgtype.Int8
	PackageVersionPatch                pgtype.Int8
	PackageVersionPrerelease           pgtype.Text
	PackageVersionBuild                pgtype.Text
	Openapiv3ToolCount                 int64
	FunctionsToolCount                 int64
	ExternalMcpID                      uuid.NullUUID
	ExternalMcpRegistryID              uuid.NullUUID
	ExternalMcpName                    pgtype.Text
	ExternalMcpSlug                    pgtype.Text
	ExternalMcpRegistryServerSpecifier pgtype.Text
}

func (q *Queries) GetDeploymentWithAssets(ctx context.Context, arg GetDeploymentWithAssetsParams) ([]GetDeploymentWithAssetsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentWithAssets, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentWithAssetsRow
	for rows.Next() {
		var i GetDeploymentWithAssetsRow
		if err := rows.Scan(
			&i.Deployment.ID,
			&i.Deployment.Seq,
			&i.Deployment.UserID,
			&i.Deployment.ProjectID,
			&i.Deployment.OrganizationID,
			&i.Deployment.IdempotencyKey,
			&i.Deployment.ClonedFrom,
			&i.Deployment.GithubRepo,
			&i.Deployment.GithubPr,
			&i.Deployment.GithubSha,
			&i.Deployment.ExternalID,
			&i.Deployment.ExternalUrl,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.Status,
			&i.DeploymentsOpenapiv3AssetID,
			&i.DeploymentsOpenapiv3AssetStoreID,
			&i.DeploymentsOpenapiv3AssetName,
			&i.DeploymentsOpenapiv3AssetSlug,
			&i.DeploymentsFunctionsID,
			&i.DeploymentsFunctionsAssetID,
			&i.DeploymentsFunctionsName,
			&i.DeploymentsFunctionsSlug,
			&i.DeploymentsFunctionsRuntime,
			&i.DeploymentPackageID,
			&i.PackageName,
			&i.PackageVersionMajor,
			&i.PackageVersionMinor,
			&i.PackageVersionPatch,
			&i.PackageVersionPrerelease,
			&i.PackageVersionBuild,
			&i.Openapiv3ToolCount,
			&i.FunctionsToolCount,
			&i.ExternalMcpID,
			&i.ExternalMcpRegistryID,
			&i.ExternalMcpName,
			&i.ExternalMcpSlug,
			&i.ExternalMcpRegistryServerSpecifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionCredentialsBatch = `-- name: GetFunctionCredentialsBatch :many
SELECT DISTINCT ON (function_id)
  id,
  function_id,
  encryption_key,
  bearer_format
FROM functions_access
WHERE project_id = $1
  AND deployment_id = $2
  AND function_id = ANY($3::uuid[])
  AND deleted IS FALSE
ORDER BY function_id, seq DESC
`

type GetFunctionCredentialsBatchParams struct {
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionIds  []uuid.UUID
}

type GetFunctionCredentialsBatchRow struct {
	ID            uuid.UUID
	FunctionID    uuid.UUID
	EncryptionKey conv.Secret
	BearerFormat  pgtype.Text
}

func (q *Queries) GetFunctionCredentialsBatch(ctx context.Context, arg GetFunctionCredentialsBatchParams) ([]GetFunctionCredentialsBatchRow, error) {
	rows, err := q.db.Query(ctx, getFunctionCredentialsBatch, arg.ProjectID, arg.DeploymentID, arg.FunctionIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFunctionCredentialsBatchRow
	for rows.Next() {
		var i GetFunctionCredentialsBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.FunctionID,
			&i.EncryptionKey,
			&i.BearerFormat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDeploymentID = `-- name: GetLatestDeploymentID :one
SELECT id
FROM deployments
WHERE project_id = $1
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetLatestDeploymentID(ctx context.Context, projectID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getLatestDeploymentID, projectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listDeploymentExternalMCPs = `-- name: ListDeploymentExternalMCPs :many
SELECT id, deployment_id, registry_id, name, slug, registry_server_specifier, created_at, updated_at
FROM external_mcp_attachments
WHERE deployment_id = $1 AND deleted IS FALSE
ORDER BY created_at ASC
`

type ListDeploymentExternalMCPsRow struct {
	ID                      uuid.UUID
	DeploymentID            uuid.UUID
	RegistryID              uuid.UUID
	Name                    string
	Slug                    string
	RegistryServerSpecifier string
	CreatedAt               pgtype.Timestamptz
	UpdatedAt               pgtype.Timestamptz
}

func (q *Queries) ListDeploymentExternalMCPs(ctx context.Context, deploymentID uuid.UUID) ([]ListDeploymentExternalMCPsRow, error) {
	rows, err := q.db.Query(ctx, listDeploymentExternalMCPs, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentExternalMCPsRow
	for rows.Next() {
		var i ListDeploymentExternalMCPsRow
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.RegistryID,
			&i.Name,
			&i.Slug,
			&i.RegistryServerSpecifier,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeployments = `-- name: ListDeployments :many
WITH latest_statuses AS (
  SELECT DISTINCT ON (deployment_id) deployment_id, status
  FROM deployment_statuses
  WHERE deployment_id IN (
    SELECT id FROM deployments WHERE project_id = $1
  )
  ORDER BY deployment_id, seq DESC
)
SELECT 
  d.id,
  d.user_id,
  d.created_at,
  COALESCE(ls.status, 'unknown') as status,
  COUNT(DISTINCT doa.id) as openapiv3_asset_count,
  COUNT(DISTINCT htd.id) as openapiv3_tool_count,
  COUNT(DISTINCT tf.function_id) as functions_asset_count,
  COUNT(DISTINCT tf.id) as functions_tool_count
FROM deployments d
LEFT JOIN latest_statuses ls ON d.id = ls.deployment_id
LEFT JOIN deployments_openapiv3_assets doa ON d.id = doa.deployment_id
LEFT JOIN http_tool_definitions htd ON d.id = htd.deployment_id AND htd.deleted IS FALSE
LEFT JOIN function_tool_definitions tf ON d.id = tf.deployment_id AND tf.deleted IS FALSE
WHERE
  d.project_id = $1
  AND d.id <= CASE 
    WHEN $2::uuid IS NOT NULL THEN $2::uuid
    ELSE (SELECT id FROM deployments WHERE project_id = $1 ORDER BY id DESC LIMIT 1)
  END
GROUP BY d.id, ls.status
ORDER BY d.id DESC
LIMIT 51
`

type ListDeploymentsParams struct {
	ProjectID uuid.UUID
	Cursor    uuid.NullUUID
}

type ListDeploymentsRow struct {
	ID                  uuid.UUID
	UserID              string
	CreatedAt           pgtype.Timestamptz
	Status              string
	Openapiv3AssetCount int64
	Openapiv3ToolCount  int64
	FunctionsAssetCount int64
	FunctionsToolCount  int64
}

func (q *Queries) ListDeployments(ctx context.Context, arg ListDeploymentsParams) ([]ListDeploymentsRow, error) {
	rows, err := q.db.Query(ctx, listDeployments, arg.ProjectID, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentsRow
	for rows.Next() {
		var i ListDeploymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.Status,
			&i.Openapiv3AssetCount,
			&i.Openapiv3ToolCount,
			&i.FunctionsAssetCount,
			&i.FunctionsToolCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logDeploymentEvent = `-- name: LogDeploymentEvent :exec
INSERT INTO deployment_logs (deployment_id, project_id, event, message, attachment_id, attachment_type)
VALUES ($1, $2, $3, $4, $5, $6)
`

type LogDeploymentEventParams struct {
	DeploymentID   uuid.UUID
	ProjectID      uuid.UUID
	Event          string
	Message        string
	AttachmentID   uuid.NullUUID
	AttachmentType pgtype.Text
}

func (q *Queries) LogDeploymentEvent(ctx context.Context, arg LogDeploymentEventParams) error {
	_, err := q.db.Exec(ctx, logDeploymentEvent,
		arg.DeploymentID,
		arg.ProjectID,
		arg.Event,
		arg.Message,
		arg.AttachmentID,
		arg.AttachmentType,
	)
	return err
}

const transitionDeployment = `-- name: TransitionDeployment :one
WITH current_status AS (
  SELECT 0 as state, id, deployment_id, status
  FROM deployment_statuses as d
  WHERE d.deployment_id = $1
  ORDER BY d.seq DESC
  LIMIT 1
),
status_update AS (
  INSERT INTO deployment_statuses (deployment_id, status)
  SELECT $1, $2
  WHERE (
    CASE
      WHEN $2 = 'created' THEN NOT EXISTS (SELECT 1 FROM current_status)
      WHEN $2 = 'pending' THEN EXISTS (SELECT 1 FROM current_status WHERE status = 'created')
      WHEN $2 = 'failed' THEN EXISTS (SELECT 1 FROM current_status WHERE status = 'pending')
      WHEN $2 = 'completed' THEN EXISTS (SELECT 1 FROM current_status WHERE status = 'pending')
      ELSE FALSE
    END
  )
  LIMIT 1
  RETURNING 1 as state, id, deployment_id, status
),
new_log AS (
  INSERT INTO deployment_logs (deployment_id, project_id, event, message)
  SELECT $1, $3, $4, $5
  WHERE EXISTS (SELECT 1 FROM status_update)
  RETURNING id
),
all_statuses AS (
  SELECT state, id, deployment_id, status FROM status_update
  UNION ALL
  SELECT state, id, deployment_id, status FROM current_status
)
SELECT 
    all_statuses.id as status_id
  , all_statuses.status as status
  , (CASE 
      WHEN all_statuses.state = 1 THEN TRUE
      ELSE FALSE
    END) as moved
FROM all_statuses
ORDER BY all_statuses.state DESC
LIMIT 1
`

type TransitionDeploymentParams struct {
	DeploymentID uuid.UUID
	Status       string
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

type TransitionDeploymentRow struct {
	StatusID uuid.UUID
	Status   string
	Moved    bool
}

func (q *Queries) TransitionDeployment(ctx context.Context, arg TransitionDeploymentParams) (TransitionDeploymentRow, error) {
	row := q.db.QueryRow(ctx, transitionDeployment,
		arg.DeploymentID,
		arg.Status,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	var i TransitionDeploymentRow
	err := row.Scan(&i.StatusID, &i.Status, &i.Moved)
	return i, err
}

const upsertDeploymentExternalMCP = `-- name: UpsertDeploymentExternalMCP :one
INSERT INTO external_mcp_attachments (deployment_id, registry_id, name, slug, registry_server_specifier)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (deployment_id, slug) WHERE deleted IS FALSE
DO UPDATE SET
  registry_id = EXCLUDED.registry_id,
  name = EXCLUDED.name,
  registry_server_specifier = EXCLUDED.registry_server_specifier,
  updated_at = clock_timestamp()
RETURNING id, deployment_id, registry_id, name, slug, registry_server_specifier, created_at, updated_at
`

type UpsertDeploymentExternalMCPParams struct {
	DeploymentID            uuid.UUID
	RegistryID              uuid.UUID
	Name                    string
	Slug                    string
	RegistryServerSpecifier string
}

type UpsertDeploymentExternalMCPRow struct {
	ID                      uuid.UUID
	DeploymentID            uuid.UUID
	RegistryID              uuid.UUID
	Name                    string
	Slug                    string
	RegistryServerSpecifier string
	CreatedAt               pgtype.Timestamptz
	UpdatedAt               pgtype.Timestamptz
}

func (q *Queries) UpsertDeploymentExternalMCP(ctx context.Context, arg UpsertDeploymentExternalMCPParams) (UpsertDeploymentExternalMCPRow, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentExternalMCP,
		arg.DeploymentID,
		arg.RegistryID,
		arg.Name,
		arg.Slug,
		arg.RegistryServerSpecifier,
	)
	var i UpsertDeploymentExternalMCPRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.RegistryID,
		&i.Name,
		&i.Slug,
		&i.RegistryServerSpecifier,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertDeploymentFunctionsAsset = `-- name: UpsertDeploymentFunctionsAsset :one
INSERT INTO deployments_functions (
  deployment_id
  , asset_id
  , name
  , slug
  , runtime
) VALUES (
  $1
  , $2
  , $3
  , $4
  , $5
)
ON CONFLICT (deployment_id, slug) DO UPDATE
SET
  asset_id = EXCLUDED.asset_id
  , name = EXCLUDED.name
  , runtime = EXCLUDED.runtime
RETURNING id, asset_id, name, slug
`

type UpsertDeploymentFunctionsAssetParams struct {
	DeploymentID uuid.UUID
	AssetID      uuid.UUID
	Name         string
	Slug         string
	Runtime      string
}

type UpsertDeploymentFunctionsAssetRow struct {
	ID      uuid.UUID
	AssetID uuid.UUID
	Name    string
	Slug    string
}

func (q *Queries) UpsertDeploymentFunctionsAsset(ctx context.Context, arg UpsertDeploymentFunctionsAssetParams) (UpsertDeploymentFunctionsAssetRow, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentFunctionsAsset,
		arg.DeploymentID,
		arg.AssetID,
		arg.Name,
		arg.Slug,
		arg.Runtime,
	)
	var i UpsertDeploymentFunctionsAssetRow
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.Name,
		&i.Slug,
	)
	return i, err
}

const upsertDeploymentOpenAPIv3Asset = `-- name: UpsertDeploymentOpenAPIv3Asset :one
INSERT INTO deployments_openapiv3_assets (
  deployment_id,
  asset_id,
  name,
  slug
) VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT (deployment_id, slug) DO UPDATE
SET
  asset_id = EXCLUDED.asset_id,
  name = EXCLUDED.name
RETURNING id, asset_id, name, slug
`

type UpsertDeploymentOpenAPIv3AssetParams struct {
	DeploymentID uuid.UUID
	AssetID      uuid.UUID
	Name         string
	Slug         string
}

type UpsertDeploymentOpenAPIv3AssetRow struct {
	ID      uuid.UUID
	AssetID uuid.UUID
	Name    string
	Slug    string
}

func (q *Queries) UpsertDeploymentOpenAPIv3Asset(ctx context.Context, arg UpsertDeploymentOpenAPIv3AssetParams) (UpsertDeploymentOpenAPIv3AssetRow, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentOpenAPIv3Asset,
		arg.DeploymentID,
		arg.AssetID,
		arg.Name,
		arg.Slug,
	)
	var i UpsertDeploymentOpenAPIv3AssetRow
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.Name,
		&i.Slug,
	)
	return i, err
}

const upsertDeploymentPackage = `-- name: UpsertDeploymentPackage :one
INSERT INTO deployments_packages (
  deployment_id
  , package_id
  , version_id
) VALUES (
  $1,
  $2,
  $3
)
ON CONFLICT (deployment_id, package_id) DO UPDATE
SET
  version_id = EXCLUDED.version_id
RETURNING id
`

type UpsertDeploymentPackageParams struct {
	DeploymentID uuid.UUID
	PackageID    uuid.UUID
	VersionID    uuid.UUID
}

func (q *Queries) UpsertDeploymentPackage(ctx context.Context, arg UpsertDeploymentPackageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentPackage, arg.DeploymentID, arg.PackageID, arg.VersionID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
