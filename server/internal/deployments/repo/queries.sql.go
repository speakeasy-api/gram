// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/tools/repo/models"
)

type BatchLogEventsParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

const cloneDeployment = `-- name: CloneDeployment :one
INSERT INTO deployments (
  cloned_from
  , idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , github_sha
  , external_id
  , external_url
)
SELECT
  current.id
  , gen_random_uuid()
  , current.user_id
  , current.organization_id
  , current.project_id
  , current.github_repo
  , current.github_pr
  , current.github_sha
  , current.external_id
  , current.external_url
FROM deployments as current
WHERE current.id = $1 AND current.project_id = $2
RETURNING id
`

type CloneDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) CloneDeployment(ctx context.Context, arg CloneDeploymentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, cloneDeployment, arg.ID, arg.ProjectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const cloneDeploymentOpenAPIv3Assets = `-- name: CloneDeploymentOpenAPIv3Assets :many
INSERT INTO deployments_openapiv3_assets (
  deployment_id
  , asset_id
  , name
  , slug
)
SELECT 
  $1
  , current.asset_id
  , current.name
  , current.slug
FROM deployments_openapiv3_assets as current
WHERE current.deployment_id = $2
  AND current.asset_id <> ALL ($3::uuid[])
RETURNING id
`

type CloneDeploymentOpenAPIv3AssetsParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

func (q *Queries) CloneDeploymentOpenAPIv3Assets(ctx context.Context, arg CloneDeploymentOpenAPIv3AssetsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentOpenAPIv3Assets, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cloneDeploymentPackages = `-- name: CloneDeploymentPackages :many
INSERT INTO deployments_packages (
  deployment_id
  , package_id
  , version_id
)
SELECT 
  $1
  , current.package_id
  , current.version_id
FROM deployments_packages as current
WHERE current.deployment_id = $2
  AND current.package_id <> ALL ($3::uuid[])
RETURNING id, package_id, version_id
`

type CloneDeploymentPackagesParams struct {
	CloneDeploymentID    uuid.UUID
	OriginalDeploymentID uuid.UUID
	ExcludedIds          []uuid.UUID
}

type CloneDeploymentPackagesRow struct {
	ID        uuid.UUID
	PackageID uuid.UUID
	VersionID uuid.UUID
}

func (q *Queries) CloneDeploymentPackages(ctx context.Context, arg CloneDeploymentPackagesParams) ([]CloneDeploymentPackagesRow, error) {
	rows, err := q.db.Query(ctx, cloneDeploymentPackages, arg.CloneDeploymentID, arg.OriginalDeploymentID, arg.ExcludedIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CloneDeploymentPackagesRow
	for rows.Next() {
		var i CloneDeploymentPackagesRow
		if err := rows.Scan(&i.ID, &i.PackageID, &i.VersionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createDeployment = `-- name: CreateDeployment :execresult
INSERT INTO deployments (
  idempotency_key
  , user_id
  , organization_id
  , project_id
  , github_repo
  , github_pr
  , github_sha
  , external_id
  , external_url
) VALUES (
  $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
)
ON CONFLICT (project_id, idempotency_key) DO NOTHING
`

type CreateDeploymentParams struct {
	IdempotencyKey string
	UserID         string
	OrganizationID string
	ProjectID      uuid.UUID
	GithubRepo     pgtype.Text
	GithubPr       pgtype.Text
	GithubSha      pgtype.Text
	ExternalID     pgtype.Text
	ExternalUrl    pgtype.Text
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, createDeployment,
		arg.IdempotencyKey,
		arg.UserID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.GithubRepo,
		arg.GithubPr,
		arg.GithubSha,
		arg.ExternalID,
		arg.ExternalUrl,
	)
}

const createHTTPSecurity = `-- name: CreateHTTPSecurity :one
INSERT INTO http_security (
    key
  , deployment_id
  , project_id
  , openapiv3_document_id
  , type
  , name
  , in_placement
  , scheme
  , bearer_format
  , env_variables
  , oauth_types
  , oauth_flows
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
)
RETURNING id, deployment_id, project_id, openapiv3_document_id, key, type, name, in_placement, scheme, bearer_format, oauth_types, oauth_flows, env_variables, created_at, updated_at, deleted_at, deleted
`

type CreateHTTPSecurityParams struct {
	Key                 string
	DeploymentID        uuid.UUID
	ProjectID           uuid.NullUUID
	Openapiv3DocumentID uuid.NullUUID
	Type                pgtype.Text
	Name                pgtype.Text
	InPlacement         pgtype.Text
	Scheme              pgtype.Text
	BearerFormat        pgtype.Text
	EnvVariables        []string
	OauthTypes          []string
	OauthFlows          []byte
}

func (q *Queries) CreateHTTPSecurity(ctx context.Context, arg CreateHTTPSecurityParams) (HttpSecurity, error) {
	row := q.db.QueryRow(ctx, createHTTPSecurity,
		arg.Key,
		arg.DeploymentID,
		arg.ProjectID,
		arg.Openapiv3DocumentID,
		arg.Type,
		arg.Name,
		arg.InPlacement,
		arg.Scheme,
		arg.BearerFormat,
		arg.EnvVariables,
		arg.OauthTypes,
		arg.OauthFlows,
	)
	var i HttpSecurity
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.ProjectID,
		&i.Openapiv3DocumentID,
		&i.Key,
		&i.Type,
		&i.Name,
		&i.InPlacement,
		&i.Scheme,
		&i.BearerFormat,
		&i.OauthTypes,
		&i.OauthFlows,
		&i.EnvVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const createOpenAPIv3ToolDefinition = `-- name: CreateOpenAPIv3ToolDefinition :one
INSERT INTO http_tool_definitions (
    project_id
  , deployment_id
  , openapiv3_document_id
  , name
  , untruncated_name
  , openapiv3_operation
  , summary
  , description
  , tags
  , confirm
  , confirm_prompt
  , x_gram
  , original_name
  , original_summary
  , original_description
  , security
  , http_method
  , path
  , schema_version
  , schema
  , header_settings
  , query_settings
  , path_settings
  , server_env_var
  , default_server_url
  , request_content_type
  , response_filter
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , $11
  , $12
  , $13
  , $14
  , $15
  , $16
  , $17
  , $18
  , $19
  , $20
  , $21
  , $22
  , $23
  , $24
  , $25
  , $26
  , $27
)
RETURNING id, project_id, deployment_id, openapiv3_document_id, confirm, confirm_prompt, summarizer, name, untruncated_name, summary, description, openapiv3_operation, tags, x_gram, original_name, original_summary, original_description, server_env_var, default_server_url, security, http_method, path, schema_version, schema, header_settings, query_settings, path_settings, request_content_type, response_filter, created_at, updated_at, deleted_at, deleted
`

type CreateOpenAPIv3ToolDefinitionParams struct {
	ProjectID           uuid.UUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.NullUUID
	Name                string
	UntruncatedName     pgtype.Text
	Openapiv3Operation  pgtype.Text
	Summary             string
	Description         string
	Tags                []string
	Confirm             pgtype.Text
	ConfirmPrompt       pgtype.Text
	XGram               pgtype.Bool
	OriginalName        pgtype.Text
	OriginalSummary     pgtype.Text
	OriginalDescription pgtype.Text
	Security            []byte
	HttpMethod          string
	Path                string
	SchemaVersion       string
	Schema              []byte
	HeaderSettings      []byte
	QuerySettings       []byte
	PathSettings        []byte
	ServerEnvVar        string
	DefaultServerUrl    pgtype.Text
	RequestContentType  pgtype.Text
	ResponseFilter      *models.ResponseFilter
}

func (q *Queries) CreateOpenAPIv3ToolDefinition(ctx context.Context, arg CreateOpenAPIv3ToolDefinitionParams) (HttpToolDefinition, error) {
	row := q.db.QueryRow(ctx, createOpenAPIv3ToolDefinition,
		arg.ProjectID,
		arg.DeploymentID,
		arg.Openapiv3DocumentID,
		arg.Name,
		arg.UntruncatedName,
		arg.Openapiv3Operation,
		arg.Summary,
		arg.Description,
		arg.Tags,
		arg.Confirm,
		arg.ConfirmPrompt,
		arg.XGram,
		arg.OriginalName,
		arg.OriginalSummary,
		arg.OriginalDescription,
		arg.Security,
		arg.HttpMethod,
		arg.Path,
		arg.SchemaVersion,
		arg.Schema,
		arg.HeaderSettings,
		arg.QuerySettings,
		arg.PathSettings,
		arg.ServerEnvVar,
		arg.DefaultServerUrl,
		arg.RequestContentType,
		arg.ResponseFilter,
	)
	var i HttpToolDefinition
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.DeploymentID,
		&i.Openapiv3DocumentID,
		&i.Confirm,
		&i.ConfirmPrompt,
		&i.Summarizer,
		&i.Name,
		&i.UntruncatedName,
		&i.Summary,
		&i.Description,
		&i.Openapiv3Operation,
		&i.Tags,
		&i.XGram,
		&i.OriginalName,
		&i.OriginalSummary,
		&i.OriginalDescription,
		&i.ServerEnvVar,
		&i.DefaultServerUrl,
		&i.Security,
		&i.HttpMethod,
		&i.Path,
		&i.SchemaVersion,
		&i.Schema,
		&i.HeaderSettings,
		&i.QuerySettings,
		&i.PathSettings,
		&i.RequestContentType,
		&i.ResponseFilter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const dangerouslyClearDeploymentHTTPSecurity = `-- name: DangerouslyClearDeploymentHTTPSecurity :execrows
DELETE FROM http_security
WHERE
  project_id = $1
  AND (deployment_id = $2 AND deployment_id IS NOT NULL)
  AND (openapiv3_document_id = $3 AND openapiv3_document_id IS NOT NULL)
`

type DangerouslyClearDeploymentHTTPSecurityParams struct {
	ProjectID           uuid.NullUUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.NullUUID
}

func (q *Queries) DangerouslyClearDeploymentHTTPSecurity(ctx context.Context, arg DangerouslyClearDeploymentHTTPSecurityParams) (int64, error) {
	result, err := q.db.Exec(ctx, dangerouslyClearDeploymentHTTPSecurity, arg.ProjectID, arg.DeploymentID, arg.Openapiv3DocumentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dangerouslyClearDeploymentTools = `-- name: DangerouslyClearDeploymentTools :execrows
DELETE FROM http_tool_definitions
WHERE
  project_id = $1
  AND deployment_id = $2
  AND openapiv3_document_id = $3::uuid
`

type DangerouslyClearDeploymentToolsParams struct {
	ProjectID           uuid.UUID
	DeploymentID        uuid.UUID
	Openapiv3DocumentID uuid.UUID
}

func (q *Queries) DangerouslyClearDeploymentTools(ctx context.Context, arg DangerouslyClearDeploymentToolsParams) (int64, error) {
	result, err := q.db.Exec(ctx, dangerouslyClearDeploymentTools, arg.ProjectID, arg.DeploymentID, arg.Openapiv3DocumentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const describeDeploymentPackages = `-- name: DescribeDeploymentPackages :many
SELECT 
  deployments_packages.id as deployment_package_id
  , packages.name as package_name
  , package_versions.id, package_versions.package_id, package_versions.deployment_id, package_versions.visibility, package_versions.major, package_versions.minor, package_versions.patch, package_versions.prerelease, package_versions.build, package_versions.created_at, package_versions.updated_at, package_versions.deleted_at, package_versions.deleted
FROM deployments_packages
INNER JOIN packages ON deployments_packages.package_id = packages.id
INNER JOIN package_versions ON deployments_packages.version_id = package_versions.id
WHERE deployments_packages.deployment_id = $1
`

type DescribeDeploymentPackagesRow struct {
	DeploymentPackageID uuid.UUID
	PackageName         string
	PackageVersion      PackageVersion
}

func (q *Queries) DescribeDeploymentPackages(ctx context.Context, deploymentID uuid.UUID) ([]DescribeDeploymentPackagesRow, error) {
	rows, err := q.db.Query(ctx, describeDeploymentPackages, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DescribeDeploymentPackagesRow
	for rows.Next() {
		var i DescribeDeploymentPackagesRow
		if err := rows.Scan(
			&i.DeploymentPackageID,
			&i.PackageName,
			&i.PackageVersion.ID,
			&i.PackageVersion.PackageID,
			&i.PackageVersion.DeploymentID,
			&i.PackageVersion.Visibility,
			&i.PackageVersion.Major,
			&i.PackageVersion.Minor,
			&i.PackageVersion.Patch,
			&i.PackageVersion.Prerelease,
			&i.PackageVersion.Build,
			&i.PackageVersion.CreatedAt,
			&i.PackageVersion.UpdatedAt,
			&i.PackageVersion.DeletedAt,
			&i.PackageVersion.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeployment = `-- name: GetDeployment :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeployment(ctx context.Context, arg GetDeploymentParams) (GetDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getDeployment, arg.ID, arg.ProjectID)
	var i GetDeploymentRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.ClonedFrom,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentByIdempotencyKey = `-- name: GetDeploymentByIdempotencyKey :one
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    INNER JOIN deployments ON deployment_statuses.deployment_id = deployments.id
    WHERE deployments.idempotency_key = $1
    ORDER BY deployment_statuses.seq DESC
    LIMIT 1
)
SELECT deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at, coalesce(latest_status.status, 'unknown') as status
FROM deployments
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
WHERE deployments.idempotency_key = $1
 AND deployments.project_id = $2
`

type GetDeploymentByIdempotencyKeyParams struct {
	IdempotencyKey string
	ProjectID      uuid.UUID
}

type GetDeploymentByIdempotencyKeyRow struct {
	Deployment Deployment
	Status     string
}

func (q *Queries) GetDeploymentByIdempotencyKey(ctx context.Context, arg GetDeploymentByIdempotencyKeyParams) (GetDeploymentByIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getDeploymentByIdempotencyKey, arg.IdempotencyKey, arg.ProjectID)
	var i GetDeploymentByIdempotencyKeyRow
	err := row.Scan(
		&i.Deployment.ID,
		&i.Deployment.Seq,
		&i.Deployment.UserID,
		&i.Deployment.ProjectID,
		&i.Deployment.OrganizationID,
		&i.Deployment.IdempotencyKey,
		&i.Deployment.ClonedFrom,
		&i.Deployment.GithubRepo,
		&i.Deployment.GithubPr,
		&i.Deployment.GithubSha,
		&i.Deployment.ExternalID,
		&i.Deployment.ExternalUrl,
		&i.Deployment.CreatedAt,
		&i.Deployment.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getDeploymentLogs = `-- name: GetDeploymentLogs :many
WITH latest_status as (
    SELECT s.status
    FROM deployment_statuses s
    WHERE s.deployment_id = $1
    ORDER BY s.seq DESC
    LIMIT 1
)
SELECT
  coalesce((select status from latest_status), 'unknown')::text as status,
  log.id,
  log.event,
  log.message,
  log.created_at
FROM deployment_logs log
WHERE
  log.deployment_id = $1 AND log.project_id = $2
  AND log.id >= CASE 
    WHEN $3::uuid IS NOT NULL THEN $3::uuid
    ELSE (
      SELECT dl.id
      FROM deployment_logs dl
      WHERE dl.deployment_id = $1 AND dl.project_id = $2
      ORDER BY dl.id ASC LIMIT 1
    )
  END
ORDER BY log.id ASC
LIMIT 51
`

type GetDeploymentLogsParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
	Cursor       uuid.NullUUID
}

type GetDeploymentLogsRow struct {
	Status    string
	ID        uuid.UUID
	Event     string
	Message   string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetDeploymentLogs(ctx context.Context, arg GetDeploymentLogsParams) ([]GetDeploymentLogsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentLogs, arg.DeploymentID, arg.ProjectID, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentLogsRow
	for rows.Next() {
		var i GetDeploymentLogsRow
		if err := rows.Scan(
			&i.Status,
			&i.ID,
			&i.Event,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentOpenAPIv3 = `-- name: GetDeploymentOpenAPIv3 :many
SELECT id, deployment_id, asset_id, name, slug
FROM deployments_openapiv3_assets
WHERE deployment_id = $1
`

func (q *Queries) GetDeploymentOpenAPIv3(ctx context.Context, deploymentID uuid.UUID) ([]DeploymentsOpenapiv3Asset, error) {
	rows, err := q.db.Query(ctx, getDeploymentOpenAPIv3, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentsOpenapiv3Asset
	for rows.Next() {
		var i DeploymentsOpenapiv3Asset
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.AssetID,
			&i.Name,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentWithAssets = `-- name: GetDeploymentWithAssets :many
WITH latest_status as (
    SELECT deployment_id, status
    FROM deployment_statuses
    WHERE deployment_id = $1
    ORDER BY seq DESC
    LIMIT 1
),
tool_counts as (
    SELECT 
        deployment_id,
        COUNT(DISTINCT id) as tool_count
    FROM http_tool_definitions 
    WHERE deployment_id = $1 AND deleted IS FALSE
    GROUP BY deployment_id
)
SELECT
  deployments.id, deployments.seq, deployments.user_id, deployments.project_id, deployments.organization_id, deployments.idempotency_key, deployments.cloned_from, deployments.github_repo, deployments.github_pr, deployments.github_sha, deployments.external_id, deployments.external_url, deployments.created_at, deployments.updated_at,
  coalesce(latest_status.status, 'unknown') as status,
  deployments_openapiv3_assets.id as deployments_openapiv3_asset_id,
  deployments_openapiv3_assets.asset_id as deployments_openapiv3_asset_store_id,
  deployments_openapiv3_assets.name as deployments_openapiv3_asset_name,
  deployments_openapiv3_assets.slug as deployments_openapiv3_asset_slug,
  deployments_packages.package_id as deployment_package_id,
  packages.name as package_name,
  package_versions.major as package_version_major,
  package_versions.minor as package_version_minor,
  package_versions.patch as package_version_patch,
  package_versions.prerelease as package_version_prerelease,
  package_versions.build as package_version_build,
  COALESCE(tool_counts.tool_count, 0) as tool_count
FROM deployments
LEFT JOIN deployments_openapiv3_assets ON deployments.id = deployments_openapiv3_assets.deployment_id
LEFT JOIN deployments_packages ON deployments.id = deployments_packages.deployment_id
LEFT JOIN latest_status ON deployments.id = latest_status.deployment_id
LEFT JOIN packages ON deployments_packages.package_id = packages.id
LEFT JOIN package_versions ON deployments_packages.version_id = package_versions.id
LEFT JOIN tool_counts ON deployments.id = tool_counts.deployment_id
WHERE deployments.id = $1 AND deployments.project_id = $2
`

type GetDeploymentWithAssetsParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetDeploymentWithAssetsRow struct {
	Deployment                       Deployment
	Status                           string
	DeploymentsOpenapiv3AssetID      uuid.NullUUID
	DeploymentsOpenapiv3AssetStoreID uuid.NullUUID
	DeploymentsOpenapiv3AssetName    pgtype.Text
	DeploymentsOpenapiv3AssetSlug    pgtype.Text
	DeploymentPackageID              uuid.NullUUID
	PackageName                      pgtype.Text
	PackageVersionMajor              pgtype.Int8
	PackageVersionMinor              pgtype.Int8
	PackageVersionPatch              pgtype.Int8
	PackageVersionPrerelease         pgtype.Text
	PackageVersionBuild              pgtype.Text
	ToolCount                        int64
}

func (q *Queries) GetDeploymentWithAssets(ctx context.Context, arg GetDeploymentWithAssetsParams) ([]GetDeploymentWithAssetsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentWithAssets, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentWithAssetsRow
	for rows.Next() {
		var i GetDeploymentWithAssetsRow
		if err := rows.Scan(
			&i.Deployment.ID,
			&i.Deployment.Seq,
			&i.Deployment.UserID,
			&i.Deployment.ProjectID,
			&i.Deployment.OrganizationID,
			&i.Deployment.IdempotencyKey,
			&i.Deployment.ClonedFrom,
			&i.Deployment.GithubRepo,
			&i.Deployment.GithubPr,
			&i.Deployment.GithubSha,
			&i.Deployment.ExternalID,
			&i.Deployment.ExternalUrl,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.Status,
			&i.DeploymentsOpenapiv3AssetID,
			&i.DeploymentsOpenapiv3AssetStoreID,
			&i.DeploymentsOpenapiv3AssetName,
			&i.DeploymentsOpenapiv3AssetSlug,
			&i.DeploymentPackageID,
			&i.PackageName,
			&i.PackageVersionMajor,
			&i.PackageVersionMinor,
			&i.PackageVersionPatch,
			&i.PackageVersionPrerelease,
			&i.PackageVersionBuild,
			&i.ToolCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDeploymentID = `-- name: GetLatestDeploymentID :one
SELECT id
FROM deployments
WHERE project_id = $1
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetLatestDeploymentID(ctx context.Context, projectID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getLatestDeploymentID, projectID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listDeployments = `-- name: ListDeployments :many
WITH latest_statuses AS (
  SELECT DISTINCT ON (deployment_id) deployment_id, status
  FROM deployment_statuses
  WHERE deployment_id IN (
    SELECT id FROM deployments WHERE project_id = $1
  )
  ORDER BY deployment_id, seq DESC
)
SELECT 
  d.id,
  d.user_id,
  d.created_at,
  COALESCE(ls.status, 'unknown') as status,
  COUNT(DISTINCT doa.id) as asset_count,
  COUNT(DISTINCT htd.id) as tool_count
FROM deployments d
LEFT JOIN latest_statuses ls ON d.id = ls.deployment_id
LEFT JOIN deployments_openapiv3_assets doa ON d.id = doa.deployment_id
LEFT JOIN http_tool_definitions htd ON d.id = htd.deployment_id AND htd.deleted IS FALSE
WHERE
  d.project_id = $1
  AND d.id <= CASE 
    WHEN $2::uuid IS NOT NULL THEN $2::uuid
    ELSE (SELECT id FROM deployments WHERE project_id = $1 ORDER BY id DESC LIMIT 1)
  END
GROUP BY d.id, ls.status
ORDER BY d.id DESC
LIMIT 51
`

type ListDeploymentsParams struct {
	ProjectID uuid.UUID
	Cursor    uuid.NullUUID
}

type ListDeploymentsRow struct {
	ID         uuid.UUID
	UserID     string
	CreatedAt  pgtype.Timestamptz
	Status     string
	AssetCount int64
	ToolCount  int64
}

func (q *Queries) ListDeployments(ctx context.Context, arg ListDeploymentsParams) ([]ListDeploymentsRow, error) {
	rows, err := q.db.Query(ctx, listDeployments, arg.ProjectID, arg.Cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentsRow
	for rows.Next() {
		var i ListDeploymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.Status,
			&i.AssetCount,
			&i.ToolCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logDeploymentEvent = `-- name: LogDeploymentEvent :exec
INSERT INTO deployment_logs (deployment_id, project_id, event, message)
VALUES ($1, $2, $3, $4)
`

type LogDeploymentEventParams struct {
	DeploymentID uuid.UUID
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

func (q *Queries) LogDeploymentEvent(ctx context.Context, arg LogDeploymentEventParams) error {
	_, err := q.db.Exec(ctx, logDeploymentEvent,
		arg.DeploymentID,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	return err
}

const transitionDeployment = `-- name: TransitionDeployment :one
WITH current_status AS (
  SELECT 0 as state, id, deployment_id, status
  FROM deployment_statuses as d
  WHERE d.deployment_id = $1
  ORDER BY d.seq DESC
  LIMIT 1
),
status_update AS (
  INSERT INTO deployment_statuses (deployment_id, status)
  SELECT $1, $2
  WHERE (
    CASE
      WHEN $2 = 'created' THEN NOT EXISTS (SELECT 1 FROM current_status)
      WHEN $2 = 'pending' THEN EXISTS (SELECT 1 FROM current_status WHERE status = 'created')
      WHEN $2 = 'failed' THEN EXISTS (SELECT 1 FROM current_status WHERE status = 'pending')
      WHEN $2 = 'completed' THEN EXISTS (SELECT 1 FROM current_status WHERE status = 'pending')
      ELSE FALSE
    END
  )
  LIMIT 1
  RETURNING 1 as state, id, deployment_id, status
),
new_log AS (
  INSERT INTO deployment_logs (deployment_id, project_id, event, message)
  SELECT $1, $3, $4, $5
  WHERE EXISTS (SELECT 1 FROM status_update)
  RETURNING id
),
all_statuses AS (
  SELECT state, id, deployment_id, status FROM status_update
  UNION ALL
  SELECT state, id, deployment_id, status FROM current_status
)
SELECT 
    all_statuses.id as status_id
  , all_statuses.status as status
  , (CASE 
      WHEN all_statuses.state = 1 THEN TRUE
      ELSE FALSE
    END) as moved
FROM all_statuses
ORDER BY all_statuses.state DESC
LIMIT 1
`

type TransitionDeploymentParams struct {
	DeploymentID uuid.UUID
	Status       string
	ProjectID    uuid.UUID
	Event        string
	Message      string
}

type TransitionDeploymentRow struct {
	StatusID uuid.UUID
	Status   string
	Moved    bool
}

func (q *Queries) TransitionDeployment(ctx context.Context, arg TransitionDeploymentParams) (TransitionDeploymentRow, error) {
	row := q.db.QueryRow(ctx, transitionDeployment,
		arg.DeploymentID,
		arg.Status,
		arg.ProjectID,
		arg.Event,
		arg.Message,
	)
	var i TransitionDeploymentRow
	err := row.Scan(&i.StatusID, &i.Status, &i.Moved)
	return i, err
}

const upsertDeploymentOpenAPIv3Asset = `-- name: UpsertDeploymentOpenAPIv3Asset :one
INSERT INTO deployments_openapiv3_assets (
  deployment_id,
  asset_id,
  name,
  slug
) VALUES (
  $1,
  $2,
  $3,
  $4
)
ON CONFLICT (deployment_id, slug) DO UPDATE
SET
  asset_id = EXCLUDED.asset_id,
  name = EXCLUDED.name
RETURNING id, asset_id, name, slug
`

type UpsertDeploymentOpenAPIv3AssetParams struct {
	DeploymentID uuid.UUID
	AssetID      uuid.UUID
	Name         string
	Slug         string
}

type UpsertDeploymentOpenAPIv3AssetRow struct {
	ID      uuid.UUID
	AssetID uuid.UUID
	Name    string
	Slug    string
}

func (q *Queries) UpsertDeploymentOpenAPIv3Asset(ctx context.Context, arg UpsertDeploymentOpenAPIv3AssetParams) (UpsertDeploymentOpenAPIv3AssetRow, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentOpenAPIv3Asset,
		arg.DeploymentID,
		arg.AssetID,
		arg.Name,
		arg.Slug,
	)
	var i UpsertDeploymentOpenAPIv3AssetRow
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.Name,
		&i.Slug,
	)
	return i, err
}

const upsertDeploymentPackage = `-- name: UpsertDeploymentPackage :one
INSERT INTO deployments_packages (
  deployment_id
  , package_id
  , version_id
) VALUES (
  $1,
  $2,
  $3
)
ON CONFLICT (deployment_id, package_id) DO UPDATE
SET
  version_id = EXCLUDED.version_id
RETURNING id
`

type UpsertDeploymentPackageParams struct {
	DeploymentID uuid.UUID
	PackageID    uuid.UUID
	VersionID    uuid.UUID
}

func (q *Queries) UpsertDeploymentPackage(ctx context.Context, arg UpsertDeploymentPackageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentPackage, arg.DeploymentID, arg.PackageID, arg.VersionID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
