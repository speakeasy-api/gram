// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const deleteToolsetEmbeddings = `-- name: DeleteToolsetEmbeddings :exec
DELETE FROM toolset_embeddings
WHERE toolset_id = $1
  AND entry_key LIKE 'tools:%'
  AND deleted IS FALSE
`

// NOTE: Hard delete while in experimentation phase to preserve space.
// Consider switching to soft delete when feature is production-ready.
func (q *Queries) DeleteToolsetEmbeddings(ctx context.Context, toolsetID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteToolsetEmbeddings, toolsetID)
	return err
}

const insertToolsetEmbedding = `-- name: InsertToolsetEmbedding :one
INSERT INTO toolset_embeddings (
    project_id,
    toolset_id,
    toolset_version,
    entry_key,
    embedding_model,
    embedding_1536,
    payload,
    tags
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING id, project_id, toolset_id, toolset_version, entry_key, embedding_model, embedding_1536, payload, tags, created_at, updated_at, deleted_at, deleted
`

type InsertToolsetEmbeddingParams struct {
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	ToolsetVersion int64
	EntryKey       string
	EmbeddingModel string
	Embedding1536  pgvector_go.Vector
	Payload        []byte
	Tags           []string
}

func (q *Queries) InsertToolsetEmbedding(ctx context.Context, arg InsertToolsetEmbeddingParams) (ToolsetEmbedding, error) {
	row := q.db.QueryRow(ctx, insertToolsetEmbedding,
		arg.ProjectID,
		arg.ToolsetID,
		arg.ToolsetVersion,
		arg.EntryKey,
		arg.EmbeddingModel,
		arg.Embedding1536,
		arg.Payload,
		arg.Tags,
	)
	var i ToolsetEmbedding
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ToolsetID,
		&i.ToolsetVersion,
		&i.EntryKey,
		&i.EmbeddingModel,
		&i.Embedding1536,
		&i.Payload,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const searchToolsetToolEmbeddingsAllTagsMatch = `-- name: SearchToolsetToolEmbeddingsAllTagsMatch :many
SELECT
    id,
    project_id,
    toolset_id,
    toolset_version,
    entry_key,
    embedding_model,
    payload,
    tags,
    created_at,
    updated_at,
    (1 - (embedding_1536 <=> $1))::float8 AS similarity
FROM toolset_embeddings
WHERE project_id = $2
  AND toolset_id = $3
  AND toolset_version = $4
  AND entry_key LIKE 'tools:%'
  AND (cardinality($5::text[]) = 0 OR tags @> $5)
  AND deleted IS FALSE
ORDER BY embedding_1536 <=> $1
LIMIT $6
`

type SearchToolsetToolEmbeddingsAllTagsMatchParams struct {
	QueryEmbedding1536 pgvector_go.Vector
	ProjectID          uuid.UUID
	ToolsetID          uuid.UUID
	ToolsetVersion     int64
	Tags               []string
	ResultLimit        int32
}

type SearchToolsetToolEmbeddingsAllTagsMatchRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	ToolsetVersion int64
	EntryKey       string
	EmbeddingModel string
	Payload        []byte
	Tags           []string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Similarity     float64
}

func (q *Queries) SearchToolsetToolEmbeddingsAllTagsMatch(ctx context.Context, arg SearchToolsetToolEmbeddingsAllTagsMatchParams) ([]SearchToolsetToolEmbeddingsAllTagsMatchRow, error) {
	rows, err := q.db.Query(ctx, searchToolsetToolEmbeddingsAllTagsMatch,
		arg.QueryEmbedding1536,
		arg.ProjectID,
		arg.ToolsetID,
		arg.ToolsetVersion,
		arg.Tags,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchToolsetToolEmbeddingsAllTagsMatchRow
	for rows.Next() {
		var i SearchToolsetToolEmbeddingsAllTagsMatchRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ToolsetID,
			&i.ToolsetVersion,
			&i.EntryKey,
			&i.EmbeddingModel,
			&i.Payload,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchToolsetToolEmbeddingsAnyTagsMatch = `-- name: SearchToolsetToolEmbeddingsAnyTagsMatch :many
SELECT
    id,
    project_id,
    toolset_id,
    toolset_version,
    entry_key,
    embedding_model,
    payload,
    tags,
    created_at,
    updated_at,
    (1 - (embedding_1536 <=> $1))::float8 AS similarity
FROM toolset_embeddings
WHERE project_id = $2
  AND toolset_id = $3
  AND toolset_version = $4
  AND entry_key LIKE 'tools:%'
  AND (cardinality($5::text[]) = 0 OR tags && $5::text[])
  AND deleted IS FALSE
ORDER BY embedding_1536 <=> $1
LIMIT $6
`

type SearchToolsetToolEmbeddingsAnyTagsMatchParams struct {
	QueryEmbedding1536 pgvector_go.Vector
	ProjectID          uuid.UUID
	ToolsetID          uuid.UUID
	ToolsetVersion     int64
	Tags               []string
	ResultLimit        int32
}

type SearchToolsetToolEmbeddingsAnyTagsMatchRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	ToolsetVersion int64
	EntryKey       string
	EmbeddingModel string
	Payload        []byte
	Tags           []string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Similarity     float64
}

func (q *Queries) SearchToolsetToolEmbeddingsAnyTagsMatch(ctx context.Context, arg SearchToolsetToolEmbeddingsAnyTagsMatchParams) ([]SearchToolsetToolEmbeddingsAnyTagsMatchRow, error) {
	rows, err := q.db.Query(ctx, searchToolsetToolEmbeddingsAnyTagsMatch,
		arg.QueryEmbedding1536,
		arg.ProjectID,
		arg.ToolsetID,
		arg.ToolsetVersion,
		arg.Tags,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchToolsetToolEmbeddingsAnyTagsMatchRow
	for rows.Next() {
		var i SearchToolsetToolEmbeddingsAnyTagsMatchRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ToolsetID,
			&i.ToolsetVersion,
			&i.EntryKey,
			&i.EmbeddingModel,
			&i.Payload,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toolsetAvailableTags = `-- name: ToolsetAvailableTags :many
SELECT DISTINCT unnest(tags)::text as tag
FROM toolset_embeddings
WHERE project_id = $1
  AND toolset_id = $2
  AND toolset_version = $3
  AND entry_key LIKE 'tools:%'
  AND deleted IS FALSE
ORDER BY tag
`

type ToolsetAvailableTagsParams struct {
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	ToolsetVersion int64
}

func (q *Queries) ToolsetAvailableTags(ctx context.Context, arg ToolsetAvailableTagsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, toolsetAvailableTags, arg.ProjectID, arg.ToolsetID, arg.ToolsetVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toolsetToolsAreIndexed = `-- name: ToolsetToolsAreIndexed :one
WITH latest_deployment AS (
  SELECT d.created_at
  FROM deployments d
  JOIN deployment_statuses ds ON d.id = ds.deployment_id
  WHERE d.project_id = $1
    AND ds.status = 'completed'
  ORDER BY d.created_at DESC
  LIMIT 1
),
latest_embedding AS (
  SELECT MAX(created_at) as created_at
  FROM toolset_embeddings
  WHERE toolset_embeddings.toolset_id = $2
    AND toolset_embeddings.toolset_version = $3
    AND entry_key LIKE 'tools:%'
    AND deleted IS FALSE
)
SELECT
  CASE
    -- If no embeddings exist for this version, not indexed
    WHEN (SELECT created_at FROM latest_embedding) IS NULL THEN FALSE
    -- If embeddings exist but are older than latest deployment, not indexed
    WHEN (SELECT created_at FROM latest_deployment) IS NOT NULL
         AND (SELECT created_at FROM latest_embedding) < (SELECT created_at FROM latest_deployment) THEN FALSE
    -- Otherwise, embeddings are up to date
    ELSE TRUE
  END as indexed
`

type ToolsetToolsAreIndexedParams struct {
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	ToolsetVersion int64
}

func (q *Queries) ToolsetToolsAreIndexed(ctx context.Context, arg ToolsetToolsAreIndexedParams) (bool, error) {
	row := q.db.QueryRow(ctx, toolsetToolsAreIndexed, arg.ProjectID, arg.ToolsetID, arg.ToolsetVersion)
	var indexed bool
	err := row.Scan(&indexed)
	return indexed, err
}
