// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const deleteToolsetEmbeddings = `-- name: DeleteToolsetEmbeddings :exec
UPDATE toolset_embeddings
SET deleted_at = clock_timestamp()
WHERE toolset_id = $1
  AND entry_key LIKE 'tool:%'
  AND deleted IS FALSE
`

func (q *Queries) DeleteToolsetEmbeddings(ctx context.Context, toolsetID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteToolsetEmbeddings, toolsetID)
	return err
}

const insertToolsetEmbedding = `-- name: InsertToolsetEmbedding :one
INSERT INTO toolset_embeddings (
    project_id,
    toolset_id,
    entry_key,
    embedding_model,
    embedding_1536,
    payload
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
RETURNING id, project_id, toolset_id, entry_key, embedding_model, embedding_1536, payload, created_at, updated_at, deleted_at, deleted
`

type InsertToolsetEmbeddingParams struct {
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	EntryKey       string
	EmbeddingModel string
	Embedding1536  pgvector_go.Vector
	Payload        []byte
}

func (q *Queries) InsertToolsetEmbedding(ctx context.Context, arg InsertToolsetEmbeddingParams) (ToolsetEmbedding, error) {
	row := q.db.QueryRow(ctx, insertToolsetEmbedding,
		arg.ProjectID,
		arg.ToolsetID,
		arg.EntryKey,
		arg.EmbeddingModel,
		arg.Embedding1536,
		arg.Payload,
	)
	var i ToolsetEmbedding
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ToolsetID,
		&i.EntryKey,
		&i.EmbeddingModel,
		&i.Embedding1536,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}

const searchToolsetToolEmbeddings = `-- name: SearchToolsetToolEmbeddings :many
SELECT
    id,
    project_id,
    toolset_id,
    entry_key,
    embedding_model,
    payload,
    created_at,
    updated_at,
    (1 - (embedding_1536 <=> $1))::float8 AS similarity
FROM toolset_embeddings
WHERE project_id = $2
  AND toolset_id = $3
  AND entry_key LIKE 'tool:%'
  AND deleted IS FALSE
ORDER BY embedding_1536 <=> $1
LIMIT $4
`

type SearchToolsetToolEmbeddingsParams struct {
	QueryEmbedding1536 pgvector_go.Vector
	ProjectID          uuid.UUID
	ToolsetID          uuid.UUID
	ResultLimit        int32
}

type SearchToolsetToolEmbeddingsRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	ToolsetID      uuid.UUID
	EntryKey       string
	EmbeddingModel string
	Payload        []byte
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Similarity     float64
}

func (q *Queries) SearchToolsetToolEmbeddings(ctx context.Context, arg SearchToolsetToolEmbeddingsParams) ([]SearchToolsetToolEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, searchToolsetToolEmbeddings,
		arg.QueryEmbedding1536,
		arg.ProjectID,
		arg.ToolsetID,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchToolsetToolEmbeddingsRow
	for rows.Next() {
		var i SearchToolsetToolEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ToolsetID,
			&i.EntryKey,
			&i.EmbeddingModel,
			&i.Payload,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toolsetToolsAreIndexed = `-- name: ToolsetToolsAreIndexed :one
WITH latest_deployment AS (
  SELECT d.created_at
  FROM deployments d
  JOIN deployment_statuses ds ON d.id = ds.deployment_id
  WHERE d.project_id = $1
    AND ds.status = 'completed'
  ORDER BY d.created_at DESC
  LIMIT 1
),
latest_toolset_version AS (
  SELECT created_at
  FROM toolset_versions
  WHERE toolset_versions.toolset_id = $2
  ORDER BY created_at DESC
  LIMIT 1
),
latest_embedding AS (
  SELECT MAX(created_at) as created_at
  FROM toolset_embeddings
  WHERE toolset_embeddings.toolset_id = $2
    AND entry_key LIKE 'tool:%'
    AND deleted IS FALSE
)
SELECT
  CASE
    -- If no embeddings exist, not indexed
    WHEN (SELECT created_at FROM latest_embedding) IS NULL THEN FALSE
    -- If embeddings exist but are older than latest deployment, not indexed
    WHEN (SELECT created_at FROM latest_deployment) IS NOT NULL
         AND (SELECT created_at FROM latest_embedding) < (SELECT created_at FROM latest_deployment) THEN FALSE
    -- If embeddings exist but are older than latest toolset version, not indexed
    WHEN (SELECT created_at FROM latest_toolset_version) IS NOT NULL
         AND (SELECT created_at FROM latest_embedding) < (SELECT created_at FROM latest_toolset_version) THEN FALSE
    -- Otherwise, embeddings are up to date
    ELSE TRUE
  END as indexed
`

type ToolsetToolsAreIndexedParams struct {
	ProjectID uuid.UUID
	ToolsetID uuid.UUID
}

func (q *Queries) ToolsetToolsAreIndexed(ctx context.Context, arg ToolsetToolsAreIndexedParams) (bool, error) {
	row := q.db.QueryRow(ctx, toolsetToolsAreIndexed, arg.ProjectID, arg.ToolsetID)
	var indexed bool
	err := row.Scan(&indexed)
	return indexed, err
}
