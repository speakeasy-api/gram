package agents

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log/slog"
	"mime"
	"net/http"
	"strings"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"github.com/speakeasy-api/gram/server/internal/attr"
	"github.com/speakeasy-api/gram/server/internal/cache"
	"github.com/speakeasy-api/gram/server/internal/contenttypes"
	"github.com/speakeasy-api/gram/server/internal/conv"
	"github.com/speakeasy-api/gram/server/internal/encryption"
	"github.com/speakeasy-api/gram/server/internal/environments"
	env_repo "github.com/speakeasy-api/gram/server/internal/environments/repo"
	"github.com/speakeasy-api/gram/server/internal/functions"
	"github.com/speakeasy-api/gram/server/internal/gateway"
	"github.com/speakeasy-api/gram/server/internal/guardian"
	"github.com/speakeasy-api/gram/server/internal/mv"
	"github.com/speakeasy-api/gram/server/internal/o11y"
	tm "github.com/speakeasy-api/gram/server/internal/telemetry"
	"github.com/speakeasy-api/gram/server/internal/thirdparty/openrouter"
	"github.com/speakeasy-api/gram/server/internal/toolsets"
	"github.com/speakeasy-api/gram/server/internal/urn"
)

// ResponseInput represents the input to an agent response.
// It can be any JSON value (string, array, object, etc.) - parsing is handled in PreprocessAgentsInput
type ResponseInput any

// OutputMessage represents an output message from the model
type OutputMessage struct {
	Type    string              `json:"type"` // "message"
	ID      string              `json:"id"`
	Status  string              `json:"status"` // "in_progress", "completed", or "incomplete"
	Role    string              `json:"role"`   // "assistant"
	Content []OutputTextContent `json:"content"`
}

type OutputTextContent struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

// MCPToolCall represents an MCP tool invocation in OpenAI Responses API format
type MCPToolCall struct {
	Type        string  `json:"type"` // "mcp_call"
	ID          string  `json:"id"`
	ServerLabel string  `json:"server_label"`
	Name        string  `json:"name"`
	Arguments   string  `json:"arguments"`
	Output      string  `json:"output"`
	Error       *string `json:"error,omitempty"`
	Status      string  `json:"status"` // "in_progress", "completed", "incomplete", "calling", or "failed"
}

// FunctionToolCall represents a function tool call in OpenAI Responses API format
type FunctionToolCall struct {
	Type      string `json:"type"`    // "function_call"
	ID        string `json:"id"`      // Unique ID of the function tool call
	CallID    string `json:"call_id"` // The unique ID of the function tool call generated by the model
	Name      string `json:"name"`    // The name of the function to run
	Arguments string `json:"arguments"`
	Status    string `json:"status"` // "in_progress", "completed", or "incomplete"
}

// FunctionToolCallOutput represents the output of a function tool call
type FunctionToolCallOutput struct {
	Type   string `json:"type"`    // "function_call_output"
	CallID string `json:"call_id"` // The call_id of the function tool call this output is for
	Output string `json:"output"`  // The output of the function call
}

// OutputItem is a union type for different output types
// Can be one of: OutputMessage, MCPToolCall, FunctionToolCall, FunctionToolCallOutput
type OutputItem interface {
	outputItemType() string
}

func (o OutputMessage) outputItemType() string          { return o.Type }
func (o MCPToolCall) outputItemType() string            { return o.Type }
func (o FunctionToolCall) outputItemType() string       { return o.Type }
func (o FunctionToolCallOutput) outputItemType() string { return o.Type }

// OutputItems is a wrapper for []OutputItem that provides custom JSON unmarshaling
type OutputItems []OutputItem

// UnmarshalJSON implements json.Unmarshaler for OutputItems
func (o *OutputItems) UnmarshalJSON(data []byte) error {
	var raw []json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("unmarshal output items array: %w", err)
	}

	items := make([]OutputItem, 0, len(raw))
	for _, itemData := range raw {
		var typeCheck struct {
			Type string `json:"type"`
		}
		if err := json.Unmarshal(itemData, &typeCheck); err != nil {
			return fmt.Errorf("unmarshal output item type: %w", err)
		}

		switch typeCheck.Type {
		case "message":
			var msg OutputMessage
			if err := json.Unmarshal(itemData, &msg); err != nil {
				return fmt.Errorf("unmarshal OutputMessage: %w", err)
			}
			items = append(items, msg)
		case "mcp_call":
			var toolCall MCPToolCall
			if err := json.Unmarshal(itemData, &toolCall); err != nil {
				return fmt.Errorf("unmarshal MCPToolCall: %w", err)
			}
			items = append(items, toolCall)
		case "function_call":
			var funcCall FunctionToolCall
			if err := json.Unmarshal(itemData, &funcCall); err != nil {
				return fmt.Errorf("unmarshal FunctionToolCall: %w", err)
			}
			items = append(items, funcCall)
		case "function_call_output":
			var funcOutput FunctionToolCallOutput
			if err := json.Unmarshal(itemData, &funcOutput); err != nil {
				return fmt.Errorf("unmarshal FunctionToolCallOutput: %w", err)
			}
			items = append(items, funcOutput)
		default:
			return fmt.Errorf("unknown output item type: %s", typeCheck.Type)
		}
	}

	*o = items
	return nil
}

// MarshalJSON implements json.Marshaler for OutputItems
func (o OutputItems) MarshalJSON() ([]byte, error) {
	if o == nil {
		return []byte(""), nil
	}
	data, err := json.Marshal([]OutputItem(o))
	if err != nil {
		return nil, fmt.Errorf("marshal output items: %w", err)
	}
	return data, nil
}

type Toolset struct {
	ToolsetSlug     string `json:"toolset_slug"`
	EnvironmentSlug string `json:"environment_slug"`
}

type SubAgent struct {
	Instructions    string     `json:"instructions"`
	Name            string     `json:"name"`
	Description     string     `json:"description"`
	Tools           []urn.Tool `json:"tools"`
	Toolsets        []Toolset  `json:"toolsets"`
	EnvironmentSlug string     `json:"environment_slug"`
}

type ResponseRequest struct {
	Model              string        `json:"model"`
	Instructions       *string       `json:"instructions,omitempty"`
	Input              ResponseInput `json:"input"` // Can be string or []OutputMessage or []RoleMessage
	PreviousResponseID *string       `json:"previous_response_id,omitempty"`
	Temperature        *float64      `json:"temperature,omitempty"`
	Toolsets           []Toolset     `json:"toolsets,omitempty"`
	SubAgents          []SubAgent    `json:"sub_agents,omitempty"`
	Async              *bool         `json:"async,omitempty"`
	Store              *bool         `json:"store,omitempty"`
}

type ResponseUsage struct {
	InputTokens  int `json:"input_tokens"`
	OutputTokens int `json:"output_tokens"`
	TotalTokens  int `json:"total_tokens"`
}

type TextFormat struct {
	Type string `json:"type"`
}

type ResponseText struct {
	Format TextFormat `json:"format"`
}

type ResponseOutput struct {
	ID                 string       `json:"id"`
	Object             string       `json:"object"` // "response"
	CreatedAt          int64        `json:"created_at"`
	Status             string       `json:"status"`
	Error              *string      `json:"error"`
	Instructions       *string      `json:"instructions"`
	Model              string       `json:"model"`
	Output             OutputItems  `json:"output"` // Can contain OutputMessage, MCPToolCall
	PreviousResponseID *string      `json:"previous_response_id"`
	Temperature        float64      `json:"temperature"`
	Text               ResponseText `json:"text"`
	Result             string       `json:"result"`
}

// ExecutionHistory tracks execution metrics for agent workflows
type ExecutionHistory struct {
	MainThreadToolCalls int            `json:"main_thread_tool_calls"`
	SubAgentToolCalls   map[string]int `json:"sub_agent_tool_calls"`
}

// InputDetails captures the input context for an agent workflow
type InputDetails struct {
	Instructions *string `json:"instructions,omitempty"`
	Prompt       string  `json:"prompt"`
}

// AgentsResponseWorkflowResult is the wrapper result returned by AgentsResponseWorkflow
type AgentsResponseWorkflowResult struct {
	OrgID            string           `json:"org_id"`
	ProjectID        uuid.UUID        `json:"project_id"`
	ResponseOutput   ResponseOutput   `json:"response_output"`
	ExecutionHistory ExecutionHistory `json:"execution_history"`
	InputDetails     InputDetails     `json:"input_details"`
}

type AgentTool struct {
	Definition  openrouter.Tool
	IsMCPTool   bool
	ServerLabel string
	ToolURN     *urn.Tool
}

// Service holds dependencies for agent operations
type Service struct {
	logger       *slog.Logger
	db           *pgxpool.Pool
	env          *environments.EnvironmentEntries
	toolProxy    *gateway.ToolProxy
	cache        cache.Cache
	toolsetCache cache.TypedCacheObject[mv.ToolsetBaseContents]
	chatClient   *openrouter.ChatClient
}

// NewService creates a new agents service
func NewService(
	logger *slog.Logger,
	tracerProvider trace.TracerProvider,
	meterProvider metric.MeterProvider,
	db *pgxpool.Pool,
	env *environments.EnvironmentEntries,
	enc *encryption.Client,
	cacheImpl cache.Cache,
	guardianPolicy *guardian.Policy,
	funcCaller functions.ToolCaller,
	openRouter openrouter.Provisioner,
	baseChatClient *openrouter.ChatClient,
) *Service {
	logger = logger.With(attr.SlogComponent("agents"))

	return &Service{
		logger: logger,
		db:     db,
		env:    env,
		toolProxy: gateway.NewToolProxy(
			logger,
			tracerProvider,
			meterProvider,
			gateway.ToolCallSourceDirect,
			enc,
			cacheImpl,
			guardianPolicy,
			funcCaller,
		),
		cache:        cacheImpl,
		toolsetCache: cache.NewTypedObjectCache[mv.ToolsetBaseContents](logger.With(attr.SlogCacheNamespace("toolset")), cacheImpl, cache.SuffixNone),
		chatClient:   baseChatClient,
	}
}

// toolCallResponseWriter captures the response from a tool call
type toolCallResponseWriter struct {
	headers    http.Header
	body       *bytes.Buffer
	statusCode int
}

func (w *toolCallResponseWriter) Header() http.Header {
	return w.headers
}

func (w *toolCallResponseWriter) Write(b []byte) (int, error) {
	return w.body.Write(b) //nolint:wrapcheck // passthrough from bytes.Buffer
}

func (w *toolCallResponseWriter) WriteHeader(statusCode int) {
	w.statusCode = statusCode
}

type toolCallResult struct {
	Text string
	Data string
}

func formatResult(rw toolCallResponseWriter) (toolCallResult, error) {
	body := rw.body.Bytes()
	if len(body) == 0 {
		return toolCallResult{Text: "", Data: ""}, nil
	}

	ct := rw.Header().Get("Content-Type")
	if ct == "" {
		return toolCallResult{Text: string(body), Data: ""}, nil
	}

	mt, _, err := mime.ParseMediaType(ct)
	if err != nil {
		return toolCallResult{Text: "", Data: ""}, fmt.Errorf("failed to parse content type %q: %w", ct, err)
	}

	switch {
	case strings.HasPrefix(mt, "text/"), contenttypes.IsJSON(mt), contenttypes.IsYAML(mt):
		return toolCallResult{Text: string(body), Data: ""}, nil
	case strings.HasPrefix(mt, "image/"):
		encoded := base64.StdEncoding.EncodeToString(body)
		return toolCallResult{Text: "", Data: encoded}, nil
	case strings.HasPrefix(mt, "audio/"):
		encoded := base64.StdEncoding.EncodeToString(body)
		return toolCallResult{Text: "", Data: encoded}, nil
	default:
		return toolCallResult{Text: string(body), Data: ""}, nil
	}
}

// LoadToolsetTools loads tool definitions from a toolset (without executors)
func (s *Service) LoadToolsetTools(
	ctx context.Context,
	projectID uuid.UUID,
	toolsetSlug string,
	environmentSlug string,
) ([]AgentTool, error) {
	toolset, err := mv.DescribeToolset(ctx, s.logger, s.db, mv.ProjectID(projectID), mv.ToolsetSlug(toolsetSlug), &s.toolsetCache)
	if err != nil {
		return nil, err
	}

	toolsetHelpers := toolsets.NewToolsets(s.db)

	agentTools := make([]AgentTool, 0, len(toolset.Tools))
	for _, tool := range toolset.Tools {
		if tool == nil {
			continue
		}

		toolURN, err := conv.GetToolURN(*tool)
		if err != nil {
			return nil, fmt.Errorf("failed to get tool urn: %w", err)
		}

		tool := conv.ToBaseTool(tool)

		plan, err := toolsetHelpers.GetToolCallPlanByURN(ctx, *toolURN, projectID)
		if err != nil {
			return nil, fmt.Errorf("failed to get tool call plan: %w", err)
		}

		var schema json.RawMessage
		switch plan.Kind {
		case gateway.ToolKindHTTP:
			if plan.HTTP != nil {
				schema = json.RawMessage(plan.HTTP.Schema)
			}
		case gateway.ToolKindFunction:
			if plan.Function != nil {
				schema = json.RawMessage(plan.Function.InputSchema)
			}
		case gateway.ToolKindPrompt:
			schema = json.RawMessage(`{}`)
		}

		if len(schema) == 0 {
			schema = json.RawMessage(`{}`)
		}

		var description string
		if plan.Descriptor != nil && plan.Descriptor.Description != nil {
			description = *plan.Descriptor.Description
		} else {
			description = tool.Description
		}

		agentTools = append(agentTools, AgentTool{
			Definition: openrouter.Tool{
				Type: "function",
				Function: &openrouter.FunctionDefinition{
					Name:        tool.Name,
					Description: description,
					Parameters:  schema,
				},
			},
			IsMCPTool:   true,
			ServerLabel: toolsetSlug,
			ToolURN:     toolURN,
		})
	}

	return agentTools, nil
}

// LoadToolsByURN loads tool definitions by their URNs (without executors)
func (s *Service) LoadToolsByURN(
	ctx context.Context,
	projectID uuid.UUID,
	toolURNs []urn.Tool,
	environmentSlug string,
) ([]AgentTool, error) {
	toolsetHelpers := toolsets.NewToolsets(s.db)

	agentTools := make([]AgentTool, 0, len(toolURNs))
	for _, toolURN := range toolURNs {
		plan, err := toolsetHelpers.GetToolCallPlanByURN(ctx, toolURN, projectID)
		if err != nil {
			return nil, fmt.Errorf("failed to get tool call plan for %s: %w", toolURN.String(), err)
		}

		if plan.Descriptor == nil {
			continue
		}

		var name, description string
		var schema json.RawMessage

		name = plan.Descriptor.Name
		switch plan.Kind {
		case gateway.ToolKindHTTP:
			if plan.HTTP != nil {
				schema = json.RawMessage(plan.HTTP.Schema)
			}
		case gateway.ToolKindFunction:
			if plan.Function != nil {
				schema = json.RawMessage(plan.Function.InputSchema)
			}
		case gateway.ToolKindPrompt:
			// Prompt tools don't have a schema in the same way
			schema = json.RawMessage(`{}`)
		}

		if plan.Descriptor.Description != nil {
			description = *plan.Descriptor.Description
		}

		if len(schema) == 0 {
			schema = json.RawMessage(`{}`)
		}

		toolURNCopy := toolURN
		agentTools = append(agentTools, AgentTool{
			Definition: openrouter.Tool{
				Type: "function",
				Function: &openrouter.FunctionDefinition{
					Name:        name,
					Description: description,
					Parameters:  schema,
				},
			},
			IsMCPTool:   true,
			ServerLabel: toolURN.Source,
			ToolURN:     &toolURNCopy,
		})
	}

	return agentTools, nil
}

// ExecuteTool executes a tool by its URN and returns the result
func (s *Service) ExecuteTool(
	ctx context.Context,
	projectID uuid.UUID,
	toolURN urn.Tool,
	environmentSlug string,
	rawArgs string,
) (string, error) {
	envRepo := env_repo.New(s.db)
	toolsetHelpers := toolsets.NewToolsets(s.db)

	plan, err := toolsetHelpers.GetToolCallPlanByURN(ctx, toolURN, projectID)
	if err != nil {
		return "", fmt.Errorf("failed to get tool call plan: %w", err)
	}

	descriptor := plan.Descriptor
	ctx, _ = o11y.EnrichToolCallContext(ctx, s.logger, descriptor.OrganizationSlug, descriptor.ProjectSlug)

	systemConfig, err := s.env.LoadSourceEnv(ctx, projectID, string(toolURN.Kind), toolURN.Source)
	if err != nil {
		return "", fmt.Errorf("failed to load system environment: %w", err)
	}

	// Load environment entries if environment slug provided
	var environmentEntries []env_repo.EnvironmentEntry
	if environmentSlug != "" {
		envModel, err := envRepo.GetEnvironmentBySlug(ctx, env_repo.GetEnvironmentBySlugParams{
			ProjectID: projectID,
			Slug:      strings.ToLower(environmentSlug),
		})
		if err != nil {
			return "", fmt.Errorf("failed to load environment: %w", err)
		}

		environmentEntries, err = s.env.ListEnvironmentEntries(ctx, projectID, envModel.ID, false)
		if err != nil {
			return "", fmt.Errorf("failed to load environment entries: %w", err)
		}
	}

	rw := &toolCallResponseWriter{
		headers:    make(http.Header),
		body:       new(bytes.Buffer),
		statusCode: http.StatusOK,
	}

	ciEnv := gateway.NewCaseInsensitiveEnv()
	for _, entry := range environmentEntries {
		ciEnv.Set(entry.Name, entry.Value)
	}

	err = s.toolProxy.Do(ctx, rw, bytes.NewBufferString(rawArgs), gateway.ToolCallEnv{
		SystemEnv:  gateway.CIEnvFrom(systemConfig),
		UserConfig: ciEnv,
	}, plan, tm.NewNoopToolCallLogger())
	if err != nil {
		return "", fmt.Errorf("tool proxy error: %w", err)
	}

	result, err := formatResult(*rw)
	if err != nil {
		return "", fmt.Errorf("failed to format tool call result: %w", err)
	}

	if result.Text != "" {
		return result.Text, nil
	}
	if result.Data != "" {
		// result.Data is already a string (base64-encoded for images/audio), return it directly
		return result.Data, nil
	}
	return fmt.Sprintf("status code: %d", rw.statusCode), nil
}

// GetCompletionFromMessages calls the chat client to get a completion from messages
func (s *Service) GetCompletionFromMessages(
	ctx context.Context,
	orgID string,
	projectID string,
	messages []openrouter.OpenAIChatMessage,
	toolDefs []openrouter.Tool,
	temperature *float64,
	model string,
) (*openrouter.OpenAIChatMessage, error) {
	msg, err := s.chatClient.GetCompletionFromMessages(ctx, orgID, projectID, messages, toolDefs, temperature, model)
	if err != nil {
		return nil, fmt.Errorf("failed to get completion from messages: %w", err)
	}
	return msg, nil
}
