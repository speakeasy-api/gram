// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getIntegration = `-- name: GetIntegration :one
WITH package_id_lookup as (
  SELECT id
  FROM packages
  WHERE (
      ($1::UUID IS NOT NULL AND packages.id = $1::UUID)
      OR ($2::TEXT IS NOT NULL AND packages.name = $2::TEXT)
    )
    AND packages.deleted IS FALSE
  LIMIT 1
),
latest_public_version as (
    SELECT
        pv.package_id,
        pv.deployment_id,
        pv.major,
        pv.minor,
        pv.patch,
        pv.prerelease,
        pv.build,
        pv.created_at
    FROM package_versions pv
    WHERE pv.package_id = (SELECT id FROM package_id_lookup)
        AND pv.visibility = 'public'
        AND pv.prerelease IS NULL -- Exclude prerelease versions
        AND pv.deleted IS FALSE  -- Exclude soft-deleted versions
    ORDER BY pv.major DESC, pv.minor DESC, pv.patch DESC
    LIMIT 1
)
SELECT 
    packages.id, packages.name, packages.title, packages.summary, packages.description_raw, packages.description_html, packages.url, packages.keywords, packages.image_asset_id, packages.organization_id, packages.project_id, packages.created_at, packages.updated_at, packages.deleted_at, packages.deleted
  , lv.major AS version_major
  , lv.minor AS version_minor
  , lv.patch AS version_patch
  , lv.prerelease AS version_prerelease
  , lv.build AS version_build
  , lv.created_at AS version_created_at
  , (SELECT ARRAY_AGG(name)::text[] FROM http_tool_definitions WHERE http_tool_definitions.deployment_id = lv.deployment_id) as tool_names
FROM packages
INNER JOIN latest_public_version lv ON packages.id = lv.package_id
`

type GetIntegrationParams struct {
	PackageID   uuid.NullUUID
	PackageName pgtype.Text
}

type GetIntegrationRow struct {
	Package           Package
	VersionMajor      int64
	VersionMinor      int64
	VersionPatch      int64
	VersionPrerelease pgtype.Text
	VersionBuild      pgtype.Text
	VersionCreatedAt  pgtype.Timestamptz
	ToolNames         []string
}

func (q *Queries) GetIntegration(ctx context.Context, arg GetIntegrationParams) (GetIntegrationRow, error) {
	row := q.db.QueryRow(ctx, getIntegration, arg.PackageID, arg.PackageName)
	var i GetIntegrationRow
	err := row.Scan(
		&i.Package.ID,
		&i.Package.Name,
		&i.Package.Title,
		&i.Package.Summary,
		&i.Package.DescriptionRaw,
		&i.Package.DescriptionHtml,
		&i.Package.Url,
		&i.Package.Keywords,
		&i.Package.ImageAssetID,
		&i.Package.OrganizationID,
		&i.Package.ProjectID,
		&i.Package.CreatedAt,
		&i.Package.UpdatedAt,
		&i.Package.DeletedAt,
		&i.Package.Deleted,
		&i.VersionMajor,
		&i.VersionMinor,
		&i.VersionPatch,
		&i.VersionPrerelease,
		&i.VersionBuild,
		&i.VersionCreatedAt,
		&i.ToolNames,
	)
	return i, err
}

const listIntegrationVersions = `-- name: ListIntegrationVersions :many
WITH package_id_lookup as (
  SELECT id
  FROM packages
  WHERE (
      ($1::UUID IS NOT NULL AND packages.id = $1::UUID)
      OR ($2::TEXT IS NOT NULL AND packages.name = $2::TEXT)
    )
    AND packages.deleted IS FALSE
  LIMIT 1
)
SELECT
    id
  , major
  , minor
  , patch
  , prerelease
  , build
  , created_at
FROM package_versions pv
WHERE pv.package_id = (SELECT id FROM package_id_lookup)
  AND pv.visibility = 'public'
  AND pv.prerelease IS NULL -- Exclude prerelease versions
  AND pv.deleted IS FALSE  -- Exclude soft-deleted versions
ORDER BY pv.major DESC, pv.minor DESC, pv.patch DESC
LIMIT 500
`

type ListIntegrationVersionsParams struct {
	PackageID   uuid.NullUUID
	PackageName pgtype.Text
}

type ListIntegrationVersionsRow struct {
	ID         uuid.UUID
	Major      int64
	Minor      int64
	Patch      int64
	Prerelease pgtype.Text
	Build      pgtype.Text
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) ListIntegrationVersions(ctx context.Context, arg ListIntegrationVersionsParams) ([]ListIntegrationVersionsRow, error) {
	rows, err := q.db.Query(ctx, listIntegrationVersions, arg.PackageID, arg.PackageName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIntegrationVersionsRow
	for rows.Next() {
		var i ListIntegrationVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Major,
			&i.Minor,
			&i.Patch,
			&i.Prerelease,
			&i.Build,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIntegrations = `-- name: ListIntegrations :many
SELECT 
  p.id AS package_id,
  p.name AS package_name,
  p.title AS package_title,
  p.summary AS package_summary,
  p.url AS package_url,
  p.keywords AS package_keywords,
  p.image_asset_id AS package_image_asset_id,
  lv.major AS version_major,
  lv.minor AS version_minor,
  lv.patch AS version_patch,
  lv.prerelease AS version_prerelease,
  lv.build AS version_build,
  lv.created_at AS version_created_at,
  (SELECT ARRAY_AGG(name)::text[] FROM http_tool_definitions WHERE http_tool_definitions.deployment_id = lv.deployment_id) as tool_names
FROM packages p
JOIN LATERAL (
    SELECT
        pv.deployment_id,
        pv.major,
        pv.minor,
        pv.patch,
        pv.prerelease,
        pv.build,
        pv.created_at
    FROM package_versions pv
    WHERE pv.package_id = p.id
        AND pv.visibility = 'public'
        AND pv.prerelease IS NULL -- Exclude prerelease versions
        AND pv.deleted IS FALSE  -- Exclude soft-deleted versions
    ORDER BY pv.major DESC, pv.minor DESC, pv.patch DESC
    LIMIT 1
) lv ON TRUE
WHERE p.deleted IS FALSE
`

type ListIntegrationsRow struct {
	PackageID           uuid.UUID
	PackageName         string
	PackageTitle        pgtype.Text
	PackageSummary      pgtype.Text
	PackageUrl          pgtype.Text
	PackageKeywords     []string
	PackageImageAssetID uuid.NullUUID
	VersionMajor        int64
	VersionMinor        int64
	VersionPatch        int64
	VersionPrerelease   pgtype.Text
	VersionBuild        pgtype.Text
	VersionCreatedAt    pgtype.Timestamptz
	ToolNames           []string
}

func (q *Queries) ListIntegrations(ctx context.Context) ([]ListIntegrationsRow, error) {
	rows, err := q.db.Query(ctx, listIntegrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIntegrationsRow
	for rows.Next() {
		var i ListIntegrationsRow
		if err := rows.Scan(
			&i.PackageID,
			&i.PackageName,
			&i.PackageTitle,
			&i.PackageSummary,
			&i.PackageUrl,
			&i.PackageKeywords,
			&i.PackageImageAssetID,
			&i.VersionMajor,
			&i.VersionMinor,
			&i.VersionPatch,
			&i.VersionPrerelease,
			&i.VersionBuild,
			&i.VersionCreatedAt,
			&i.ToolNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
