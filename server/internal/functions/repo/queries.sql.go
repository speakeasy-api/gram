// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/speakeasy-api/gram/server/internal/conv"
)

const finalizeFlyApp = `-- name: FinalizeFlyApp :one
UPDATE fly_apps SET
  status = $1,
  reaped_at = $2,
  updated_at = clock_timestamp()
WHERE
  id = $3
  AND project_id = $4
  AND deployment_id = $5
  AND function_id = $6
RETURNING id
`

type FinalizeFlyAppParams struct {
	Status       string
	ReapedAt     pgtype.Timestamptz
	ID           uuid.UUID
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
}

func (q *Queries) FinalizeFlyApp(ctx context.Context, arg FinalizeFlyAppParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, finalizeFlyApp,
		arg.Status,
		arg.ReapedAt,
		arg.ID,
		arg.ProjectID,
		arg.DeploymentID,
		arg.FunctionID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getFlyAppAccess = `-- name: GetFlyAppAccess :one
SELECT
    fa.fly_org_id
  , fa.fly_org_slug
  , fa.app_name
  , fa.app_url
  , fa.runner_version
  , access.id AS access_id
  , access.encryption_key
  , access.bearer_format
FROM fly_apps fa
LEFT JOIN functions_access access
  ON access.id = fa.access_id
  AND access.deleted IS FALSE
WHERE
  fa.project_id = $1
  AND fa.deployment_id = $2
  AND fa.function_id = $3
  AND fa.status = 'ready'
  AND fa.reaped_at IS NULL
  AND fa.access_id = $4
ORDER BY fa.seq DESC NULLS LAST
LIMIT 1
`

type GetFlyAppAccessParams struct {
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
	AccessID     uuid.UUID
}

type GetFlyAppAccessRow struct {
	FlyOrgID      string
	FlyOrgSlug    string
	AppName       string
	AppUrl        string
	RunnerVersion string
	AccessID      uuid.NullUUID
	EncryptionKey conv.Secret
	BearerFormat  pgtype.Text
}

func (q *Queries) GetFlyAppAccess(ctx context.Context, arg GetFlyAppAccessParams) (GetFlyAppAccessRow, error) {
	row := q.db.QueryRow(ctx, getFlyAppAccess,
		arg.ProjectID,
		arg.DeploymentID,
		arg.FunctionID,
		arg.AccessID,
	)
	var i GetFlyAppAccessRow
	err := row.Scan(
		&i.FlyOrgID,
		&i.FlyOrgSlug,
		&i.AppName,
		&i.AppUrl,
		&i.RunnerVersion,
		&i.AccessID,
		&i.EncryptionKey,
		&i.BearerFormat,
	)
	return i, err
}

const getFlyAppNameForFunction = `-- name: GetFlyAppNameForFunction :one
SELECT
    id
  , fly_org_slug
  , app_name
FROM fly_apps
WHERE
  project_id = $1
  AND deployment_id = $2
  AND function_id = $3
  AND status = 'ready'
  AND reaped_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetFlyAppNameForFunctionParams struct {
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
}

type GetFlyAppNameForFunctionRow struct {
	ID         uuid.UUID
	FlyOrgSlug string
	AppName    string
}

func (q *Queries) GetFlyAppNameForFunction(ctx context.Context, arg GetFlyAppNameForFunctionParams) (GetFlyAppNameForFunctionRow, error) {
	row := q.db.QueryRow(ctx, getFlyAppNameForFunction, arg.ProjectID, arg.DeploymentID, arg.FunctionID)
	var i GetFlyAppNameForFunctionRow
	err := row.Scan(&i.ID, &i.FlyOrgSlug, &i.AppName)
	return i, err
}

const getFlyAppsToReap = `-- name: GetFlyAppsToReap :many
WITH ranked_deployments AS (
  -- This CTE ranks deployments within each project by their creation time.
  -- Using d.created_at (deployment timestamp) ensures all functions within
  -- a deployment share the same rank, preventing partial reaping where some
  -- functions are deleted but others remain. DENSE_RANK ensures consecutive
  -- ranks even if multiple deployments have the same timestamp.
  SELECT DISTINCT
      fa.project_id
    , fa.deployment_id
    , d.created_at
    , DENSE_RANK() OVER (
        PARTITION BY fa.project_id
        ORDER BY d.created_at DESC
      ) as deployment_rank
  FROM fly_apps fa
  INNER JOIN deployments d ON d.id = fa.deployment_id
  WHERE
    fa.status = 'ready'
    AND ($3::uuid IS NULL OR fa.project_id = $3)
    AND fa.reaped_at IS NULL
)
SELECT
    fa.id
  , fa.project_id
  , fa.deployment_id
  , fa.function_id
  , fa.fly_org_slug
  , fa.app_name
  , fa.created_at
FROM fly_apps fa
INNER JOIN ranked_deployments rd
  ON fa.project_id = rd.project_id
  AND fa.deployment_id = rd.deployment_id
WHERE
  rd.deployment_rank > $1
  AND fa.status = 'ready'
  AND fa.reaped_at IS NULL
ORDER BY fa.created_at ASC
LIMIT $2
`

type GetFlyAppsToReapParams struct {
	KeepCount pgtype.Int8
	BatchSize pgtype.Int8
	ProjectID uuid.NullUUID
}

type GetFlyAppsToReapRow struct {
	ID           uuid.UUID
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
	FlyOrgSlug   string
	AppName      string
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetFlyAppsToReap(ctx context.Context, arg GetFlyAppsToReapParams) ([]GetFlyAppsToReapRow, error) {
	rows, err := q.db.Query(ctx, getFlyAppsToReap, arg.KeepCount, arg.BatchSize, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlyAppsToReapRow
	for rows.Next() {
		var i GetFlyAppsToReapRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.DeploymentID,
			&i.FunctionID,
			&i.FlyOrgSlug,
			&i.AppName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunctionAssetURL = `-- name: GetFunctionAssetURL :one
SELECT a.url
FROM deployments_functions df
INNER JOIN assets a ON df.asset_id = a.id
WHERE
  a.project_id = $1
  AND df.deployment_id = $2
  AND df.id = $3
  AND a.id = $4
  AND a.deleted IS FALSE
`

type GetFunctionAssetURLParams struct {
	ProjectID    uuid.UUID
	DeploymentID uuid.UUID
	FunctionID   uuid.UUID
	AssetID      uuid.UUID
}

func (q *Queries) GetFunctionAssetURL(ctx context.Context, arg GetFunctionAssetURLParams) (string, error) {
	row := q.db.QueryRow(ctx, getFunctionAssetURL,
		arg.ProjectID,
		arg.DeploymentID,
		arg.FunctionID,
		arg.AssetID,
	)
	var url string
	err := row.Scan(&url)
	return url, err
}

const getFunctionsRunnerVersion = `-- name: GetFunctionsRunnerVersion :one
WITH project_preference AS (
  SELECT p.functions_runner_version as v
  FROM projects p
  WHERE p.id = $1
    AND deleted IS FALSE
),
function_preference AS (
  SELECT df.runner_version as v
  FROM deployments_functions df
  INNER JOIN deployments d ON df.deployment_id = d.id
  WHERE
    d.project_id = $1
    AND df.id = $2
    AND df.deployment_id = $3
)
SELECT COALESCE(
    (SELECT v FROM function_preference),
    (SELECT v FROM project_preference),
    ''
)::text as runner_version
`

type GetFunctionsRunnerVersionParams struct {
	ProjectID    uuid.UUID
	FunctionID   uuid.UUID
	DeploymentID uuid.UUID
}

func (q *Queries) GetFunctionsRunnerVersion(ctx context.Context, arg GetFunctionsRunnerVersionParams) (string, error) {
	row := q.db.QueryRow(ctx, getFunctionsRunnerVersion, arg.ProjectID, arg.FunctionID, arg.DeploymentID)
	var runner_version string
	err := row.Scan(&runner_version)
	return runner_version, err
}

const initFlyApp = `-- name: InitFlyApp :one
INSERT INTO fly_apps (
    project_id
  , deployment_id
  , function_id
  , access_id
  , fly_org_id
  , fly_org_slug
  , app_name
  , app_url
  , runner_version
  , primary_region
  , status
) VALUES (
    $1
  , $2
  , $3
  , $4
  , $5
  , $6
  , $7
  , $8
  , $9
  , $10
  , 'pending'
) RETURNING id
`

type InitFlyAppParams struct {
	ProjectID     uuid.UUID
	DeploymentID  uuid.UUID
	FunctionID    uuid.UUID
	AccessID      uuid.UUID
	FlyOrgID      string
	FlyOrgSlug    string
	AppName       string
	AppUrl        string
	RunnerVersion string
	PrimaryRegion string
}

func (q *Queries) InitFlyApp(ctx context.Context, arg InitFlyAppParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, initFlyApp,
		arg.ProjectID,
		arg.DeploymentID,
		arg.FunctionID,
		arg.AccessID,
		arg.FlyOrgID,
		arg.FlyOrgSlug,
		arg.AppName,
		arg.AppUrl,
		arg.RunnerVersion,
		arg.PrimaryRegion,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const markFlyAppReaped = `-- name: MarkFlyAppReaped :exec
UPDATE fly_apps SET
  reap_error = $1,
  reaped_at = $2,
  updated_at = clock_timestamp()
WHERE id = $3
`

type MarkFlyAppReapedParams struct {
	ReapError pgtype.Text
	ReapedAt  pgtype.Timestamptz
	ID        uuid.UUID
}

func (q *Queries) MarkFlyAppReaped(ctx context.Context, arg MarkFlyAppReapedParams) error {
	_, err := q.db.Exec(ctx, markFlyAppReaped, arg.ReapError, arg.ReapedAt, arg.ID)
	return err
}
