// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type PromptType string

const (
	PromptTypeStr                  PromptType = "str"
	PromptTypeArrayOfStr           PromptType = "arrayOfStr"
	PromptTypeArrayOfNumber        PromptType = "arrayOfNumber"
	PromptTypeArrayOfArrayOfNumber PromptType = "arrayOfArrayOfNumber"
)

type Prompt struct {
	Str                  *string     `queryParam:"inline" union:"member"`
	ArrayOfStr           []string    `queryParam:"inline" union:"member"`
	ArrayOfNumber        []float64   `queryParam:"inline" union:"member"`
	ArrayOfArrayOfNumber [][]float64 `queryParam:"inline" union:"member"`

	Type PromptType
}

func CreatePromptStr(str string) Prompt {
	typ := PromptTypeStr

	return Prompt{
		Str:  &str,
		Type: typ,
	}
}

func CreatePromptArrayOfStr(arrayOfStr []string) Prompt {
	typ := PromptTypeArrayOfStr

	return Prompt{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func CreatePromptArrayOfNumber(arrayOfNumber []float64) Prompt {
	typ := PromptTypeArrayOfNumber

	return Prompt{
		ArrayOfNumber: arrayOfNumber,
		Type:          typ,
	}
}

func CreatePromptArrayOfArrayOfNumber(arrayOfArrayOfNumber [][]float64) Prompt {
	typ := PromptTypeArrayOfArrayOfNumber

	return Prompt{
		ArrayOfArrayOfNumber: arrayOfArrayOfNumber,
		Type:                 typ,
	}
}

func (u *Prompt) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PromptTypeStr,
			Value: &str,
		})
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PromptTypeArrayOfStr,
			Value: arrayOfStr,
		})
	}

	var arrayOfNumber []float64 = []float64{}
	if err := utils.UnmarshalJSON(data, &arrayOfNumber, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PromptTypeArrayOfNumber,
			Value: arrayOfNumber,
		})
	}

	var arrayOfArrayOfNumber [][]float64 = [][]float64{}
	if err := utils.UnmarshalJSON(data, &arrayOfArrayOfNumber, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PromptTypeArrayOfArrayOfNumber,
			Value: arrayOfArrayOfNumber,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Prompt", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Prompt", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PromptType)
	switch best.Type {
	case PromptTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case PromptTypeArrayOfStr:
		u.ArrayOfStr = best.Value.([]string)
		return nil
	case PromptTypeArrayOfNumber:
		u.ArrayOfNumber = best.Value.([]float64)
		return nil
	case PromptTypeArrayOfArrayOfNumber:
		u.ArrayOfArrayOfNumber = best.Value.([][]float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Prompt", string(data))
}

func (u Prompt) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	if u.ArrayOfNumber != nil {
		return utils.MarshalJSON(u.ArrayOfNumber, "", true)
	}

	if u.ArrayOfArrayOfNumber != nil {
		return utils.MarshalJSON(u.ArrayOfArrayOfNumber, "", true)
	}

	return nil, errors.New("could not marshal union type Prompt: all fields are null")
}

type CompletionCreateParamsStopType string

const (
	CompletionCreateParamsStopTypeStr        CompletionCreateParamsStopType = "str"
	CompletionCreateParamsStopTypeArrayOfStr CompletionCreateParamsStopType = "arrayOfStr"
)

type CompletionCreateParamsStop struct {
	Str        *string  `queryParam:"inline" union:"member"`
	ArrayOfStr []string `queryParam:"inline" union:"member"`

	Type CompletionCreateParamsStopType
}

func CreateCompletionCreateParamsStopStr(str string) CompletionCreateParamsStop {
	typ := CompletionCreateParamsStopTypeStr

	return CompletionCreateParamsStop{
		Str:  &str,
		Type: typ,
	}
}

func CreateCompletionCreateParamsStopArrayOfStr(arrayOfStr []string) CompletionCreateParamsStop {
	typ := CompletionCreateParamsStopTypeArrayOfStr

	return CompletionCreateParamsStop{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *CompletionCreateParamsStop) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CompletionCreateParamsStopTypeStr,
			Value: &str,
		})
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CompletionCreateParamsStopTypeArrayOfStr,
			Value: arrayOfStr,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CompletionCreateParamsStop", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CompletionCreateParamsStop", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CompletionCreateParamsStopType)
	switch best.Type {
	case CompletionCreateParamsStopTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case CompletionCreateParamsStopTypeArrayOfStr:
		u.ArrayOfStr = best.Value.([]string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CompletionCreateParamsStop", string(data))
}

func (u CompletionCreateParamsStop) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type CompletionCreateParamsStop: all fields are null")
}

type StreamOptions struct {
	IncludeUsage optionalnullable.OptionalNullable[bool] `json:"include_usage,omitzero"`
}

func (s *StreamOptions) GetIncludeUsage() optionalnullable.OptionalNullable[bool] {
	if s == nil {
		return nil
	}
	return s.IncludeUsage
}

type CompletionCreateParamsResponseFormatPython struct {
	type_ string `const:"python" json:"type"`
}

func (c CompletionCreateParamsResponseFormatPython) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CompletionCreateParamsResponseFormatPython) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CompletionCreateParamsResponseFormatPython) GetType() string {
	return "python"
}

type CompletionCreateParamsResponseFormatJSONObject struct {
	type_ string `const:"json_object" json:"type"`
}

func (c CompletionCreateParamsResponseFormatJSONObject) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CompletionCreateParamsResponseFormatJSONObject) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CompletionCreateParamsResponseFormatJSONObject) GetType() string {
	return "json_object"
}

type CompletionCreateParamsResponseFormatText struct {
	type_ string `const:"text" json:"type"`
}

func (c CompletionCreateParamsResponseFormatText) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CompletionCreateParamsResponseFormatText) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CompletionCreateParamsResponseFormatText) GetType() string {
	return "text"
}

type CompletionCreateParamsResponseFormatUnionType string

const (
	CompletionCreateParamsResponseFormatUnionTypeText       CompletionCreateParamsResponseFormatUnionType = "text"
	CompletionCreateParamsResponseFormatUnionTypeJSONObject CompletionCreateParamsResponseFormatUnionType = "json_object"
	CompletionCreateParamsResponseFormatUnionTypeJSONSchema CompletionCreateParamsResponseFormatUnionType = "json_schema"
	CompletionCreateParamsResponseFormatUnionTypeGrammar    CompletionCreateParamsResponseFormatUnionType = "grammar"
	CompletionCreateParamsResponseFormatUnionTypePython     CompletionCreateParamsResponseFormatUnionType = "python"
)

type CompletionCreateParamsResponseFormatUnion struct {
	CompletionCreateParamsResponseFormatText       *CompletionCreateParamsResponseFormatText       `queryParam:"inline" union:"member"`
	CompletionCreateParamsResponseFormatJSONObject *CompletionCreateParamsResponseFormatJSONObject `queryParam:"inline" union:"member"`
	ResponseFormatJSONSchema                       *ResponseFormatJSONSchema                       `queryParam:"inline" union:"member"`
	ResponseFormatTextGrammar                      *ResponseFormatTextGrammar                      `queryParam:"inline" union:"member"`
	CompletionCreateParamsResponseFormatPython     *CompletionCreateParamsResponseFormatPython     `queryParam:"inline" union:"member"`

	Type CompletionCreateParamsResponseFormatUnionType
}

func CreateCompletionCreateParamsResponseFormatUnionText(text CompletionCreateParamsResponseFormatText) CompletionCreateParamsResponseFormatUnion {
	typ := CompletionCreateParamsResponseFormatUnionTypeText

	return CompletionCreateParamsResponseFormatUnion{
		CompletionCreateParamsResponseFormatText: &text,
		Type:                                     typ,
	}
}

func CreateCompletionCreateParamsResponseFormatUnionJSONObject(jsonObject CompletionCreateParamsResponseFormatJSONObject) CompletionCreateParamsResponseFormatUnion {
	typ := CompletionCreateParamsResponseFormatUnionTypeJSONObject

	return CompletionCreateParamsResponseFormatUnion{
		CompletionCreateParamsResponseFormatJSONObject: &jsonObject,
		Type: typ,
	}
}

func CreateCompletionCreateParamsResponseFormatUnionJSONSchema(jsonSchema ResponseFormatJSONSchema) CompletionCreateParamsResponseFormatUnion {
	typ := CompletionCreateParamsResponseFormatUnionTypeJSONSchema

	return CompletionCreateParamsResponseFormatUnion{
		ResponseFormatJSONSchema: &jsonSchema,
		Type:                     typ,
	}
}

func CreateCompletionCreateParamsResponseFormatUnionGrammar(grammar ResponseFormatTextGrammar) CompletionCreateParamsResponseFormatUnion {
	typ := CompletionCreateParamsResponseFormatUnionTypeGrammar

	return CompletionCreateParamsResponseFormatUnion{
		ResponseFormatTextGrammar: &grammar,
		Type:                      typ,
	}
}

func CreateCompletionCreateParamsResponseFormatUnionPython(python CompletionCreateParamsResponseFormatPython) CompletionCreateParamsResponseFormatUnion {
	typ := CompletionCreateParamsResponseFormatUnionTypePython

	return CompletionCreateParamsResponseFormatUnion{
		CompletionCreateParamsResponseFormatPython: &python,
		Type: typ,
	}
}

func (u *CompletionCreateParamsResponseFormatUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "text":
		completionCreateParamsResponseFormatText := new(CompletionCreateParamsResponseFormatText)
		if err := utils.UnmarshalJSON(data, &completionCreateParamsResponseFormatText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == text) type CompletionCreateParamsResponseFormatText within CompletionCreateParamsResponseFormatUnion: %w", string(data), err)
		}

		u.CompletionCreateParamsResponseFormatText = completionCreateParamsResponseFormatText
		u.Type = CompletionCreateParamsResponseFormatUnionTypeText
		return nil
	case "json_object":
		completionCreateParamsResponseFormatJSONObject := new(CompletionCreateParamsResponseFormatJSONObject)
		if err := utils.UnmarshalJSON(data, &completionCreateParamsResponseFormatJSONObject, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == json_object) type CompletionCreateParamsResponseFormatJSONObject within CompletionCreateParamsResponseFormatUnion: %w", string(data), err)
		}

		u.CompletionCreateParamsResponseFormatJSONObject = completionCreateParamsResponseFormatJSONObject
		u.Type = CompletionCreateParamsResponseFormatUnionTypeJSONObject
		return nil
	case "json_schema":
		responseFormatJSONSchema := new(ResponseFormatJSONSchema)
		if err := utils.UnmarshalJSON(data, &responseFormatJSONSchema, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == json_schema) type ResponseFormatJSONSchema within CompletionCreateParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ResponseFormatJSONSchema = responseFormatJSONSchema
		u.Type = CompletionCreateParamsResponseFormatUnionTypeJSONSchema
		return nil
	case "grammar":
		responseFormatTextGrammar := new(ResponseFormatTextGrammar)
		if err := utils.UnmarshalJSON(data, &responseFormatTextGrammar, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == grammar) type ResponseFormatTextGrammar within CompletionCreateParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ResponseFormatTextGrammar = responseFormatTextGrammar
		u.Type = CompletionCreateParamsResponseFormatUnionTypeGrammar
		return nil
	case "python":
		completionCreateParamsResponseFormatPython := new(CompletionCreateParamsResponseFormatPython)
		if err := utils.UnmarshalJSON(data, &completionCreateParamsResponseFormatPython, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == python) type CompletionCreateParamsResponseFormatPython within CompletionCreateParamsResponseFormatUnion: %w", string(data), err)
		}

		u.CompletionCreateParamsResponseFormatPython = completionCreateParamsResponseFormatPython
		u.Type = CompletionCreateParamsResponseFormatUnionTypePython
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CompletionCreateParamsResponseFormatUnion", string(data))
}

func (u CompletionCreateParamsResponseFormatUnion) MarshalJSON() ([]byte, error) {
	if u.CompletionCreateParamsResponseFormatText != nil {
		return utils.MarshalJSON(u.CompletionCreateParamsResponseFormatText, "", true)
	}

	if u.CompletionCreateParamsResponseFormatJSONObject != nil {
		return utils.MarshalJSON(u.CompletionCreateParamsResponseFormatJSONObject, "", true)
	}

	if u.ResponseFormatJSONSchema != nil {
		return utils.MarshalJSON(u.ResponseFormatJSONSchema, "", true)
	}

	if u.ResponseFormatTextGrammar != nil {
		return utils.MarshalJSON(u.ResponseFormatTextGrammar, "", true)
	}

	if u.CompletionCreateParamsResponseFormatPython != nil {
		return utils.MarshalJSON(u.CompletionCreateParamsResponseFormatPython, "", true)
	}

	return nil, errors.New("could not marshal union type CompletionCreateParamsResponseFormatUnion: all fields are null")
}

type CompletionCreateParams struct {
	Model            *string                                                                      `json:"model,omitzero"`
	Models           []string                                                                     `json:"models,omitzero"`
	Prompt           Prompt                                                                       `json:"prompt"`
	BestOf           optionalnullable.OptionalNullable[int64]                                     `json:"best_of,omitzero"`
	Echo             optionalnullable.OptionalNullable[bool]                                      `json:"echo,omitzero"`
	FrequencyPenalty optionalnullable.OptionalNullable[float64]                                   `json:"frequency_penalty,omitzero"`
	LogitBias        optionalnullable.OptionalNullable[map[string]float64]                        `json:"logit_bias,omitzero"`
	Logprobs         optionalnullable.OptionalNullable[int64]                                     `json:"logprobs,omitzero"`
	MaxTokens        optionalnullable.OptionalNullable[int64]                                     `json:"max_tokens,omitzero"`
	N                optionalnullable.OptionalNullable[int64]                                     `json:"n,omitzero"`
	PresencePenalty  optionalnullable.OptionalNullable[float64]                                   `json:"presence_penalty,omitzero"`
	Seed             optionalnullable.OptionalNullable[int64]                                     `json:"seed,omitzero"`
	Stop             optionalnullable.OptionalNullable[CompletionCreateParamsStop]                `json:"stop,omitzero"`
	Stream           *bool                                                                        `default:"false" json:"stream"`
	StreamOptions    optionalnullable.OptionalNullable[StreamOptions]                             `json:"stream_options,omitzero"`
	Suffix           optionalnullable.OptionalNullable[string]                                    `json:"suffix,omitzero"`
	Temperature      optionalnullable.OptionalNullable[float64]                                   `json:"temperature,omitzero"`
	TopP             optionalnullable.OptionalNullable[float64]                                   `json:"top_p,omitzero"`
	User             *string                                                                      `json:"user,omitzero"`
	Metadata         optionalnullable.OptionalNullable[map[string]string]                         `json:"metadata,omitzero"`
	ResponseFormat   optionalnullable.OptionalNullable[CompletionCreateParamsResponseFormatUnion] `json:"response_format,omitzero"`
}

func (c CompletionCreateParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CompletionCreateParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CompletionCreateParams) GetModel() *string {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *CompletionCreateParams) GetModels() []string {
	if c == nil {
		return nil
	}
	return c.Models
}

func (c *CompletionCreateParams) GetPrompt() Prompt {
	if c == nil {
		return Prompt{}
	}
	return c.Prompt
}

func (c *CompletionCreateParams) GetBestOf() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.BestOf
}

func (c *CompletionCreateParams) GetEcho() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.Echo
}

func (c *CompletionCreateParams) GetFrequencyPenalty() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.FrequencyPenalty
}

func (c *CompletionCreateParams) GetLogitBias() optionalnullable.OptionalNullable[map[string]float64] {
	if c == nil {
		return nil
	}
	return c.LogitBias
}

func (c *CompletionCreateParams) GetLogprobs() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.Logprobs
}

func (c *CompletionCreateParams) GetMaxTokens() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.MaxTokens
}

func (c *CompletionCreateParams) GetN() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.N
}

func (c *CompletionCreateParams) GetPresencePenalty() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.PresencePenalty
}

func (c *CompletionCreateParams) GetSeed() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.Seed
}

func (c *CompletionCreateParams) GetStop() optionalnullable.OptionalNullable[CompletionCreateParamsStop] {
	if c == nil {
		return nil
	}
	return c.Stop
}

func (c *CompletionCreateParams) GetStream() *bool {
	if c == nil {
		return nil
	}
	return c.Stream
}

func (c *CompletionCreateParams) GetStreamOptions() optionalnullable.OptionalNullable[StreamOptions] {
	if c == nil {
		return nil
	}
	return c.StreamOptions
}

func (c *CompletionCreateParams) GetSuffix() optionalnullable.OptionalNullable[string] {
	if c == nil {
		return nil
	}
	return c.Suffix
}

func (c *CompletionCreateParams) GetTemperature() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.Temperature
}

func (c *CompletionCreateParams) GetTopP() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.TopP
}

func (c *CompletionCreateParams) GetUser() *string {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *CompletionCreateParams) GetMetadata() optionalnullable.OptionalNullable[map[string]string] {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CompletionCreateParams) GetResponseFormat() optionalnullable.OptionalNullable[CompletionCreateParamsResponseFormatUnion] {
	if c == nil {
		return nil
	}
	return c.ResponseFormat
}

func (c *CompletionCreateParams) GetResponseFormatText() *CompletionCreateParamsResponseFormatText {
	if v := c.GetResponseFormat(); v != nil {
		if actualValue, ok := v.Get(); ok && actualValue != nil {
			return actualValue.CompletionCreateParamsResponseFormatText
		}
		return nil
	}
	return nil
}

func (c *CompletionCreateParams) GetResponseFormatJSONObject() *CompletionCreateParamsResponseFormatJSONObject {
	if v := c.GetResponseFormat(); v != nil {
		if actualValue, ok := v.Get(); ok && actualValue != nil {
			return actualValue.CompletionCreateParamsResponseFormatJSONObject
		}
		return nil
	}
	return nil
}

func (c *CompletionCreateParams) GetResponseFormatJSONSchema() *ResponseFormatJSONSchema {
	if v := c.GetResponseFormat(); v != nil {
		if actualValue, ok := v.Get(); ok && actualValue != nil {
			return actualValue.ResponseFormatJSONSchema
		}
		return nil
	}
	return nil
}

func (c *CompletionCreateParams) GetResponseFormatGrammar() *ResponseFormatTextGrammar {
	if v := c.GetResponseFormat(); v != nil {
		if actualValue, ok := v.Get(); ok && actualValue != nil {
			return actualValue.ResponseFormatTextGrammar
		}
		return nil
	}
	return nil
}

func (c *CompletionCreateParams) GetResponseFormatPython() *CompletionCreateParamsResponseFormatPython {
	if v := c.GetResponseFormat(); v != nil {
		if actualValue, ok := v.Get(); ok && actualValue != nil {
			return actualValue.CompletionCreateParamsResponseFormatPython
		}
		return nil
	}
	return nil
}
