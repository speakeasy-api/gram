// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
)

type Schema0Enum string

const (
	Schema0EnumAi21            Schema0Enum = "AI21"
	Schema0EnumAionLabs        Schema0Enum = "AionLabs"
	Schema0EnumAlibaba         Schema0Enum = "Alibaba"
	Schema0EnumAmazonBedrock   Schema0Enum = "Amazon Bedrock"
	Schema0EnumAmazonNova      Schema0Enum = "Amazon Nova"
	Schema0EnumAnthropic       Schema0Enum = "Anthropic"
	Schema0EnumArceeAi         Schema0Enum = "Arcee AI"
	Schema0EnumAtlasCloud      Schema0Enum = "AtlasCloud"
	Schema0EnumAvian           Schema0Enum = "Avian"
	Schema0EnumAzure           Schema0Enum = "Azure"
	Schema0EnumBaseTen         Schema0Enum = "BaseTen"
	Schema0EnumBytePlus        Schema0Enum = "BytePlus"
	Schema0EnumBlackForestLabs Schema0Enum = "Black Forest Labs"
	Schema0EnumCerebras        Schema0Enum = "Cerebras"
	Schema0EnumChutes          Schema0Enum = "Chutes"
	Schema0EnumCirrascale      Schema0Enum = "Cirrascale"
	Schema0EnumClarifai        Schema0Enum = "Clarifai"
	Schema0EnumCloudflare      Schema0Enum = "Cloudflare"
	Schema0EnumCohere          Schema0Enum = "Cohere"
	Schema0EnumCrusoe          Schema0Enum = "Crusoe"
	Schema0EnumDeepInfra       Schema0Enum = "DeepInfra"
	Schema0EnumDeepSeek        Schema0Enum = "DeepSeek"
	Schema0EnumFeatherless     Schema0Enum = "Featherless"
	Schema0EnumFireworks       Schema0Enum = "Fireworks"
	Schema0EnumFriendli        Schema0Enum = "Friendli"
	Schema0EnumGmiCloud        Schema0Enum = "GMICloud"
	Schema0EnumGoogle          Schema0Enum = "Google"
	Schema0EnumGoogleAiStudio  Schema0Enum = "Google AI Studio"
	Schema0EnumGroq            Schema0Enum = "Groq"
	Schema0EnumHyperbolic      Schema0Enum = "Hyperbolic"
	Schema0EnumInception       Schema0Enum = "Inception"
	Schema0EnumInceptron       Schema0Enum = "Inceptron"
	Schema0EnumInferenceNet    Schema0Enum = "InferenceNet"
	Schema0EnumInfermatic      Schema0Enum = "Infermatic"
	Schema0EnumInflection      Schema0Enum = "Inflection"
	Schema0EnumLiquid          Schema0Enum = "Liquid"
	Schema0EnumMara            Schema0Enum = "Mara"
	Schema0EnumMancer2         Schema0Enum = "Mancer 2"
	Schema0EnumMinimax         Schema0Enum = "Minimax"
	Schema0EnumModelRun        Schema0Enum = "ModelRun"
	Schema0EnumMistral         Schema0Enum = "Mistral"
	Schema0EnumModular         Schema0Enum = "Modular"
	Schema0EnumMoonshotAi      Schema0Enum = "Moonshot AI"
	Schema0EnumMorph           Schema0Enum = "Morph"
	Schema0EnumNCompass        Schema0Enum = "NCompass"
	Schema0EnumNebius          Schema0Enum = "Nebius"
	Schema0EnumNextBit         Schema0Enum = "NextBit"
	Schema0EnumNovita          Schema0Enum = "Novita"
	Schema0EnumNvidia          Schema0Enum = "Nvidia"
	Schema0EnumOpenAi          Schema0Enum = "OpenAI"
	Schema0EnumOpenInference   Schema0Enum = "OpenInference"
	Schema0EnumParasail        Schema0Enum = "Parasail"
	Schema0EnumPerplexity      Schema0Enum = "Perplexity"
	Schema0EnumPhala           Schema0Enum = "Phala"
	Schema0EnumRelace          Schema0Enum = "Relace"
	Schema0EnumSambaNova       Schema0Enum = "SambaNova"
	Schema0EnumSeed            Schema0Enum = "Seed"
	Schema0EnumSiliconFlow     Schema0Enum = "SiliconFlow"
	Schema0EnumSourceful       Schema0Enum = "Sourceful"
	Schema0EnumStealth         Schema0Enum = "Stealth"
	Schema0EnumStreamLake      Schema0Enum = "StreamLake"
	Schema0EnumSwitchpoint     Schema0Enum = "Switchpoint"
	Schema0EnumTogether        Schema0Enum = "Together"
	Schema0EnumUpstage         Schema0Enum = "Upstage"
	Schema0EnumVenice          Schema0Enum = "Venice"
	Schema0EnumWandB           Schema0Enum = "WandB"
	Schema0EnumXiaomi          Schema0Enum = "Xiaomi"
	Schema0EnumXAi             Schema0Enum = "xAI"
	Schema0EnumZAi             Schema0Enum = "Z.AI"
	Schema0EnumFakeProvider    Schema0Enum = "FakeProvider"
)

func (e Schema0Enum) ToPointer() *Schema0Enum {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Schema0Enum) IsExact() bool {
	if e != nil {
		switch *e {
		case "AI21", "AionLabs", "Alibaba", "Amazon Bedrock", "Amazon Nova", "Anthropic", "Arcee AI", "AtlasCloud", "Avian", "Azure", "BaseTen", "BytePlus", "Black Forest Labs", "Cerebras", "Chutes", "Cirrascale", "Clarifai", "Cloudflare", "Cohere", "Crusoe", "DeepInfra", "DeepSeek", "Featherless", "Fireworks", "Friendli", "GMICloud", "Google", "Google AI Studio", "Groq", "Hyperbolic", "Inception", "Inceptron", "InferenceNet", "Infermatic", "Inflection", "Liquid", "Mara", "Mancer 2", "Minimax", "ModelRun", "Mistral", "Modular", "Moonshot AI", "Morph", "NCompass", "Nebius", "NextBit", "Novita", "Nvidia", "OpenAI", "OpenInference", "Parasail", "Perplexity", "Phala", "Relace", "SambaNova", "Seed", "SiliconFlow", "Sourceful", "Stealth", "StreamLake", "Switchpoint", "Together", "Upstage", "Venice", "WandB", "Xiaomi", "xAI", "Z.AI", "FakeProvider":
			return true
		}
	}
	return false
}

type Schema0Type string

const (
	Schema0TypeSchema0Enum Schema0Type = "__schema0_enum"
	Schema0TypeStr         Schema0Type = "str"
)

type Schema0 struct {
	Schema0Enum *Schema0Enum `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`

	Type Schema0Type
}

func CreateSchema0Schema0Enum(schema0Enum Schema0Enum) Schema0 {
	typ := Schema0TypeSchema0Enum

	return Schema0{
		Schema0Enum: &schema0Enum,
		Type:        typ,
	}
}

func CreateSchema0Str(str string) Schema0 {
	typ := Schema0TypeStr

	return Schema0{
		Str:  &str,
		Type: typ,
	}
}

func (u *Schema0) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var schema0Enum Schema0Enum = Schema0Enum("")
	if err := utils.UnmarshalJSON(data, &schema0Enum, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  Schema0TypeSchema0Enum,
			Value: &schema0Enum,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  Schema0TypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schema0", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schema0", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(Schema0Type)
	switch best.Type {
	case Schema0TypeSchema0Enum:
		u.Schema0Enum = best.Value.(*Schema0Enum)
		return nil
	case Schema0TypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schema0", string(data))
}

func (u Schema0) MarshalJSON() ([]byte, error) {
	if u.Schema0Enum != nil {
		return utils.MarshalJSON(u.Schema0Enum, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Schema0: all fields are null")
}
