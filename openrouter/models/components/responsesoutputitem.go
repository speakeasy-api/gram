// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
)

type ResponsesOutputItemType string

const (
	ResponsesOutputItemTypeMessage             ResponsesOutputItemType = "message"
	ResponsesOutputItemTypeReasoning           ResponsesOutputItemType = "reasoning"
	ResponsesOutputItemTypeFunctionCall        ResponsesOutputItemType = "function_call"
	ResponsesOutputItemTypeWebSearchCall       ResponsesOutputItemType = "web_search_call"
	ResponsesOutputItemTypeFileSearchCall      ResponsesOutputItemType = "file_search_call"
	ResponsesOutputItemTypeImageGenerationCall ResponsesOutputItemType = "image_generation_call"
)

// ResponsesOutputItem - An output item from the response
type ResponsesOutputItem struct {
	ResponsesOutputMessage            *ResponsesOutputMessage            `queryParam:"inline" union:"member"`
	ResponsesOutputItemReasoning      *ResponsesOutputItemReasoning      `queryParam:"inline" union:"member"`
	ResponsesOutputItemFunctionCall   *ResponsesOutputItemFunctionCall   `queryParam:"inline" union:"member"`
	ResponsesWebSearchCallOutput      *ResponsesWebSearchCallOutput      `queryParam:"inline" union:"member"`
	ResponsesOutputItemFileSearchCall *ResponsesOutputItemFileSearchCall `queryParam:"inline" union:"member"`
	ResponsesImageGenerationCall      *ResponsesImageGenerationCall      `queryParam:"inline" union:"member"`

	Type ResponsesOutputItemType
}

func CreateResponsesOutputItemMessage(message ResponsesOutputMessage) ResponsesOutputItem {
	typ := ResponsesOutputItemTypeMessage

	typStr := ResponsesOutputMessageType(typ)
	message.Type = typStr

	return ResponsesOutputItem{
		ResponsesOutputMessage: &message,
		Type:                   typ,
	}
}

func CreateResponsesOutputItemReasoning(reasoning ResponsesOutputItemReasoning) ResponsesOutputItem {
	typ := ResponsesOutputItemTypeReasoning

	typStr := ResponsesOutputItemReasoningType(typ)
	reasoning.Type = typStr

	return ResponsesOutputItem{
		ResponsesOutputItemReasoning: &reasoning,
		Type:                         typ,
	}
}

func CreateResponsesOutputItemFunctionCall(functionCall ResponsesOutputItemFunctionCall) ResponsesOutputItem {
	typ := ResponsesOutputItemTypeFunctionCall

	typStr := ResponsesOutputItemFunctionCallType(typ)
	functionCall.Type = typStr

	return ResponsesOutputItem{
		ResponsesOutputItemFunctionCall: &functionCall,
		Type:                            typ,
	}
}

func CreateResponsesOutputItemWebSearchCall(webSearchCall ResponsesWebSearchCallOutput) ResponsesOutputItem {
	typ := ResponsesOutputItemTypeWebSearchCall

	typStr := ResponsesWebSearchCallOutputType(typ)
	webSearchCall.Type = typStr

	return ResponsesOutputItem{
		ResponsesWebSearchCallOutput: &webSearchCall,
		Type:                         typ,
	}
}

func CreateResponsesOutputItemFileSearchCall(fileSearchCall ResponsesOutputItemFileSearchCall) ResponsesOutputItem {
	typ := ResponsesOutputItemTypeFileSearchCall

	typStr := ResponsesOutputItemFileSearchCallType(typ)
	fileSearchCall.Type = typStr

	return ResponsesOutputItem{
		ResponsesOutputItemFileSearchCall: &fileSearchCall,
		Type:                              typ,
	}
}

func CreateResponsesOutputItemImageGenerationCall(imageGenerationCall ResponsesImageGenerationCall) ResponsesOutputItem {
	typ := ResponsesOutputItemTypeImageGenerationCall

	typStr := ResponsesImageGenerationCallType(typ)
	imageGenerationCall.Type = typStr

	return ResponsesOutputItem{
		ResponsesImageGenerationCall: &imageGenerationCall,
		Type:                         typ,
	}
}

func (u *ResponsesOutputItem) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "message":
		responsesOutputMessage := new(ResponsesOutputMessage)
		if err := utils.UnmarshalJSON(data, &responsesOutputMessage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == message) type ResponsesOutputMessage within ResponsesOutputItem: %w", string(data), err)
		}

		u.ResponsesOutputMessage = responsesOutputMessage
		u.Type = ResponsesOutputItemTypeMessage
		return nil
	case "reasoning":
		responsesOutputItemReasoning := new(ResponsesOutputItemReasoning)
		if err := utils.UnmarshalJSON(data, &responsesOutputItemReasoning, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == reasoning) type ResponsesOutputItemReasoning within ResponsesOutputItem: %w", string(data), err)
		}

		u.ResponsesOutputItemReasoning = responsesOutputItemReasoning
		u.Type = ResponsesOutputItemTypeReasoning
		return nil
	case "function_call":
		responsesOutputItemFunctionCall := new(ResponsesOutputItemFunctionCall)
		if err := utils.UnmarshalJSON(data, &responsesOutputItemFunctionCall, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == function_call) type ResponsesOutputItemFunctionCall within ResponsesOutputItem: %w", string(data), err)
		}

		u.ResponsesOutputItemFunctionCall = responsesOutputItemFunctionCall
		u.Type = ResponsesOutputItemTypeFunctionCall
		return nil
	case "web_search_call":
		responsesWebSearchCallOutput := new(ResponsesWebSearchCallOutput)
		if err := utils.UnmarshalJSON(data, &responsesWebSearchCallOutput, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == web_search_call) type ResponsesWebSearchCallOutput within ResponsesOutputItem: %w", string(data), err)
		}

		u.ResponsesWebSearchCallOutput = responsesWebSearchCallOutput
		u.Type = ResponsesOutputItemTypeWebSearchCall
		return nil
	case "file_search_call":
		responsesOutputItemFileSearchCall := new(ResponsesOutputItemFileSearchCall)
		if err := utils.UnmarshalJSON(data, &responsesOutputItemFileSearchCall, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == file_search_call) type ResponsesOutputItemFileSearchCall within ResponsesOutputItem: %w", string(data), err)
		}

		u.ResponsesOutputItemFileSearchCall = responsesOutputItemFileSearchCall
		u.Type = ResponsesOutputItemTypeFileSearchCall
		return nil
	case "image_generation_call":
		responsesImageGenerationCall := new(ResponsesImageGenerationCall)
		if err := utils.UnmarshalJSON(data, &responsesImageGenerationCall, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == image_generation_call) type ResponsesImageGenerationCall within ResponsesOutputItem: %w", string(data), err)
		}

		u.ResponsesImageGenerationCall = responsesImageGenerationCall
		u.Type = ResponsesOutputItemTypeImageGenerationCall
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ResponsesOutputItem", string(data))
}

func (u ResponsesOutputItem) MarshalJSON() ([]byte, error) {
	if u.ResponsesOutputMessage != nil {
		return utils.MarshalJSON(u.ResponsesOutputMessage, "", true)
	}

	if u.ResponsesOutputItemReasoning != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemReasoning, "", true)
	}

	if u.ResponsesOutputItemFunctionCall != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemFunctionCall, "", true)
	}

	if u.ResponsesWebSearchCallOutput != nil {
		return utils.MarshalJSON(u.ResponsesWebSearchCallOutput, "", true)
	}

	if u.ResponsesOutputItemFileSearchCall != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemFileSearchCall, "", true)
	}

	if u.ResponsesImageGenerationCall != nil {
		return utils.MarshalJSON(u.ResponsesImageGenerationCall, "", true)
	}

	return nil, errors.New("could not marshal union type ResponsesOutputItem: all fields are null")
}
