// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
	"github.com/speakeasy-api/gram/openrouter/types"
)

type OpenResponsesRequestType string

const (
	OpenResponsesRequestTypeFunction OpenResponsesRequestType = "function"
)

func (e OpenResponsesRequestType) ToPointer() *OpenResponsesRequestType {
	return &e
}
func (e *OpenResponsesRequestType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "function":
		*e = OpenResponsesRequestType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesRequestType: %v", v)
	}
}

// OpenResponsesRequestToolFunction - Function tool definition
type OpenResponsesRequestToolFunction struct {
	Type        OpenResponsesRequestType                  `json:"type"`
	Name        string                                    `json:"name"`
	Description optionalnullable.OptionalNullable[string] `json:"description,omitzero"`
	Strict      optionalnullable.OptionalNullable[bool]   `json:"strict,omitzero"`
	Parameters  map[string]any                            `json:"parameters"`
}

func (o OpenResponsesRequestToolFunction) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestToolFunction) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestToolFunction) GetType() OpenResponsesRequestType {
	if o == nil {
		return OpenResponsesRequestType("")
	}
	return o.Type
}

func (o *OpenResponsesRequestToolFunction) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *OpenResponsesRequestToolFunction) GetDescription() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OpenResponsesRequestToolFunction) GetStrict() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.Strict
}

func (o *OpenResponsesRequestToolFunction) GetParameters() map[string]any {
	if o == nil {
		return nil
	}
	return o.Parameters
}

type OpenResponsesRequestToolUnionType string

const (
	OpenResponsesRequestToolUnionTypeFunction                 OpenResponsesRequestToolUnionType = "function"
	OpenResponsesRequestToolUnionTypeWebSearchPreview         OpenResponsesRequestToolUnionType = "web_search_preview"
	OpenResponsesRequestToolUnionTypeWebSearchPreview20250311 OpenResponsesRequestToolUnionType = "web_search_preview_2025_03_11"
	OpenResponsesRequestToolUnionTypeWebSearch                OpenResponsesRequestToolUnionType = "web_search"
	OpenResponsesRequestToolUnionTypeWebSearch20250826        OpenResponsesRequestToolUnionType = "web_search_2025_08_26"
)

type OpenResponsesRequestToolUnion struct {
	OpenResponsesRequestToolFunction          *OpenResponsesRequestToolFunction          `queryParam:"inline" union:"member"`
	OpenResponsesWebSearchPreviewTool         *OpenResponsesWebSearchPreviewTool         `queryParam:"inline" union:"member"`
	OpenResponsesWebSearchPreview20250311Tool *OpenResponsesWebSearchPreview20250311Tool `queryParam:"inline" union:"member"`
	OpenResponsesWebSearchTool                *OpenResponsesWebSearchTool                `queryParam:"inline" union:"member"`
	OpenResponsesWebSearch20250826Tool        *OpenResponsesWebSearch20250826Tool        `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestToolUnionType
}

func CreateOpenResponsesRequestToolUnionFunction(function OpenResponsesRequestToolFunction) OpenResponsesRequestToolUnion {
	typ := OpenResponsesRequestToolUnionTypeFunction

	typStr := OpenResponsesRequestType(typ)
	function.Type = typStr

	return OpenResponsesRequestToolUnion{
		OpenResponsesRequestToolFunction: &function,
		Type:                             typ,
	}
}

func CreateOpenResponsesRequestToolUnionWebSearchPreview(webSearchPreview OpenResponsesWebSearchPreviewTool) OpenResponsesRequestToolUnion {
	typ := OpenResponsesRequestToolUnionTypeWebSearchPreview

	typStr := OpenResponsesWebSearchPreviewToolType(typ)
	webSearchPreview.Type = typStr

	return OpenResponsesRequestToolUnion{
		OpenResponsesWebSearchPreviewTool: &webSearchPreview,
		Type:                              typ,
	}
}

func CreateOpenResponsesRequestToolUnionWebSearchPreview20250311(webSearchPreview20250311 OpenResponsesWebSearchPreview20250311Tool) OpenResponsesRequestToolUnion {
	typ := OpenResponsesRequestToolUnionTypeWebSearchPreview20250311

	typStr := OpenResponsesWebSearchPreview20250311ToolType(typ)
	webSearchPreview20250311.Type = typStr

	return OpenResponsesRequestToolUnion{
		OpenResponsesWebSearchPreview20250311Tool: &webSearchPreview20250311,
		Type: typ,
	}
}

func CreateOpenResponsesRequestToolUnionWebSearch(webSearch OpenResponsesWebSearchTool) OpenResponsesRequestToolUnion {
	typ := OpenResponsesRequestToolUnionTypeWebSearch

	typStr := OpenResponsesWebSearchToolType(typ)
	webSearch.Type = typStr

	return OpenResponsesRequestToolUnion{
		OpenResponsesWebSearchTool: &webSearch,
		Type:                       typ,
	}
}

func CreateOpenResponsesRequestToolUnionWebSearch20250826(webSearch20250826 OpenResponsesWebSearch20250826Tool) OpenResponsesRequestToolUnion {
	typ := OpenResponsesRequestToolUnionTypeWebSearch20250826

	typStr := OpenResponsesWebSearch20250826ToolType(typ)
	webSearch20250826.Type = typStr

	return OpenResponsesRequestToolUnion{
		OpenResponsesWebSearch20250826Tool: &webSearch20250826,
		Type:                               typ,
	}
}

func (u *OpenResponsesRequestToolUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "function":
		openResponsesRequestToolFunction := new(OpenResponsesRequestToolFunction)
		if err := utils.UnmarshalJSON(data, &openResponsesRequestToolFunction, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == function) type OpenResponsesRequestToolFunction within OpenResponsesRequestToolUnion: %w", string(data), err)
		}

		u.OpenResponsesRequestToolFunction = openResponsesRequestToolFunction
		u.Type = OpenResponsesRequestToolUnionTypeFunction
		return nil
	case "web_search_preview":
		openResponsesWebSearchPreviewTool := new(OpenResponsesWebSearchPreviewTool)
		if err := utils.UnmarshalJSON(data, &openResponsesWebSearchPreviewTool, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == web_search_preview) type OpenResponsesWebSearchPreviewTool within OpenResponsesRequestToolUnion: %w", string(data), err)
		}

		u.OpenResponsesWebSearchPreviewTool = openResponsesWebSearchPreviewTool
		u.Type = OpenResponsesRequestToolUnionTypeWebSearchPreview
		return nil
	case "web_search_preview_2025_03_11":
		openResponsesWebSearchPreview20250311Tool := new(OpenResponsesWebSearchPreview20250311Tool)
		if err := utils.UnmarshalJSON(data, &openResponsesWebSearchPreview20250311Tool, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == web_search_preview_2025_03_11) type OpenResponsesWebSearchPreview20250311Tool within OpenResponsesRequestToolUnion: %w", string(data), err)
		}

		u.OpenResponsesWebSearchPreview20250311Tool = openResponsesWebSearchPreview20250311Tool
		u.Type = OpenResponsesRequestToolUnionTypeWebSearchPreview20250311
		return nil
	case "web_search":
		openResponsesWebSearchTool := new(OpenResponsesWebSearchTool)
		if err := utils.UnmarshalJSON(data, &openResponsesWebSearchTool, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == web_search) type OpenResponsesWebSearchTool within OpenResponsesRequestToolUnion: %w", string(data), err)
		}

		u.OpenResponsesWebSearchTool = openResponsesWebSearchTool
		u.Type = OpenResponsesRequestToolUnionTypeWebSearch
		return nil
	case "web_search_2025_08_26":
		openResponsesWebSearch20250826Tool := new(OpenResponsesWebSearch20250826Tool)
		if err := utils.UnmarshalJSON(data, &openResponsesWebSearch20250826Tool, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == web_search_2025_08_26) type OpenResponsesWebSearch20250826Tool within OpenResponsesRequestToolUnion: %w", string(data), err)
		}

		u.OpenResponsesWebSearch20250826Tool = openResponsesWebSearch20250826Tool
		u.Type = OpenResponsesRequestToolUnionTypeWebSearch20250826
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestToolUnion", string(data))
}

func (u OpenResponsesRequestToolUnion) MarshalJSON() ([]byte, error) {
	if u.OpenResponsesRequestToolFunction != nil {
		return utils.MarshalJSON(u.OpenResponsesRequestToolFunction, "", true)
	}

	if u.OpenResponsesWebSearchPreviewTool != nil {
		return utils.MarshalJSON(u.OpenResponsesWebSearchPreviewTool, "", true)
	}

	if u.OpenResponsesWebSearchPreview20250311Tool != nil {
		return utils.MarshalJSON(u.OpenResponsesWebSearchPreview20250311Tool, "", true)
	}

	if u.OpenResponsesWebSearchTool != nil {
		return utils.MarshalJSON(u.OpenResponsesWebSearchTool, "", true)
	}

	if u.OpenResponsesWebSearch20250826Tool != nil {
		return utils.MarshalJSON(u.OpenResponsesWebSearch20250826Tool, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestToolUnion: all fields are null")
}

type OpenResponsesRequestImageConfigType string

const (
	OpenResponsesRequestImageConfigTypeStr    OpenResponsesRequestImageConfigType = "str"
	OpenResponsesRequestImageConfigTypeNumber OpenResponsesRequestImageConfigType = "number"
)

type OpenResponsesRequestImageConfig struct {
	Str    *string  `queryParam:"inline" union:"member"`
	Number *float64 `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestImageConfigType
}

func CreateOpenResponsesRequestImageConfigStr(str string) OpenResponsesRequestImageConfig {
	typ := OpenResponsesRequestImageConfigTypeStr

	return OpenResponsesRequestImageConfig{
		Str:  &str,
		Type: typ,
	}
}

func CreateOpenResponsesRequestImageConfigNumber(number float64) OpenResponsesRequestImageConfig {
	typ := OpenResponsesRequestImageConfigTypeNumber

	return OpenResponsesRequestImageConfig{
		Number: &number,
		Type:   typ,
	}
}

func (u *OpenResponsesRequestImageConfig) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestImageConfigTypeStr,
			Value: &str,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestImageConfigTypeNumber,
			Value: &number,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestImageConfig", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestImageConfig", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesRequestImageConfigType)
	switch best.Type {
	case OpenResponsesRequestImageConfigTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case OpenResponsesRequestImageConfigTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestImageConfig", string(data))
}

func (u OpenResponsesRequestImageConfig) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestImageConfig: all fields are null")
}

type ServiceTier string

const (
	ServiceTierAuto ServiceTier = "auto"
)

func (e ServiceTier) ToPointer() *ServiceTier {
	return &e
}
func (e *ServiceTier) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		*e = ServiceTier(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ServiceTier: %v", v)
	}
}

type Truncation string

const (
	TruncationAuto     Truncation = "auto"
	TruncationDisabled Truncation = "disabled"
)

func (e Truncation) ToPointer() *Truncation {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Truncation) IsExact() bool {
	if e != nil {
		switch *e {
		case "auto", "disabled":
			return true
		}
	}
	return false
}

type OpenResponsesRequestOrderType string

const (
	OpenResponsesRequestOrderTypeProviderName OpenResponsesRequestOrderType = "ProviderName"
	OpenResponsesRequestOrderTypeStr          OpenResponsesRequestOrderType = "str"
)

type OpenResponsesRequestOrder struct {
	ProviderName *ProviderName `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestOrderType
}

func CreateOpenResponsesRequestOrderProviderName(providerName ProviderName) OpenResponsesRequestOrder {
	typ := OpenResponsesRequestOrderTypeProviderName

	return OpenResponsesRequestOrder{
		ProviderName: &providerName,
		Type:         typ,
	}
}

func CreateOpenResponsesRequestOrderStr(str string) OpenResponsesRequestOrder {
	typ := OpenResponsesRequestOrderTypeStr

	return OpenResponsesRequestOrder{
		Str:  &str,
		Type: typ,
	}
}

func (u *OpenResponsesRequestOrder) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerName ProviderName = ProviderName("")
	if err := utils.UnmarshalJSON(data, &providerName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestOrderTypeProviderName,
			Value: &providerName,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestOrderTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestOrder", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestOrder", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesRequestOrderType)
	switch best.Type {
	case OpenResponsesRequestOrderTypeProviderName:
		u.ProviderName = best.Value.(*ProviderName)
		return nil
	case OpenResponsesRequestOrderTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestOrder", string(data))
}

func (u OpenResponsesRequestOrder) MarshalJSON() ([]byte, error) {
	if u.ProviderName != nil {
		return utils.MarshalJSON(u.ProviderName, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestOrder: all fields are null")
}

type OpenResponsesRequestOnlyType string

const (
	OpenResponsesRequestOnlyTypeProviderName OpenResponsesRequestOnlyType = "ProviderName"
	OpenResponsesRequestOnlyTypeStr          OpenResponsesRequestOnlyType = "str"
)

type OpenResponsesRequestOnly struct {
	ProviderName *ProviderName `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestOnlyType
}

func CreateOpenResponsesRequestOnlyProviderName(providerName ProviderName) OpenResponsesRequestOnly {
	typ := OpenResponsesRequestOnlyTypeProviderName

	return OpenResponsesRequestOnly{
		ProviderName: &providerName,
		Type:         typ,
	}
}

func CreateOpenResponsesRequestOnlyStr(str string) OpenResponsesRequestOnly {
	typ := OpenResponsesRequestOnlyTypeStr

	return OpenResponsesRequestOnly{
		Str:  &str,
		Type: typ,
	}
}

func (u *OpenResponsesRequestOnly) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerName ProviderName = ProviderName("")
	if err := utils.UnmarshalJSON(data, &providerName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestOnlyTypeProviderName,
			Value: &providerName,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestOnlyTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestOnly", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestOnly", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesRequestOnlyType)
	switch best.Type {
	case OpenResponsesRequestOnlyTypeProviderName:
		u.ProviderName = best.Value.(*ProviderName)
		return nil
	case OpenResponsesRequestOnlyTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestOnly", string(data))
}

func (u OpenResponsesRequestOnly) MarshalJSON() ([]byte, error) {
	if u.ProviderName != nil {
		return utils.MarshalJSON(u.ProviderName, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestOnly: all fields are null")
}

type OpenResponsesRequestIgnoreType string

const (
	OpenResponsesRequestIgnoreTypeProviderName OpenResponsesRequestIgnoreType = "ProviderName"
	OpenResponsesRequestIgnoreTypeStr          OpenResponsesRequestIgnoreType = "str"
)

type OpenResponsesRequestIgnore struct {
	ProviderName *ProviderName `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestIgnoreType
}

func CreateOpenResponsesRequestIgnoreProviderName(providerName ProviderName) OpenResponsesRequestIgnore {
	typ := OpenResponsesRequestIgnoreTypeProviderName

	return OpenResponsesRequestIgnore{
		ProviderName: &providerName,
		Type:         typ,
	}
}

func CreateOpenResponsesRequestIgnoreStr(str string) OpenResponsesRequestIgnore {
	typ := OpenResponsesRequestIgnoreTypeStr

	return OpenResponsesRequestIgnore{
		Str:  &str,
		Type: typ,
	}
}

func (u *OpenResponsesRequestIgnore) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerName ProviderName = ProviderName("")
	if err := utils.UnmarshalJSON(data, &providerName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestIgnoreTypeProviderName,
			Value: &providerName,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestIgnoreTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestIgnore", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestIgnore", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesRequestIgnoreType)
	switch best.Type {
	case OpenResponsesRequestIgnoreTypeProviderName:
		u.ProviderName = best.Value.(*ProviderName)
		return nil
	case OpenResponsesRequestIgnoreTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestIgnore", string(data))
}

func (u OpenResponsesRequestIgnore) MarshalJSON() ([]byte, error) {
	if u.ProviderName != nil {
		return utils.MarshalJSON(u.ProviderName, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestIgnore: all fields are null")
}

type OpenResponsesRequestSortType string

const (
	OpenResponsesRequestSortTypeProviderSort       OpenResponsesRequestSortType = "ProviderSort"
	OpenResponsesRequestSortTypeProviderSortConfig OpenResponsesRequestSortType = "ProviderSortConfig"
	OpenResponsesRequestSortTypeAny                OpenResponsesRequestSortType = "any"
)

// OpenResponsesRequestSort - The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
type OpenResponsesRequestSort struct {
	ProviderSort       *ProviderSort       `queryParam:"inline" union:"member"`
	ProviderSortConfig *ProviderSortConfig `queryParam:"inline" union:"member"`
	Any                any                 `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestSortType
}

func CreateOpenResponsesRequestSortProviderSort(providerSort ProviderSort) OpenResponsesRequestSort {
	typ := OpenResponsesRequestSortTypeProviderSort

	return OpenResponsesRequestSort{
		ProviderSort: &providerSort,
		Type:         typ,
	}
}

func CreateOpenResponsesRequestSortProviderSortConfig(providerSortConfig ProviderSortConfig) OpenResponsesRequestSort {
	typ := OpenResponsesRequestSortTypeProviderSortConfig

	return OpenResponsesRequestSort{
		ProviderSortConfig: &providerSortConfig,
		Type:               typ,
	}
}

func CreateOpenResponsesRequestSortAny(anyT any) OpenResponsesRequestSort {
	typ := OpenResponsesRequestSortTypeAny

	return OpenResponsesRequestSort{
		Any:  anyT,
		Type: typ,
	}
}

func (u *OpenResponsesRequestSort) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerSort ProviderSort = ProviderSort("")
	if err := utils.UnmarshalJSON(data, &providerSort, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestSortTypeProviderSort,
			Value: &providerSort,
		})
	}

	var providerSortConfig ProviderSortConfig = ProviderSortConfig{}
	if err := utils.UnmarshalJSON(data, &providerSortConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestSortTypeProviderSortConfig,
			Value: &providerSortConfig,
		})
	}

	var anyVar any = nil
	if err := utils.UnmarshalJSON(data, &anyVar, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesRequestSortTypeAny,
			Value: anyVar,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestSort", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestSort", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesRequestSortType)
	switch best.Type {
	case OpenResponsesRequestSortTypeProviderSort:
		u.ProviderSort = best.Value.(*ProviderSort)
		return nil
	case OpenResponsesRequestSortTypeProviderSortConfig:
		u.ProviderSortConfig = best.Value.(*ProviderSortConfig)
		return nil
	case OpenResponsesRequestSortTypeAny:
		u.Any = best.Value.(any)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestSort", string(data))
}

func (u OpenResponsesRequestSort) MarshalJSON() ([]byte, error) {
	if u.ProviderSort != nil {
		return utils.MarshalJSON(u.ProviderSort, "", true)
	}

	if u.ProviderSortConfig != nil {
		return utils.MarshalJSON(u.ProviderSortConfig, "", true)
	}

	if u.Any != nil {
		return utils.MarshalJSON(u.Any, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestSort: all fields are null")
}

// OpenResponsesRequestMaxPrice - The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
type OpenResponsesRequestMaxPrice struct {
	// A value in string format that is a large number
	Prompt *string `json:"prompt,omitzero"`
	// A value in string format that is a large number
	Completion *string `json:"completion,omitzero"`
	// A value in string format that is a large number
	Image *string `json:"image,omitzero"`
	// A value in string format that is a large number
	Audio *string `json:"audio,omitzero"`
	// A value in string format that is a large number
	Request *string `json:"request,omitzero"`
}

func (o *OpenResponsesRequestMaxPrice) GetPrompt() *string {
	if o == nil {
		return nil
	}
	return o.Prompt
}

func (o *OpenResponsesRequestMaxPrice) GetCompletion() *string {
	if o == nil {
		return nil
	}
	return o.Completion
}

func (o *OpenResponsesRequestMaxPrice) GetImage() *string {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *OpenResponsesRequestMaxPrice) GetAudio() *string {
	if o == nil {
		return nil
	}
	return o.Audio
}

func (o *OpenResponsesRequestMaxPrice) GetRequest() *string {
	if o == nil {
		return nil
	}
	return o.Request
}

// OpenResponsesRequestProvider - When multiple model providers are available, optionally indicate your routing preference.
type OpenResponsesRequestProvider struct {
	// Whether to allow backup providers to serve requests
	// - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
	// - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
	//
	AllowFallbacks optionalnullable.OptionalNullable[bool] `json:"allow_fallbacks,omitzero"`
	// Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
	RequireParameters optionalnullable.OptionalNullable[bool] `json:"require_parameters,omitzero"`
	// Data collection setting. If no available model provider meets the requirement, your request will return an error.
	// - allow: (default) allow providers which store user data non-transiently and may train on it
	//
	// - deny: use only providers which do not collect user data.
	DataCollection optionalnullable.OptionalNullable[DataCollection] `json:"data_collection,omitzero"`
	// Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
	Zdr optionalnullable.OptionalNullable[bool] `json:"zdr,omitzero"`
	// Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used.
	EnforceDistillableText optionalnullable.OptionalNullable[bool] `json:"enforce_distillable_text,omitzero"`
	// An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
	Order optionalnullable.OptionalNullable[[]OpenResponsesRequestOrder] `json:"order,omitzero"`
	// List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
	Only optionalnullable.OptionalNullable[[]OpenResponsesRequestOnly] `json:"only,omitzero"`
	// List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
	Ignore optionalnullable.OptionalNullable[[]OpenResponsesRequestIgnore] `json:"ignore,omitzero"`
	// A list of quantization levels to filter the provider by.
	Quantizations optionalnullable.OptionalNullable[[]Quantization] `json:"quantizations,omitzero"`
	// The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
	Sort optionalnullable.OptionalNullable[OpenResponsesRequestSort] `json:"sort,omitzero"`
	// The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
	MaxPrice *OpenResponsesRequestMaxPrice `json:"max_price,omitzero"`
	// Preferred minimum throughput (in tokens per second). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints below the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
	PreferredMinThroughput optionalnullable.OptionalNullable[PreferredMinThroughput] `json:"preferred_min_throughput,omitzero"`
	// Preferred maximum latency (in seconds). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints above the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
	PreferredMaxLatency optionalnullable.OptionalNullable[PreferredMaxLatency] `json:"preferred_max_latency,omitzero"`
}

func (o OpenResponsesRequestProvider) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestProvider) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestProvider) GetAllowFallbacks() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.AllowFallbacks
}

func (o *OpenResponsesRequestProvider) GetRequireParameters() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.RequireParameters
}

func (o *OpenResponsesRequestProvider) GetDataCollection() optionalnullable.OptionalNullable[DataCollection] {
	if o == nil {
		return nil
	}
	return o.DataCollection
}

func (o *OpenResponsesRequestProvider) GetZdr() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.Zdr
}

func (o *OpenResponsesRequestProvider) GetEnforceDistillableText() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.EnforceDistillableText
}

func (o *OpenResponsesRequestProvider) GetOrder() optionalnullable.OptionalNullable[[]OpenResponsesRequestOrder] {
	if o == nil {
		return nil
	}
	return o.Order
}

func (o *OpenResponsesRequestProvider) GetOnly() optionalnullable.OptionalNullable[[]OpenResponsesRequestOnly] {
	if o == nil {
		return nil
	}
	return o.Only
}

func (o *OpenResponsesRequestProvider) GetIgnore() optionalnullable.OptionalNullable[[]OpenResponsesRequestIgnore] {
	if o == nil {
		return nil
	}
	return o.Ignore
}

func (o *OpenResponsesRequestProvider) GetQuantizations() optionalnullable.OptionalNullable[[]Quantization] {
	if o == nil {
		return nil
	}
	return o.Quantizations
}

func (o *OpenResponsesRequestProvider) GetSort() optionalnullable.OptionalNullable[OpenResponsesRequestSort] {
	if o == nil {
		return nil
	}
	return o.Sort
}

func (o *OpenResponsesRequestProvider) GetMaxPrice() *OpenResponsesRequestMaxPrice {
	if o == nil {
		return nil
	}
	return o.MaxPrice
}

func (o *OpenResponsesRequestProvider) GetPreferredMinThroughput() optionalnullable.OptionalNullable[PreferredMinThroughput] {
	if o == nil {
		return nil
	}
	return o.PreferredMinThroughput
}

func (o *OpenResponsesRequestProvider) GetPreferredMaxLatency() optionalnullable.OptionalNullable[PreferredMaxLatency] {
	if o == nil {
		return nil
	}
	return o.PreferredMaxLatency
}

type IDResponseHealing string

const (
	IDResponseHealingResponseHealing IDResponseHealing = "response-healing"
)

func (e IDResponseHealing) ToPointer() *IDResponseHealing {
	return &e
}
func (e *IDResponseHealing) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "response-healing":
		*e = IDResponseHealing(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IDResponseHealing: %v", v)
	}
}

type OpenResponsesRequestPluginResponseHealing struct {
	ID IDResponseHealing `json:"id"`
	// Set to false to disable the response-healing plugin for this request. Defaults to true.
	Enabled *bool `json:"enabled,omitzero"`
}

func (o OpenResponsesRequestPluginResponseHealing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestPluginResponseHealing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestPluginResponseHealing) GetID() IDResponseHealing {
	if o == nil {
		return IDResponseHealing("")
	}
	return o.ID
}

func (o *OpenResponsesRequestPluginResponseHealing) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

type IDFileParser string

const (
	IDFileParserFileParser IDFileParser = "file-parser"
)

func (e IDFileParser) ToPointer() *IDFileParser {
	return &e
}
func (e *IDFileParser) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file-parser":
		*e = IDFileParser(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IDFileParser: %v", v)
	}
}

type OpenResponsesRequestPluginFileParser struct {
	ID IDFileParser `json:"id"`
	// Set to false to disable the file-parser plugin for this request. Defaults to true.
	Enabled *bool `json:"enabled,omitzero"`
	// Options for PDF parsing.
	Pdf *PDFParserOptions `json:"pdf,omitzero"`
}

func (o OpenResponsesRequestPluginFileParser) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestPluginFileParser) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestPluginFileParser) GetID() IDFileParser {
	if o == nil {
		return IDFileParser("")
	}
	return o.ID
}

func (o *OpenResponsesRequestPluginFileParser) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *OpenResponsesRequestPluginFileParser) GetPdf() *PDFParserOptions {
	if o == nil {
		return nil
	}
	return o.Pdf
}

type IDWeb string

const (
	IDWebWeb IDWeb = "web"
)

func (e IDWeb) ToPointer() *IDWeb {
	return &e
}
func (e *IDWeb) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "web":
		*e = IDWeb(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IDWeb: %v", v)
	}
}

type OpenResponsesRequestPluginWeb struct {
	ID IDWeb `json:"id"`
	// Set to false to disable the web-search plugin for this request. Defaults to true.
	Enabled      *bool    `json:"enabled,omitzero"`
	MaxResults   *float64 `json:"max_results,omitzero"`
	SearchPrompt *string  `json:"search_prompt,omitzero"`
	// The search engine to use for web search.
	Engine *WebSearchEngine `json:"engine,omitzero"`
}

func (o OpenResponsesRequestPluginWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestPluginWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestPluginWeb) GetID() IDWeb {
	if o == nil {
		return IDWeb("")
	}
	return o.ID
}

func (o *OpenResponsesRequestPluginWeb) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *OpenResponsesRequestPluginWeb) GetMaxResults() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxResults
}

func (o *OpenResponsesRequestPluginWeb) GetSearchPrompt() *string {
	if o == nil {
		return nil
	}
	return o.SearchPrompt
}

func (o *OpenResponsesRequestPluginWeb) GetEngine() *WebSearchEngine {
	if o == nil {
		return nil
	}
	return o.Engine
}

type IDModeration string

const (
	IDModerationModeration IDModeration = "moderation"
)

func (e IDModeration) ToPointer() *IDModeration {
	return &e
}
func (e *IDModeration) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "moderation":
		*e = IDModeration(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IDModeration: %v", v)
	}
}

type OpenResponsesRequestPluginModeration struct {
	ID IDModeration `json:"id"`
}

func (o OpenResponsesRequestPluginModeration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestPluginModeration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestPluginModeration) GetID() IDModeration {
	if o == nil {
		return IDModeration("")
	}
	return o.ID
}

type IDAutoRouter string

const (
	IDAutoRouterAutoRouter IDAutoRouter = "auto-router"
)

func (e IDAutoRouter) ToPointer() *IDAutoRouter {
	return &e
}
func (e *IDAutoRouter) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto-router":
		*e = IDAutoRouter(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IDAutoRouter: %v", v)
	}
}

type OpenResponsesRequestPluginAutoRouter struct {
	ID IDAutoRouter `json:"id"`
	// Set to false to disable the auto-router plugin for this request. Defaults to true.
	Enabled *bool `json:"enabled,omitzero"`
	// List of model patterns to filter which models the auto-router can route between. Supports wildcards (e.g., "anthropic/*" matches all Anthropic models). When not specified, uses the default supported models list.
	AllowedModels []string `json:"allowed_models,omitzero"`
}

func (o OpenResponsesRequestPluginAutoRouter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequestPluginAutoRouter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequestPluginAutoRouter) GetID() IDAutoRouter {
	if o == nil {
		return IDAutoRouter("")
	}
	return o.ID
}

func (o *OpenResponsesRequestPluginAutoRouter) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *OpenResponsesRequestPluginAutoRouter) GetAllowedModels() []string {
	if o == nil {
		return nil
	}
	return o.AllowedModels
}

type OpenResponsesRequestPluginUnionType string

const (
	OpenResponsesRequestPluginUnionTypeAutoRouter      OpenResponsesRequestPluginUnionType = "auto-router"
	OpenResponsesRequestPluginUnionTypeModeration      OpenResponsesRequestPluginUnionType = "moderation"
	OpenResponsesRequestPluginUnionTypeWeb             OpenResponsesRequestPluginUnionType = "web"
	OpenResponsesRequestPluginUnionTypeFileParser      OpenResponsesRequestPluginUnionType = "file-parser"
	OpenResponsesRequestPluginUnionTypeResponseHealing OpenResponsesRequestPluginUnionType = "response-healing"
)

type OpenResponsesRequestPluginUnion struct {
	OpenResponsesRequestPluginAutoRouter      *OpenResponsesRequestPluginAutoRouter      `queryParam:"inline" union:"member"`
	OpenResponsesRequestPluginModeration      *OpenResponsesRequestPluginModeration      `queryParam:"inline" union:"member"`
	OpenResponsesRequestPluginWeb             *OpenResponsesRequestPluginWeb             `queryParam:"inline" union:"member"`
	OpenResponsesRequestPluginFileParser      *OpenResponsesRequestPluginFileParser      `queryParam:"inline" union:"member"`
	OpenResponsesRequestPluginResponseHealing *OpenResponsesRequestPluginResponseHealing `queryParam:"inline" union:"member"`

	Type OpenResponsesRequestPluginUnionType
}

func CreateOpenResponsesRequestPluginUnionAutoRouter(autoRouter OpenResponsesRequestPluginAutoRouter) OpenResponsesRequestPluginUnion {
	typ := OpenResponsesRequestPluginUnionTypeAutoRouter

	typStr := IDAutoRouter(typ)
	autoRouter.ID = typStr

	return OpenResponsesRequestPluginUnion{
		OpenResponsesRequestPluginAutoRouter: &autoRouter,
		Type:                                 typ,
	}
}

func CreateOpenResponsesRequestPluginUnionModeration(moderation OpenResponsesRequestPluginModeration) OpenResponsesRequestPluginUnion {
	typ := OpenResponsesRequestPluginUnionTypeModeration

	typStr := IDModeration(typ)
	moderation.ID = typStr

	return OpenResponsesRequestPluginUnion{
		OpenResponsesRequestPluginModeration: &moderation,
		Type:                                 typ,
	}
}

func CreateOpenResponsesRequestPluginUnionWeb(web OpenResponsesRequestPluginWeb) OpenResponsesRequestPluginUnion {
	typ := OpenResponsesRequestPluginUnionTypeWeb

	typStr := IDWeb(typ)
	web.ID = typStr

	return OpenResponsesRequestPluginUnion{
		OpenResponsesRequestPluginWeb: &web,
		Type:                          typ,
	}
}

func CreateOpenResponsesRequestPluginUnionFileParser(fileParser OpenResponsesRequestPluginFileParser) OpenResponsesRequestPluginUnion {
	typ := OpenResponsesRequestPluginUnionTypeFileParser

	typStr := IDFileParser(typ)
	fileParser.ID = typStr

	return OpenResponsesRequestPluginUnion{
		OpenResponsesRequestPluginFileParser: &fileParser,
		Type:                                 typ,
	}
}

func CreateOpenResponsesRequestPluginUnionResponseHealing(responseHealing OpenResponsesRequestPluginResponseHealing) OpenResponsesRequestPluginUnion {
	typ := OpenResponsesRequestPluginUnionTypeResponseHealing

	typStr := IDResponseHealing(typ)
	responseHealing.ID = typStr

	return OpenResponsesRequestPluginUnion{
		OpenResponsesRequestPluginResponseHealing: &responseHealing,
		Type: typ,
	}
}

func (u *OpenResponsesRequestPluginUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		ID string `json:"id"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.ID {
	case "auto-router":
		openResponsesRequestPluginAutoRouter := new(OpenResponsesRequestPluginAutoRouter)
		if err := utils.UnmarshalJSON(data, &openResponsesRequestPluginAutoRouter, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == auto-router) type OpenResponsesRequestPluginAutoRouter within OpenResponsesRequestPluginUnion: %w", string(data), err)
		}

		u.OpenResponsesRequestPluginAutoRouter = openResponsesRequestPluginAutoRouter
		u.Type = OpenResponsesRequestPluginUnionTypeAutoRouter
		return nil
	case "moderation":
		openResponsesRequestPluginModeration := new(OpenResponsesRequestPluginModeration)
		if err := utils.UnmarshalJSON(data, &openResponsesRequestPluginModeration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == moderation) type OpenResponsesRequestPluginModeration within OpenResponsesRequestPluginUnion: %w", string(data), err)
		}

		u.OpenResponsesRequestPluginModeration = openResponsesRequestPluginModeration
		u.Type = OpenResponsesRequestPluginUnionTypeModeration
		return nil
	case "web":
		openResponsesRequestPluginWeb := new(OpenResponsesRequestPluginWeb)
		if err := utils.UnmarshalJSON(data, &openResponsesRequestPluginWeb, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == web) type OpenResponsesRequestPluginWeb within OpenResponsesRequestPluginUnion: %w", string(data), err)
		}

		u.OpenResponsesRequestPluginWeb = openResponsesRequestPluginWeb
		u.Type = OpenResponsesRequestPluginUnionTypeWeb
		return nil
	case "file-parser":
		openResponsesRequestPluginFileParser := new(OpenResponsesRequestPluginFileParser)
		if err := utils.UnmarshalJSON(data, &openResponsesRequestPluginFileParser, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == file-parser) type OpenResponsesRequestPluginFileParser within OpenResponsesRequestPluginUnion: %w", string(data), err)
		}

		u.OpenResponsesRequestPluginFileParser = openResponsesRequestPluginFileParser
		u.Type = OpenResponsesRequestPluginUnionTypeFileParser
		return nil
	case "response-healing":
		openResponsesRequestPluginResponseHealing := new(OpenResponsesRequestPluginResponseHealing)
		if err := utils.UnmarshalJSON(data, &openResponsesRequestPluginResponseHealing, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == response-healing) type OpenResponsesRequestPluginResponseHealing within OpenResponsesRequestPluginUnion: %w", string(data), err)
		}

		u.OpenResponsesRequestPluginResponseHealing = openResponsesRequestPluginResponseHealing
		u.Type = OpenResponsesRequestPluginUnionTypeResponseHealing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesRequestPluginUnion", string(data))
}

func (u OpenResponsesRequestPluginUnion) MarshalJSON() ([]byte, error) {
	if u.OpenResponsesRequestPluginAutoRouter != nil {
		return utils.MarshalJSON(u.OpenResponsesRequestPluginAutoRouter, "", true)
	}

	if u.OpenResponsesRequestPluginModeration != nil {
		return utils.MarshalJSON(u.OpenResponsesRequestPluginModeration, "", true)
	}

	if u.OpenResponsesRequestPluginWeb != nil {
		return utils.MarshalJSON(u.OpenResponsesRequestPluginWeb, "", true)
	}

	if u.OpenResponsesRequestPluginFileParser != nil {
		return utils.MarshalJSON(u.OpenResponsesRequestPluginFileParser, "", true)
	}

	if u.OpenResponsesRequestPluginResponseHealing != nil {
		return utils.MarshalJSON(u.OpenResponsesRequestPluginResponseHealing, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesRequestPluginUnion: all fields are null")
}

// OpenResponsesRequest - Request schema for Responses endpoint
type OpenResponsesRequest struct {
	// Input for a response request - can be a string or array of items
	Input        *OpenResponsesInput                       `json:"input,omitzero"`
	Instructions optionalnullable.OptionalNullable[string] `json:"instructions,omitzero"`
	// Metadata key-value pairs for the request. Keys must be ≤64 characters and cannot contain brackets. Values must be ≤512 characters. Maximum 16 pairs allowed.
	Metadata          optionalnullable.OptionalNullable[map[string]string] `json:"metadata,omitzero"`
	Tools             []OpenResponsesRequestToolUnion                      `json:"tools,omitzero"`
	ToolChoice        *OpenAIResponsesToolChoiceUnion                      `json:"tool_choice,omitzero"`
	ParallelToolCalls optionalnullable.OptionalNullable[bool]              `json:"parallel_tool_calls,omitzero"`
	Model             *string                                              `json:"model,omitzero"`
	Models            []string                                             `json:"models,omitzero"`
	// Text output configuration including format and verbosity
	Text *OpenResponsesResponseText `json:"text,omitzero"`
	// Configuration for reasoning mode in the response
	Reasoning        optionalnullable.OptionalNullable[OpenResponsesReasoningConfig] `json:"reasoning,omitzero"`
	MaxOutputTokens  optionalnullable.OptionalNullable[float64]                      `json:"max_output_tokens,omitzero"`
	Temperature      optionalnullable.OptionalNullable[float64]                      `json:"temperature,omitzero"`
	TopP             optionalnullable.OptionalNullable[float64]                      `json:"top_p,omitzero"`
	TopLogprobs      optionalnullable.OptionalNullable[int64]                        `json:"top_logprobs,omitzero"`
	MaxToolCalls     optionalnullable.OptionalNullable[int64]                        `json:"max_tool_calls,omitzero"`
	PresencePenalty  optionalnullable.OptionalNullable[float64]                      `json:"presence_penalty,omitzero"`
	FrequencyPenalty optionalnullable.OptionalNullable[float64]                      `json:"frequency_penalty,omitzero"`
	TopK             *float64                                                        `json:"top_k,omitzero"`
	// Provider-specific image configuration options. Keys and values vary by model/provider. See https://openrouter.ai/docs/features/multimodal/image-generation for more details.
	ImageConfig map[string]OpenResponsesRequestImageConfig `json:"image_config,omitzero"`
	// Output modalities for the response. Supported values are "text" and "image".
	Modalities         []ResponsesOutputModality                                      `json:"modalities,omitzero"`
	PromptCacheKey     optionalnullable.OptionalNullable[string]                      `json:"prompt_cache_key,omitzero"`
	PreviousResponseID optionalnullable.OptionalNullable[string]                      `json:"previous_response_id,omitzero"`
	Prompt             optionalnullable.OptionalNullable[OpenAIResponsesPrompt]       `json:"prompt,omitzero"`
	Include            optionalnullable.OptionalNullable[[]OpenAIResponsesIncludable] `json:"include,omitzero"`
	Background         optionalnullable.OptionalNullable[bool]                        `json:"background,omitzero"`
	SafetyIdentifier   optionalnullable.OptionalNullable[string]                      `json:"safety_identifier,omitzero"`
	store              *bool                                                          `const:"false" json:"store"`
	ServiceTier        *ServiceTier                                                   `default:"auto" json:"service_tier"`
	Truncation         optionalnullable.OptionalNullable[Truncation]                  `json:"truncation,omitzero"`
	Stream             *bool                                                          `default:"false" json:"stream"`
	// When multiple model providers are available, optionally indicate your routing preference.
	Provider optionalnullable.OptionalNullable[OpenResponsesRequestProvider] `json:"provider,omitzero"`
	// Plugins you want to enable for this request, including their settings.
	Plugins []OpenResponsesRequestPluginUnion `json:"plugins,omitzero"`
	// A unique identifier representing your end-user, which helps distinguish between different users of your app. This allows your app to identify specific users in case of abuse reports, preventing your entire app from being affected by the actions of individual users. Maximum of 128 characters.
	User *string `json:"user,omitzero"`
	// A unique identifier for grouping related requests (e.g., a conversation or agent workflow) for observability. If provided in both the request body and the x-session-id header, the body value takes precedence. Maximum of 128 characters.
	SessionID *string `json:"session_id,omitzero"`
}

func (o OpenResponsesRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesRequest) GetInput() *OpenResponsesInput {
	if o == nil {
		return nil
	}
	return o.Input
}

func (o *OpenResponsesRequest) GetInstructions() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.Instructions
}

func (o *OpenResponsesRequest) GetMetadata() optionalnullable.OptionalNullable[map[string]string] {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OpenResponsesRequest) GetTools() []OpenResponsesRequestToolUnion {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *OpenResponsesRequest) GetToolChoice() *OpenAIResponsesToolChoiceUnion {
	if o == nil {
		return nil
	}
	return o.ToolChoice
}

func (o *OpenResponsesRequest) GetParallelToolCalls() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.ParallelToolCalls
}

func (o *OpenResponsesRequest) GetModel() *string {
	if o == nil {
		return nil
	}
	return o.Model
}

func (o *OpenResponsesRequest) GetModels() []string {
	if o == nil {
		return nil
	}
	return o.Models
}

func (o *OpenResponsesRequest) GetText() *OpenResponsesResponseText {
	if o == nil {
		return nil
	}
	return o.Text
}

func (o *OpenResponsesRequest) GetReasoning() optionalnullable.OptionalNullable[OpenResponsesReasoningConfig] {
	if o == nil {
		return nil
	}
	return o.Reasoning
}

func (o *OpenResponsesRequest) GetMaxOutputTokens() optionalnullable.OptionalNullable[float64] {
	if o == nil {
		return nil
	}
	return o.MaxOutputTokens
}

func (o *OpenResponsesRequest) GetTemperature() optionalnullable.OptionalNullable[float64] {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *OpenResponsesRequest) GetTopP() optionalnullable.OptionalNullable[float64] {
	if o == nil {
		return nil
	}
	return o.TopP
}

func (o *OpenResponsesRequest) GetTopLogprobs() optionalnullable.OptionalNullable[int64] {
	if o == nil {
		return nil
	}
	return o.TopLogprobs
}

func (o *OpenResponsesRequest) GetMaxToolCalls() optionalnullable.OptionalNullable[int64] {
	if o == nil {
		return nil
	}
	return o.MaxToolCalls
}

func (o *OpenResponsesRequest) GetPresencePenalty() optionalnullable.OptionalNullable[float64] {
	if o == nil {
		return nil
	}
	return o.PresencePenalty
}

func (o *OpenResponsesRequest) GetFrequencyPenalty() optionalnullable.OptionalNullable[float64] {
	if o == nil {
		return nil
	}
	return o.FrequencyPenalty
}

func (o *OpenResponsesRequest) GetTopK() *float64 {
	if o == nil {
		return nil
	}
	return o.TopK
}

func (o *OpenResponsesRequest) GetImageConfig() map[string]OpenResponsesRequestImageConfig {
	if o == nil {
		return nil
	}
	return o.ImageConfig
}

func (o *OpenResponsesRequest) GetModalities() []ResponsesOutputModality {
	if o == nil {
		return nil
	}
	return o.Modalities
}

func (o *OpenResponsesRequest) GetPromptCacheKey() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.PromptCacheKey
}

func (o *OpenResponsesRequest) GetPreviousResponseID() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.PreviousResponseID
}

func (o *OpenResponsesRequest) GetPrompt() optionalnullable.OptionalNullable[OpenAIResponsesPrompt] {
	if o == nil {
		return nil
	}
	return o.Prompt
}

func (o *OpenResponsesRequest) GetInclude() optionalnullable.OptionalNullable[[]OpenAIResponsesIncludable] {
	if o == nil {
		return nil
	}
	return o.Include
}

func (o *OpenResponsesRequest) GetBackground() optionalnullable.OptionalNullable[bool] {
	if o == nil {
		return nil
	}
	return o.Background
}

func (o *OpenResponsesRequest) GetSafetyIdentifier() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.SafetyIdentifier
}

func (o *OpenResponsesRequest) GetStore() *bool {
	return types.Pointer(false)
}

func (o *OpenResponsesRequest) GetServiceTier() *ServiceTier {
	if o == nil {
		return nil
	}
	return o.ServiceTier
}

func (o *OpenResponsesRequest) GetTruncation() optionalnullable.OptionalNullable[Truncation] {
	if o == nil {
		return nil
	}
	return o.Truncation
}

func (o *OpenResponsesRequest) GetStream() *bool {
	if o == nil {
		return nil
	}
	return o.Stream
}

func (o *OpenResponsesRequest) GetProvider() optionalnullable.OptionalNullable[OpenResponsesRequestProvider] {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *OpenResponsesRequest) GetPlugins() []OpenResponsesRequestPluginUnion {
	if o == nil {
		return nil
	}
	return o.Plugins
}

func (o *OpenResponsesRequest) GetUser() *string {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *OpenResponsesRequest) GetSessionID() *string {
	if o == nil {
		return nil
	}
	return o.SessionID
}
