// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type Schema2ReasoningText struct {
	type_     string                                     `const:"reasoning.text" json:"type"`
	Text      optionalnullable.OptionalNullable[string]  `json:"text,omitzero"`
	Signature optionalnullable.OptionalNullable[string]  `json:"signature,omitzero"`
	ID        optionalnullable.OptionalNullable[string]  `json:"id,omitzero"`
	Format    optionalnullable.OptionalNullable[Schema4] `json:"format,omitzero"`
	Index     *float64                                   `json:"index,omitzero"`
}

func (s Schema2ReasoningText) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Schema2ReasoningText) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *Schema2ReasoningText) GetType() string {
	return "reasoning.text"
}

func (s *Schema2ReasoningText) GetText() optionalnullable.OptionalNullable[string] {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *Schema2ReasoningText) GetSignature() optionalnullable.OptionalNullable[string] {
	if s == nil {
		return nil
	}
	return s.Signature
}

func (s *Schema2ReasoningText) GetID() optionalnullable.OptionalNullable[string] {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Schema2ReasoningText) GetFormat() optionalnullable.OptionalNullable[Schema4] {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *Schema2ReasoningText) GetIndex() *float64 {
	if s == nil {
		return nil
	}
	return s.Index
}

type Schema2ReasoningEncrypted struct {
	type_  string                                     `const:"reasoning.encrypted" json:"type"`
	Data   string                                     `json:"data"`
	ID     optionalnullable.OptionalNullable[string]  `json:"id,omitzero"`
	Format optionalnullable.OptionalNullable[Schema4] `json:"format,omitzero"`
	Index  *float64                                   `json:"index,omitzero"`
}

func (s Schema2ReasoningEncrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Schema2ReasoningEncrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *Schema2ReasoningEncrypted) GetType() string {
	return "reasoning.encrypted"
}

func (s *Schema2ReasoningEncrypted) GetData() string {
	if s == nil {
		return ""
	}
	return s.Data
}

func (s *Schema2ReasoningEncrypted) GetID() optionalnullable.OptionalNullable[string] {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Schema2ReasoningEncrypted) GetFormat() optionalnullable.OptionalNullable[Schema4] {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *Schema2ReasoningEncrypted) GetIndex() *float64 {
	if s == nil {
		return nil
	}
	return s.Index
}

type Schema4 string

const (
	Schema4Unknown                Schema4 = "unknown"
	Schema4OpenaiResponsesV1      Schema4 = "openai-responses-v1"
	Schema4AzureOpenaiResponsesV1 Schema4 = "azure-openai-responses-v1"
	Schema4XaiResponsesV1         Schema4 = "xai-responses-v1"
	Schema4AnthropicClaudeV1      Schema4 = "anthropic-claude-v1"
	Schema4GoogleGeminiV1         Schema4 = "google-gemini-v1"
)

func (e Schema4) ToPointer() *Schema4 {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Schema4) IsExact() bool {
	if e != nil {
		switch *e {
		case "unknown", "openai-responses-v1", "azure-openai-responses-v1", "xai-responses-v1", "anthropic-claude-v1", "google-gemini-v1":
			return true
		}
	}
	return false
}

type Schema2ReasoningSummary struct {
	type_   string                                     `const:"reasoning.summary" json:"type"`
	Summary string                                     `json:"summary"`
	ID      optionalnullable.OptionalNullable[string]  `json:"id,omitzero"`
	Format  optionalnullable.OptionalNullable[Schema4] `json:"format,omitzero"`
	Index   *float64                                   `json:"index,omitzero"`
}

func (s Schema2ReasoningSummary) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Schema2ReasoningSummary) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *Schema2ReasoningSummary) GetType() string {
	return "reasoning.summary"
}

func (s *Schema2ReasoningSummary) GetSummary() string {
	if s == nil {
		return ""
	}
	return s.Summary
}

func (s *Schema2ReasoningSummary) GetID() optionalnullable.OptionalNullable[string] {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Schema2ReasoningSummary) GetFormat() optionalnullable.OptionalNullable[Schema4] {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *Schema2ReasoningSummary) GetIndex() *float64 {
	if s == nil {
		return nil
	}
	return s.Index
}

type Schema2Type string

const (
	Schema2TypeReasoningSummary   Schema2Type = "reasoning.summary"
	Schema2TypeReasoningEncrypted Schema2Type = "reasoning.encrypted"
	Schema2TypeReasoningText      Schema2Type = "reasoning.text"
)

type Schema2 struct {
	Schema2ReasoningSummary   *Schema2ReasoningSummary   `queryParam:"inline" union:"member"`
	Schema2ReasoningEncrypted *Schema2ReasoningEncrypted `queryParam:"inline" union:"member"`
	Schema2ReasoningText      *Schema2ReasoningText      `queryParam:"inline" union:"member"`

	Type Schema2Type
}

func CreateSchema2ReasoningSummary(reasoningSummary Schema2ReasoningSummary) Schema2 {
	typ := Schema2TypeReasoningSummary

	return Schema2{
		Schema2ReasoningSummary: &reasoningSummary,
		Type:                    typ,
	}
}

func CreateSchema2ReasoningEncrypted(reasoningEncrypted Schema2ReasoningEncrypted) Schema2 {
	typ := Schema2TypeReasoningEncrypted

	return Schema2{
		Schema2ReasoningEncrypted: &reasoningEncrypted,
		Type:                      typ,
	}
}

func CreateSchema2ReasoningText(reasoningText Schema2ReasoningText) Schema2 {
	typ := Schema2TypeReasoningText

	return Schema2{
		Schema2ReasoningText: &reasoningText,
		Type:                 typ,
	}
}

func (u *Schema2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "reasoning.summary":
		schema2ReasoningSummary := new(Schema2ReasoningSummary)
		if err := utils.UnmarshalJSON(data, &schema2ReasoningSummary, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == reasoning.summary) type Schema2ReasoningSummary within Schema2: %w", string(data), err)
		}

		u.Schema2ReasoningSummary = schema2ReasoningSummary
		u.Type = Schema2TypeReasoningSummary
		return nil
	case "reasoning.encrypted":
		schema2ReasoningEncrypted := new(Schema2ReasoningEncrypted)
		if err := utils.UnmarshalJSON(data, &schema2ReasoningEncrypted, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == reasoning.encrypted) type Schema2ReasoningEncrypted within Schema2: %w", string(data), err)
		}

		u.Schema2ReasoningEncrypted = schema2ReasoningEncrypted
		u.Type = Schema2TypeReasoningEncrypted
		return nil
	case "reasoning.text":
		schema2ReasoningText := new(Schema2ReasoningText)
		if err := utils.UnmarshalJSON(data, &schema2ReasoningText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == reasoning.text) type Schema2ReasoningText within Schema2: %w", string(data), err)
		}

		u.Schema2ReasoningText = schema2ReasoningText
		u.Type = Schema2TypeReasoningText
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schema2", string(data))
}

func (u Schema2) MarshalJSON() ([]byte, error) {
	if u.Schema2ReasoningSummary != nil {
		return utils.MarshalJSON(u.Schema2ReasoningSummary, "", true)
	}

	if u.Schema2ReasoningEncrypted != nil {
		return utils.MarshalJSON(u.Schema2ReasoningEncrypted, "", true)
	}

	if u.Schema2ReasoningText != nil {
		return utils.MarshalJSON(u.Schema2ReasoningText, "", true)
	}

	return nil, errors.New("could not marshal union type Schema2: all fields are null")
}
