// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type ProviderPreferencesOrderType string

const (
	ProviderPreferencesOrderTypeProviderName ProviderPreferencesOrderType = "ProviderName"
	ProviderPreferencesOrderTypeStr          ProviderPreferencesOrderType = "str"
)

type ProviderPreferencesOrder struct {
	ProviderName *ProviderName `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`

	Type ProviderPreferencesOrderType
}

func CreateProviderPreferencesOrderProviderName(providerName ProviderName) ProviderPreferencesOrder {
	typ := ProviderPreferencesOrderTypeProviderName

	return ProviderPreferencesOrder{
		ProviderName: &providerName,
		Type:         typ,
	}
}

func CreateProviderPreferencesOrderStr(str string) ProviderPreferencesOrder {
	typ := ProviderPreferencesOrderTypeStr

	return ProviderPreferencesOrder{
		Str:  &str,
		Type: typ,
	}
}

func (u *ProviderPreferencesOrder) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerName ProviderName = ProviderName("")
	if err := utils.UnmarshalJSON(data, &providerName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesOrderTypeProviderName,
			Value: &providerName,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesOrderTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesOrder", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesOrder", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProviderPreferencesOrderType)
	switch best.Type {
	case ProviderPreferencesOrderTypeProviderName:
		u.ProviderName = best.Value.(*ProviderName)
		return nil
	case ProviderPreferencesOrderTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesOrder", string(data))
}

func (u ProviderPreferencesOrder) MarshalJSON() ([]byte, error) {
	if u.ProviderName != nil {
		return utils.MarshalJSON(u.ProviderName, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ProviderPreferencesOrder: all fields are null")
}

type ProviderPreferencesOnlyType string

const (
	ProviderPreferencesOnlyTypeProviderName ProviderPreferencesOnlyType = "ProviderName"
	ProviderPreferencesOnlyTypeStr          ProviderPreferencesOnlyType = "str"
)

type ProviderPreferencesOnly struct {
	ProviderName *ProviderName `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`

	Type ProviderPreferencesOnlyType
}

func CreateProviderPreferencesOnlyProviderName(providerName ProviderName) ProviderPreferencesOnly {
	typ := ProviderPreferencesOnlyTypeProviderName

	return ProviderPreferencesOnly{
		ProviderName: &providerName,
		Type:         typ,
	}
}

func CreateProviderPreferencesOnlyStr(str string) ProviderPreferencesOnly {
	typ := ProviderPreferencesOnlyTypeStr

	return ProviderPreferencesOnly{
		Str:  &str,
		Type: typ,
	}
}

func (u *ProviderPreferencesOnly) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerName ProviderName = ProviderName("")
	if err := utils.UnmarshalJSON(data, &providerName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesOnlyTypeProviderName,
			Value: &providerName,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesOnlyTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesOnly", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesOnly", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProviderPreferencesOnlyType)
	switch best.Type {
	case ProviderPreferencesOnlyTypeProviderName:
		u.ProviderName = best.Value.(*ProviderName)
		return nil
	case ProviderPreferencesOnlyTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesOnly", string(data))
}

func (u ProviderPreferencesOnly) MarshalJSON() ([]byte, error) {
	if u.ProviderName != nil {
		return utils.MarshalJSON(u.ProviderName, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ProviderPreferencesOnly: all fields are null")
}

type ProviderPreferencesIgnoreType string

const (
	ProviderPreferencesIgnoreTypeProviderName ProviderPreferencesIgnoreType = "ProviderName"
	ProviderPreferencesIgnoreTypeStr          ProviderPreferencesIgnoreType = "str"
)

type ProviderPreferencesIgnore struct {
	ProviderName *ProviderName `queryParam:"inline" union:"member"`
	Str          *string       `queryParam:"inline" union:"member"`

	Type ProviderPreferencesIgnoreType
}

func CreateProviderPreferencesIgnoreProviderName(providerName ProviderName) ProviderPreferencesIgnore {
	typ := ProviderPreferencesIgnoreTypeProviderName

	return ProviderPreferencesIgnore{
		ProviderName: &providerName,
		Type:         typ,
	}
}

func CreateProviderPreferencesIgnoreStr(str string) ProviderPreferencesIgnore {
	typ := ProviderPreferencesIgnoreTypeStr

	return ProviderPreferencesIgnore{
		Str:  &str,
		Type: typ,
	}
}

func (u *ProviderPreferencesIgnore) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerName ProviderName = ProviderName("")
	if err := utils.UnmarshalJSON(data, &providerName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesIgnoreTypeProviderName,
			Value: &providerName,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesIgnoreTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesIgnore", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesIgnore", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProviderPreferencesIgnoreType)
	switch best.Type {
	case ProviderPreferencesIgnoreTypeProviderName:
		u.ProviderName = best.Value.(*ProviderName)
		return nil
	case ProviderPreferencesIgnoreTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesIgnore", string(data))
}

func (u ProviderPreferencesIgnore) MarshalJSON() ([]byte, error) {
	if u.ProviderName != nil {
		return utils.MarshalJSON(u.ProviderName, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ProviderPreferencesIgnore: all fields are null")
}

type SortEnum string

const (
	SortEnumPrice      SortEnum = "price"
	SortEnumThroughput SortEnum = "throughput"
	SortEnumLatency    SortEnum = "latency"
)

func (e SortEnum) ToPointer() *SortEnum {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *SortEnum) IsExact() bool {
	if e != nil {
		switch *e {
		case "price", "throughput", "latency":
			return true
		}
	}
	return false
}

type ProviderSortConfigEnum string

const (
	ProviderSortConfigEnumPrice      ProviderSortConfigEnum = "price"
	ProviderSortConfigEnumThroughput ProviderSortConfigEnum = "throughput"
	ProviderSortConfigEnumLatency    ProviderSortConfigEnum = "latency"
)

func (e ProviderSortConfigEnum) ToPointer() *ProviderSortConfigEnum {
	return &e
}
func (e *ProviderSortConfigEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "price":
		fallthrough
	case "throughput":
		fallthrough
	case "latency":
		*e = ProviderSortConfigEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProviderSortConfigEnum: %v", v)
	}
}

type ProviderPreferencesPartition string

const (
	ProviderPreferencesPartitionModel ProviderPreferencesPartition = "model"
	ProviderPreferencesPartitionNone  ProviderPreferencesPartition = "none"
)

func (e ProviderPreferencesPartition) ToPointer() *ProviderPreferencesPartition {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ProviderPreferencesPartition) IsExact() bool {
	if e != nil {
		switch *e {
		case "model", "none":
			return true
		}
	}
	return false
}

type ProviderPreferencesProviderSortConfig struct {
	By        optionalnullable.OptionalNullable[ProviderSort]                 `json:"by,omitzero"`
	Partition optionalnullable.OptionalNullable[ProviderPreferencesPartition] `json:"partition,omitzero"`
}

func (p ProviderPreferencesProviderSortConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProviderPreferencesProviderSortConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *ProviderPreferencesProviderSortConfig) GetBy() optionalnullable.OptionalNullable[ProviderSort] {
	if p == nil {
		return nil
	}
	return p.By
}

func (p *ProviderPreferencesProviderSortConfig) GetPartition() optionalnullable.OptionalNullable[ProviderPreferencesPartition] {
	if p == nil {
		return nil
	}
	return p.Partition
}

type ProviderSortConfigUnionType string

const (
	ProviderSortConfigUnionTypeProviderPreferencesProviderSortConfig ProviderSortConfigUnionType = "ProviderPreferences_ProviderSortConfig"
	ProviderSortConfigUnionTypeProviderSortConfigEnum                ProviderSortConfigUnionType = "ProviderSortConfig_enum"
)

type ProviderSortConfigUnion struct {
	ProviderPreferencesProviderSortConfig *ProviderPreferencesProviderSortConfig `queryParam:"inline" union:"member"`
	ProviderSortConfigEnum                *ProviderSortConfigEnum                `queryParam:"inline" union:"member"`

	Type ProviderSortConfigUnionType
}

func CreateProviderSortConfigUnionProviderPreferencesProviderSortConfig(providerPreferencesProviderSortConfig ProviderPreferencesProviderSortConfig) ProviderSortConfigUnion {
	typ := ProviderSortConfigUnionTypeProviderPreferencesProviderSortConfig

	return ProviderSortConfigUnion{
		ProviderPreferencesProviderSortConfig: &providerPreferencesProviderSortConfig,
		Type:                                  typ,
	}
}

func CreateProviderSortConfigUnionProviderSortConfigEnum(providerSortConfigEnum ProviderSortConfigEnum) ProviderSortConfigUnion {
	typ := ProviderSortConfigUnionTypeProviderSortConfigEnum

	return ProviderSortConfigUnion{
		ProviderSortConfigEnum: &providerSortConfigEnum,
		Type:                   typ,
	}
}

func (u *ProviderSortConfigUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerPreferencesProviderSortConfig ProviderPreferencesProviderSortConfig = ProviderPreferencesProviderSortConfig{}
	if err := utils.UnmarshalJSON(data, &providerPreferencesProviderSortConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderSortConfigUnionTypeProviderPreferencesProviderSortConfig,
			Value: &providerPreferencesProviderSortConfig,
		})
	}

	var providerSortConfigEnum ProviderSortConfigEnum = ProviderSortConfigEnum("")
	if err := utils.UnmarshalJSON(data, &providerSortConfigEnum, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderSortConfigUnionTypeProviderSortConfigEnum,
			Value: &providerSortConfigEnum,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderSortConfigUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderSortConfigUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProviderSortConfigUnionType)
	switch best.Type {
	case ProviderSortConfigUnionTypeProviderPreferencesProviderSortConfig:
		u.ProviderPreferencesProviderSortConfig = best.Value.(*ProviderPreferencesProviderSortConfig)
		return nil
	case ProviderSortConfigUnionTypeProviderSortConfigEnum:
		u.ProviderSortConfigEnum = best.Value.(*ProviderSortConfigEnum)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderSortConfigUnion", string(data))
}

func (u ProviderSortConfigUnion) MarshalJSON() ([]byte, error) {
	if u.ProviderPreferencesProviderSortConfig != nil {
		return utils.MarshalJSON(u.ProviderPreferencesProviderSortConfig, "", true)
	}

	if u.ProviderSortConfigEnum != nil {
		return utils.MarshalJSON(u.ProviderSortConfigEnum, "", true)
	}

	return nil, errors.New("could not marshal union type ProviderSortConfigUnion: all fields are null")
}

type ProviderPreferencesProviderSort string

const (
	ProviderPreferencesProviderSortPrice      ProviderPreferencesProviderSort = "price"
	ProviderPreferencesProviderSortThroughput ProviderPreferencesProviderSort = "throughput"
	ProviderPreferencesProviderSortLatency    ProviderPreferencesProviderSort = "latency"
)

func (e ProviderPreferencesProviderSort) ToPointer() *ProviderPreferencesProviderSort {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ProviderPreferencesProviderSort) IsExact() bool {
	if e != nil {
		switch *e {
		case "price", "throughput", "latency":
			return true
		}
	}
	return false
}

type ProviderPreferencesSortUnionType string

const (
	ProviderPreferencesSortUnionTypeProviderPreferencesProviderSort ProviderPreferencesSortUnionType = "ProviderPreferences_ProviderSort"
	ProviderPreferencesSortUnionTypeProviderSortConfigUnion         ProviderPreferencesSortUnionType = "ProviderSortConfig_union"
	ProviderPreferencesSortUnionTypeSortEnum                        ProviderPreferencesSortUnionType = "sort_enum"
)

// ProviderPreferencesSortUnion - The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
type ProviderPreferencesSortUnion struct {
	ProviderPreferencesProviderSort *ProviderPreferencesProviderSort `queryParam:"inline" union:"member"`
	ProviderSortConfigUnion         *ProviderSortConfigUnion         `queryParam:"inline" union:"member"`
	SortEnum                        *SortEnum                        `queryParam:"inline" union:"member"`

	Type ProviderPreferencesSortUnionType
}

func CreateProviderPreferencesSortUnionProviderPreferencesProviderSort(providerPreferencesProviderSort ProviderPreferencesProviderSort) ProviderPreferencesSortUnion {
	typ := ProviderPreferencesSortUnionTypeProviderPreferencesProviderSort

	return ProviderPreferencesSortUnion{
		ProviderPreferencesProviderSort: &providerPreferencesProviderSort,
		Type:                            typ,
	}
}

func CreateProviderPreferencesSortUnionProviderSortConfigUnion(providerSortConfigUnion ProviderSortConfigUnion) ProviderPreferencesSortUnion {
	typ := ProviderPreferencesSortUnionTypeProviderSortConfigUnion

	return ProviderPreferencesSortUnion{
		ProviderSortConfigUnion: &providerSortConfigUnion,
		Type:                    typ,
	}
}

func CreateProviderPreferencesSortUnionSortEnum(sortEnum SortEnum) ProviderPreferencesSortUnion {
	typ := ProviderPreferencesSortUnionTypeSortEnum

	return ProviderPreferencesSortUnion{
		SortEnum: &sortEnum,
		Type:     typ,
	}
}

func (u *ProviderPreferencesSortUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providerPreferencesProviderSort ProviderPreferencesProviderSort = ProviderPreferencesProviderSort("")
	if err := utils.UnmarshalJSON(data, &providerPreferencesProviderSort, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesSortUnionTypeProviderPreferencesProviderSort,
			Value: &providerPreferencesProviderSort,
		})
	}

	var providerSortConfigUnion ProviderSortConfigUnion = ProviderSortConfigUnion{}
	if err := utils.UnmarshalJSON(data, &providerSortConfigUnion, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesSortUnionTypeProviderSortConfigUnion,
			Value: &providerSortConfigUnion,
		})
	}

	var sortEnum SortEnum = SortEnum("")
	if err := utils.UnmarshalJSON(data, &sortEnum, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProviderPreferencesSortUnionTypeSortEnum,
			Value: &sortEnum,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesSortUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesSortUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProviderPreferencesSortUnionType)
	switch best.Type {
	case ProviderPreferencesSortUnionTypeProviderPreferencesProviderSort:
		u.ProviderPreferencesProviderSort = best.Value.(*ProviderPreferencesProviderSort)
		return nil
	case ProviderPreferencesSortUnionTypeProviderSortConfigUnion:
		u.ProviderSortConfigUnion = best.Value.(*ProviderSortConfigUnion)
		return nil
	case ProviderPreferencesSortUnionTypeSortEnum:
		u.SortEnum = best.Value.(*SortEnum)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProviderPreferencesSortUnion", string(data))
}

func (u ProviderPreferencesSortUnion) MarshalJSON() ([]byte, error) {
	if u.ProviderPreferencesProviderSort != nil {
		return utils.MarshalJSON(u.ProviderPreferencesProviderSort, "", true)
	}

	if u.ProviderSortConfigUnion != nil {
		return utils.MarshalJSON(u.ProviderSortConfigUnion, "", true)
	}

	if u.SortEnum != nil {
		return utils.MarshalJSON(u.SortEnum, "", true)
	}

	return nil, errors.New("could not marshal union type ProviderPreferencesSortUnion: all fields are null")
}

// ProviderPreferencesMaxPrice - The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
type ProviderPreferencesMaxPrice struct {
	// A value in string format that is a large number
	Prompt *string `json:"prompt,omitzero"`
	// A value in string format that is a large number
	Completion *string `json:"completion,omitzero"`
	// A value in string format that is a large number
	Image *string `json:"image,omitzero"`
	// A value in string format that is a large number
	Audio *string `json:"audio,omitzero"`
	// A value in string format that is a large number
	Request *string `json:"request,omitzero"`
}

func (p *ProviderPreferencesMaxPrice) GetPrompt() *string {
	if p == nil {
		return nil
	}
	return p.Prompt
}

func (p *ProviderPreferencesMaxPrice) GetCompletion() *string {
	if p == nil {
		return nil
	}
	return p.Completion
}

func (p *ProviderPreferencesMaxPrice) GetImage() *string {
	if p == nil {
		return nil
	}
	return p.Image
}

func (p *ProviderPreferencesMaxPrice) GetAudio() *string {
	if p == nil {
		return nil
	}
	return p.Audio
}

func (p *ProviderPreferencesMaxPrice) GetRequest() *string {
	if p == nil {
		return nil
	}
	return p.Request
}

// ProviderPreferences - Provider routing preferences for the request.
type ProviderPreferences struct {
	// Whether to allow backup providers to serve requests
	// - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
	// - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
	//
	AllowFallbacks optionalnullable.OptionalNullable[bool] `json:"allow_fallbacks,omitzero"`
	// Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
	RequireParameters optionalnullable.OptionalNullable[bool] `json:"require_parameters,omitzero"`
	// Data collection setting. If no available model provider meets the requirement, your request will return an error.
	// - allow: (default) allow providers which store user data non-transiently and may train on it
	//
	// - deny: use only providers which do not collect user data.
	DataCollection optionalnullable.OptionalNullable[DataCollection] `json:"data_collection,omitzero"`
	// Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used.
	Zdr optionalnullable.OptionalNullable[bool] `json:"zdr,omitzero"`
	// Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used.
	EnforceDistillableText optionalnullable.OptionalNullable[bool] `json:"enforce_distillable_text,omitzero"`
	// An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
	Order optionalnullable.OptionalNullable[[]ProviderPreferencesOrder] `json:"order,omitzero"`
	// List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
	Only optionalnullable.OptionalNullable[[]ProviderPreferencesOnly] `json:"only,omitzero"`
	// List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
	Ignore optionalnullable.OptionalNullable[[]ProviderPreferencesIgnore] `json:"ignore,omitzero"`
	// A list of quantization levels to filter the provider by.
	Quantizations optionalnullable.OptionalNullable[[]Quantization]               `json:"quantizations,omitzero"`
	Sort          optionalnullable.OptionalNullable[ProviderPreferencesSortUnion] `json:"sort,omitzero"`
	// The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
	MaxPrice *ProviderPreferencesMaxPrice `json:"max_price,omitzero"`
	// Preferred minimum throughput (in tokens per second). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints below the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
	PreferredMinThroughput optionalnullable.OptionalNullable[PreferredMinThroughput] `json:"preferred_min_throughput,omitzero"`
	// Preferred maximum latency (in seconds). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints above the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
	PreferredMaxLatency optionalnullable.OptionalNullable[PreferredMaxLatency] `json:"preferred_max_latency,omitzero"`
}

func (p ProviderPreferences) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProviderPreferences) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *ProviderPreferences) GetAllowFallbacks() optionalnullable.OptionalNullable[bool] {
	if p == nil {
		return nil
	}
	return p.AllowFallbacks
}

func (p *ProviderPreferences) GetRequireParameters() optionalnullable.OptionalNullable[bool] {
	if p == nil {
		return nil
	}
	return p.RequireParameters
}

func (p *ProviderPreferences) GetDataCollection() optionalnullable.OptionalNullable[DataCollection] {
	if p == nil {
		return nil
	}
	return p.DataCollection
}

func (p *ProviderPreferences) GetZdr() optionalnullable.OptionalNullable[bool] {
	if p == nil {
		return nil
	}
	return p.Zdr
}

func (p *ProviderPreferences) GetEnforceDistillableText() optionalnullable.OptionalNullable[bool] {
	if p == nil {
		return nil
	}
	return p.EnforceDistillableText
}

func (p *ProviderPreferences) GetOrder() optionalnullable.OptionalNullable[[]ProviderPreferencesOrder] {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *ProviderPreferences) GetOnly() optionalnullable.OptionalNullable[[]ProviderPreferencesOnly] {
	if p == nil {
		return nil
	}
	return p.Only
}

func (p *ProviderPreferences) GetIgnore() optionalnullable.OptionalNullable[[]ProviderPreferencesIgnore] {
	if p == nil {
		return nil
	}
	return p.Ignore
}

func (p *ProviderPreferences) GetQuantizations() optionalnullable.OptionalNullable[[]Quantization] {
	if p == nil {
		return nil
	}
	return p.Quantizations
}

func (p *ProviderPreferences) GetSort() optionalnullable.OptionalNullable[ProviderPreferencesSortUnion] {
	if p == nil {
		return nil
	}
	return p.Sort
}

func (p *ProviderPreferences) GetMaxPrice() *ProviderPreferencesMaxPrice {
	if p == nil {
		return nil
	}
	return p.MaxPrice
}

func (p *ProviderPreferences) GetPreferredMinThroughput() optionalnullable.OptionalNullable[PreferredMinThroughput] {
	if p == nil {
		return nil
	}
	return p.PreferredMinThroughput
}

func (p *ProviderPreferences) GetPreferredMaxLatency() optionalnullable.OptionalNullable[PreferredMaxLatency] {
	if p == nil {
		return nil
	}
	return p.PreferredMaxLatency
}
