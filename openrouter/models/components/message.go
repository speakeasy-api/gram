// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
)

type MessageContentType string

const (
	MessageContentTypeStr                               MessageContentType = "str"
	MessageContentTypeArrayOfChatMessageContentItemText MessageContentType = "arrayOfChatMessageContentItemText"
)

type MessageContent struct {
	Str                               *string                      `queryParam:"inline" union:"member"`
	ArrayOfChatMessageContentItemText []ChatMessageContentItemText `queryParam:"inline" union:"member"`

	Type MessageContentType
}

func CreateMessageContentStr(str string) MessageContent {
	typ := MessageContentTypeStr

	return MessageContent{
		Str:  &str,
		Type: typ,
	}
}

func CreateMessageContentArrayOfChatMessageContentItemText(arrayOfChatMessageContentItemText []ChatMessageContentItemText) MessageContent {
	typ := MessageContentTypeArrayOfChatMessageContentItemText

	return MessageContent{
		ArrayOfChatMessageContentItemText: arrayOfChatMessageContentItemText,
		Type:                              typ,
	}
}

func (u *MessageContent) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MessageContentTypeStr,
			Value: &str,
		})
	}

	var arrayOfChatMessageContentItemText []ChatMessageContentItemText = []ChatMessageContentItemText{}
	if err := utils.UnmarshalJSON(data, &arrayOfChatMessageContentItemText, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MessageContentTypeArrayOfChatMessageContentItemText,
			Value: arrayOfChatMessageContentItemText,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageContent", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageContent", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MessageContentType)
	switch best.Type {
	case MessageContentTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case MessageContentTypeArrayOfChatMessageContentItemText:
		u.ArrayOfChatMessageContentItemText = best.Value.([]ChatMessageContentItemText)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageContent", string(data))
}

func (u MessageContent) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfChatMessageContentItemText != nil {
		return utils.MarshalJSON(u.ArrayOfChatMessageContentItemText, "", true)
	}

	return nil, errors.New("could not marshal union type MessageContent: all fields are null")
}

type MessageDeveloper struct {
	role    string         `const:"developer" json:"role"`
	Content MessageContent `json:"content"`
	Name    *string        `json:"name,omitzero"`
}

func (m MessageDeveloper) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MessageDeveloper) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *MessageDeveloper) GetRole() string {
	return "developer"
}

func (m *MessageDeveloper) GetContent() MessageContent {
	if m == nil {
		return MessageContent{}
	}
	return m.Content
}

func (m *MessageDeveloper) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

type MessageType string

const (
	MessageTypeSystem    MessageType = "system"
	MessageTypeUser      MessageType = "user"
	MessageTypeDeveloper MessageType = "developer"
	MessageTypeAssistant MessageType = "assistant"
	MessageTypeTool      MessageType = "tool"
)

type Message struct {
	SystemMessage       *SystemMessage       `queryParam:"inline" union:"member"`
	UserMessage         *UserMessage         `queryParam:"inline" union:"member"`
	MessageDeveloper    *MessageDeveloper    `queryParam:"inline" union:"member"`
	AssistantMessage    *AssistantMessage    `queryParam:"inline" union:"member"`
	ToolResponseMessage *ToolResponseMessage `queryParam:"inline" union:"member"`

	Type MessageType
}

func CreateMessageSystem(system SystemMessage) Message {
	typ := MessageTypeSystem

	return Message{
		SystemMessage: &system,
		Type:          typ,
	}
}

func CreateMessageUser(user UserMessage) Message {
	typ := MessageTypeUser

	return Message{
		UserMessage: &user,
		Type:        typ,
	}
}

func CreateMessageDeveloper(developer MessageDeveloper) Message {
	typ := MessageTypeDeveloper

	return Message{
		MessageDeveloper: &developer,
		Type:             typ,
	}
}

func CreateMessageAssistant(assistant AssistantMessage) Message {
	typ := MessageTypeAssistant

	return Message{
		AssistantMessage: &assistant,
		Type:             typ,
	}
}

func CreateMessageTool(tool ToolResponseMessage) Message {
	typ := MessageTypeTool

	return Message{
		ToolResponseMessage: &tool,
		Type:                typ,
	}
}

func (u *Message) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Role string `json:"role"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Role {
	case "system":
		systemMessage := new(SystemMessage)
		if err := utils.UnmarshalJSON(data, &systemMessage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Role == system) type SystemMessage within Message: %w", string(data), err)
		}

		u.SystemMessage = systemMessage
		u.Type = MessageTypeSystem
		return nil
	case "user":
		userMessage := new(UserMessage)
		if err := utils.UnmarshalJSON(data, &userMessage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Role == user) type UserMessage within Message: %w", string(data), err)
		}

		u.UserMessage = userMessage
		u.Type = MessageTypeUser
		return nil
	case "developer":
		messageDeveloper := new(MessageDeveloper)
		if err := utils.UnmarshalJSON(data, &messageDeveloper, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Role == developer) type MessageDeveloper within Message: %w", string(data), err)
		}

		u.MessageDeveloper = messageDeveloper
		u.Type = MessageTypeDeveloper
		return nil
	case "assistant":
		assistantMessage := new(AssistantMessage)
		if err := utils.UnmarshalJSON(data, &assistantMessage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Role == assistant) type AssistantMessage within Message: %w", string(data), err)
		}

		u.AssistantMessage = assistantMessage
		u.Type = MessageTypeAssistant
		return nil
	case "tool":
		toolResponseMessage := new(ToolResponseMessage)
		if err := utils.UnmarshalJSON(data, &toolResponseMessage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Role == tool) type ToolResponseMessage within Message: %w", string(data), err)
		}

		u.ToolResponseMessage = toolResponseMessage
		u.Type = MessageTypeTool
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Message", string(data))
}

func (u Message) MarshalJSON() ([]byte, error) {
	if u.SystemMessage != nil {
		return utils.MarshalJSON(u.SystemMessage, "", true)
	}

	if u.UserMessage != nil {
		return utils.MarshalJSON(u.UserMessage, "", true)
	}

	if u.MessageDeveloper != nil {
		return utils.MarshalJSON(u.MessageDeveloper, "", true)
	}

	if u.AssistantMessage != nil {
		return utils.MarshalJSON(u.AssistantMessage, "", true)
	}

	if u.ToolResponseMessage != nil {
		return utils.MarshalJSON(u.ToolResponseMessage, "", true)
	}

	return nil, errors.New("could not marshal union type Message: all fields are null")
}
