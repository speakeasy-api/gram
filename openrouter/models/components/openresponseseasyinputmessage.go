// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type OpenResponsesEasyInputMessageTypeMessage string

const (
	OpenResponsesEasyInputMessageTypeMessageMessage OpenResponsesEasyInputMessageTypeMessage = "message"
)

func (e OpenResponsesEasyInputMessageTypeMessage) ToPointer() *OpenResponsesEasyInputMessageTypeMessage {
	return &e
}
func (e *OpenResponsesEasyInputMessageTypeMessage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "message":
		*e = OpenResponsesEasyInputMessageTypeMessage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesEasyInputMessageTypeMessage: %v", v)
	}
}

type OpenResponsesEasyInputMessageRoleDeveloper string

const (
	OpenResponsesEasyInputMessageRoleDeveloperDeveloper OpenResponsesEasyInputMessageRoleDeveloper = "developer"
)

func (e OpenResponsesEasyInputMessageRoleDeveloper) ToPointer() *OpenResponsesEasyInputMessageRoleDeveloper {
	return &e
}
func (e *OpenResponsesEasyInputMessageRoleDeveloper) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "developer":
		*e = OpenResponsesEasyInputMessageRoleDeveloper(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesEasyInputMessageRoleDeveloper: %v", v)
	}
}

type OpenResponsesEasyInputMessageRoleAssistant string

const (
	OpenResponsesEasyInputMessageRoleAssistantAssistant OpenResponsesEasyInputMessageRoleAssistant = "assistant"
)

func (e OpenResponsesEasyInputMessageRoleAssistant) ToPointer() *OpenResponsesEasyInputMessageRoleAssistant {
	return &e
}
func (e *OpenResponsesEasyInputMessageRoleAssistant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "assistant":
		*e = OpenResponsesEasyInputMessageRoleAssistant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesEasyInputMessageRoleAssistant: %v", v)
	}
}

type OpenResponsesEasyInputMessageRoleSystem string

const (
	OpenResponsesEasyInputMessageRoleSystemSystem OpenResponsesEasyInputMessageRoleSystem = "system"
)

func (e OpenResponsesEasyInputMessageRoleSystem) ToPointer() *OpenResponsesEasyInputMessageRoleSystem {
	return &e
}
func (e *OpenResponsesEasyInputMessageRoleSystem) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system":
		*e = OpenResponsesEasyInputMessageRoleSystem(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesEasyInputMessageRoleSystem: %v", v)
	}
}

type OpenResponsesEasyInputMessageRoleUser string

const (
	OpenResponsesEasyInputMessageRoleUserUser OpenResponsesEasyInputMessageRoleUser = "user"
)

func (e OpenResponsesEasyInputMessageRoleUser) ToPointer() *OpenResponsesEasyInputMessageRoleUser {
	return &e
}
func (e *OpenResponsesEasyInputMessageRoleUser) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = OpenResponsesEasyInputMessageRoleUser(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesEasyInputMessageRoleUser: %v", v)
	}
}

type OpenResponsesEasyInputMessageRoleUnionType string

const (
	OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleUser      OpenResponsesEasyInputMessageRoleUnionType = "OpenResponsesEasyInputMessage_role_User"
	OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleSystem    OpenResponsesEasyInputMessageRoleUnionType = "OpenResponsesEasyInputMessage_role_System"
	OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleAssistant OpenResponsesEasyInputMessageRoleUnionType = "OpenResponsesEasyInputMessage_role_Assistant"
	OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleDeveloper OpenResponsesEasyInputMessageRoleUnionType = "OpenResponsesEasyInputMessage_role_Developer"
)

type OpenResponsesEasyInputMessageRoleUnion struct {
	OpenResponsesEasyInputMessageRoleUser      *OpenResponsesEasyInputMessageRoleUser      `queryParam:"inline" union:"member"`
	OpenResponsesEasyInputMessageRoleSystem    *OpenResponsesEasyInputMessageRoleSystem    `queryParam:"inline" union:"member"`
	OpenResponsesEasyInputMessageRoleAssistant *OpenResponsesEasyInputMessageRoleAssistant `queryParam:"inline" union:"member"`
	OpenResponsesEasyInputMessageRoleDeveloper *OpenResponsesEasyInputMessageRoleDeveloper `queryParam:"inline" union:"member"`

	Type OpenResponsesEasyInputMessageRoleUnionType
}

func CreateOpenResponsesEasyInputMessageRoleUnionOpenResponsesEasyInputMessageRoleUser(openResponsesEasyInputMessageRoleUser OpenResponsesEasyInputMessageRoleUser) OpenResponsesEasyInputMessageRoleUnion {
	typ := OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleUser

	return OpenResponsesEasyInputMessageRoleUnion{
		OpenResponsesEasyInputMessageRoleUser: &openResponsesEasyInputMessageRoleUser,
		Type:                                  typ,
	}
}

func CreateOpenResponsesEasyInputMessageRoleUnionOpenResponsesEasyInputMessageRoleSystem(openResponsesEasyInputMessageRoleSystem OpenResponsesEasyInputMessageRoleSystem) OpenResponsesEasyInputMessageRoleUnion {
	typ := OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleSystem

	return OpenResponsesEasyInputMessageRoleUnion{
		OpenResponsesEasyInputMessageRoleSystem: &openResponsesEasyInputMessageRoleSystem,
		Type:                                    typ,
	}
}

func CreateOpenResponsesEasyInputMessageRoleUnionOpenResponsesEasyInputMessageRoleAssistant(openResponsesEasyInputMessageRoleAssistant OpenResponsesEasyInputMessageRoleAssistant) OpenResponsesEasyInputMessageRoleUnion {
	typ := OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleAssistant

	return OpenResponsesEasyInputMessageRoleUnion{
		OpenResponsesEasyInputMessageRoleAssistant: &openResponsesEasyInputMessageRoleAssistant,
		Type: typ,
	}
}

func CreateOpenResponsesEasyInputMessageRoleUnionOpenResponsesEasyInputMessageRoleDeveloper(openResponsesEasyInputMessageRoleDeveloper OpenResponsesEasyInputMessageRoleDeveloper) OpenResponsesEasyInputMessageRoleUnion {
	typ := OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleDeveloper

	return OpenResponsesEasyInputMessageRoleUnion{
		OpenResponsesEasyInputMessageRoleDeveloper: &openResponsesEasyInputMessageRoleDeveloper,
		Type: typ,
	}
}

func (u *OpenResponsesEasyInputMessageRoleUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openResponsesEasyInputMessageRoleUser OpenResponsesEasyInputMessageRoleUser = OpenResponsesEasyInputMessageRoleUser("")
	if err := utils.UnmarshalJSON(data, &openResponsesEasyInputMessageRoleUser, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleUser,
			Value: &openResponsesEasyInputMessageRoleUser,
		})
	}

	var openResponsesEasyInputMessageRoleSystem OpenResponsesEasyInputMessageRoleSystem = OpenResponsesEasyInputMessageRoleSystem("")
	if err := utils.UnmarshalJSON(data, &openResponsesEasyInputMessageRoleSystem, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleSystem,
			Value: &openResponsesEasyInputMessageRoleSystem,
		})
	}

	var openResponsesEasyInputMessageRoleAssistant OpenResponsesEasyInputMessageRoleAssistant = OpenResponsesEasyInputMessageRoleAssistant("")
	if err := utils.UnmarshalJSON(data, &openResponsesEasyInputMessageRoleAssistant, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleAssistant,
			Value: &openResponsesEasyInputMessageRoleAssistant,
		})
	}

	var openResponsesEasyInputMessageRoleDeveloper OpenResponsesEasyInputMessageRoleDeveloper = OpenResponsesEasyInputMessageRoleDeveloper("")
	if err := utils.UnmarshalJSON(data, &openResponsesEasyInputMessageRoleDeveloper, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleDeveloper,
			Value: &openResponsesEasyInputMessageRoleDeveloper,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageRoleUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageRoleUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesEasyInputMessageRoleUnionType)
	switch best.Type {
	case OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleUser:
		u.OpenResponsesEasyInputMessageRoleUser = best.Value.(*OpenResponsesEasyInputMessageRoleUser)
		return nil
	case OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleSystem:
		u.OpenResponsesEasyInputMessageRoleSystem = best.Value.(*OpenResponsesEasyInputMessageRoleSystem)
		return nil
	case OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleAssistant:
		u.OpenResponsesEasyInputMessageRoleAssistant = best.Value.(*OpenResponsesEasyInputMessageRoleAssistant)
		return nil
	case OpenResponsesEasyInputMessageRoleUnionTypeOpenResponsesEasyInputMessageRoleDeveloper:
		u.OpenResponsesEasyInputMessageRoleDeveloper = best.Value.(*OpenResponsesEasyInputMessageRoleDeveloper)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageRoleUnion", string(data))
}

func (u OpenResponsesEasyInputMessageRoleUnion) MarshalJSON() ([]byte, error) {
	if u.OpenResponsesEasyInputMessageRoleUser != nil {
		return utils.MarshalJSON(u.OpenResponsesEasyInputMessageRoleUser, "", true)
	}

	if u.OpenResponsesEasyInputMessageRoleSystem != nil {
		return utils.MarshalJSON(u.OpenResponsesEasyInputMessageRoleSystem, "", true)
	}

	if u.OpenResponsesEasyInputMessageRoleAssistant != nil {
		return utils.MarshalJSON(u.OpenResponsesEasyInputMessageRoleAssistant, "", true)
	}

	if u.OpenResponsesEasyInputMessageRoleDeveloper != nil {
		return utils.MarshalJSON(u.OpenResponsesEasyInputMessageRoleDeveloper, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesEasyInputMessageRoleUnion: all fields are null")
}

type OpenResponsesEasyInputMessageContentType string

const (
	OpenResponsesEasyInputMessageContentTypeInputImage OpenResponsesEasyInputMessageContentType = "input_image"
)

func (e OpenResponsesEasyInputMessageContentType) ToPointer() *OpenResponsesEasyInputMessageContentType {
	return &e
}
func (e *OpenResponsesEasyInputMessageContentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "input_image":
		*e = OpenResponsesEasyInputMessageContentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesEasyInputMessageContentType: %v", v)
	}
}

type OpenResponsesEasyInputMessageDetail string

const (
	OpenResponsesEasyInputMessageDetailAuto OpenResponsesEasyInputMessageDetail = "auto"
	OpenResponsesEasyInputMessageDetailHigh OpenResponsesEasyInputMessageDetail = "high"
	OpenResponsesEasyInputMessageDetailLow  OpenResponsesEasyInputMessageDetail = "low"
)

func (e OpenResponsesEasyInputMessageDetail) ToPointer() *OpenResponsesEasyInputMessageDetail {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *OpenResponsesEasyInputMessageDetail) IsExact() bool {
	if e != nil {
		switch *e {
		case "auto", "high", "low":
			return true
		}
	}
	return false
}

// OpenResponsesEasyInputMessageContentInputImage - Image input content item
type OpenResponsesEasyInputMessageContentInputImage struct {
	Type     OpenResponsesEasyInputMessageContentType  `json:"type"`
	Detail   OpenResponsesEasyInputMessageDetail       `json:"detail"`
	ImageURL optionalnullable.OptionalNullable[string] `json:"image_url,omitzero"`
}

func (o OpenResponsesEasyInputMessageContentInputImage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesEasyInputMessageContentInputImage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesEasyInputMessageContentInputImage) GetType() OpenResponsesEasyInputMessageContentType {
	if o == nil {
		return OpenResponsesEasyInputMessageContentType("")
	}
	return o.Type
}

func (o *OpenResponsesEasyInputMessageContentInputImage) GetDetail() OpenResponsesEasyInputMessageDetail {
	if o == nil {
		return OpenResponsesEasyInputMessageDetail("")
	}
	return o.Detail
}

func (o *OpenResponsesEasyInputMessageContentInputImage) GetImageURL() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.ImageURL
}

type OpenResponsesEasyInputMessageContentUnion1Type string

const (
	OpenResponsesEasyInputMessageContentUnion1TypeInputText  OpenResponsesEasyInputMessageContentUnion1Type = "input_text"
	OpenResponsesEasyInputMessageContentUnion1TypeInputImage OpenResponsesEasyInputMessageContentUnion1Type = "input_image"
	OpenResponsesEasyInputMessageContentUnion1TypeInputFile  OpenResponsesEasyInputMessageContentUnion1Type = "input_file"
	OpenResponsesEasyInputMessageContentUnion1TypeInputAudio OpenResponsesEasyInputMessageContentUnion1Type = "input_audio"
	OpenResponsesEasyInputMessageContentUnion1TypeInputVideo OpenResponsesEasyInputMessageContentUnion1Type = "input_video"
)

type OpenResponsesEasyInputMessageContentUnion1 struct {
	ResponseInputText                              *ResponseInputText                              `queryParam:"inline" union:"member"`
	OpenResponsesEasyInputMessageContentInputImage *OpenResponsesEasyInputMessageContentInputImage `queryParam:"inline" union:"member"`
	ResponseInputFile                              *ResponseInputFile                              `queryParam:"inline" union:"member"`
	ResponseInputAudio                             *ResponseInputAudio                             `queryParam:"inline" union:"member"`
	ResponseInputVideo                             *ResponseInputVideo                             `queryParam:"inline" union:"member"`

	Type OpenResponsesEasyInputMessageContentUnion1Type
}

func CreateOpenResponsesEasyInputMessageContentUnion1InputText(inputText ResponseInputText) OpenResponsesEasyInputMessageContentUnion1 {
	typ := OpenResponsesEasyInputMessageContentUnion1TypeInputText

	typStr := ResponseInputTextType(typ)
	inputText.Type = typStr

	return OpenResponsesEasyInputMessageContentUnion1{
		ResponseInputText: &inputText,
		Type:              typ,
	}
}

func CreateOpenResponsesEasyInputMessageContentUnion1InputImage(inputImage OpenResponsesEasyInputMessageContentInputImage) OpenResponsesEasyInputMessageContentUnion1 {
	typ := OpenResponsesEasyInputMessageContentUnion1TypeInputImage

	typStr := OpenResponsesEasyInputMessageContentType(typ)
	inputImage.Type = typStr

	return OpenResponsesEasyInputMessageContentUnion1{
		OpenResponsesEasyInputMessageContentInputImage: &inputImage,
		Type: typ,
	}
}

func CreateOpenResponsesEasyInputMessageContentUnion1InputFile(inputFile ResponseInputFile) OpenResponsesEasyInputMessageContentUnion1 {
	typ := OpenResponsesEasyInputMessageContentUnion1TypeInputFile

	typStr := ResponseInputFileType(typ)
	inputFile.Type = typStr

	return OpenResponsesEasyInputMessageContentUnion1{
		ResponseInputFile: &inputFile,
		Type:              typ,
	}
}

func CreateOpenResponsesEasyInputMessageContentUnion1InputAudio(inputAudio ResponseInputAudio) OpenResponsesEasyInputMessageContentUnion1 {
	typ := OpenResponsesEasyInputMessageContentUnion1TypeInputAudio

	typStr := ResponseInputAudioType(typ)
	inputAudio.Type = typStr

	return OpenResponsesEasyInputMessageContentUnion1{
		ResponseInputAudio: &inputAudio,
		Type:               typ,
	}
}

func CreateOpenResponsesEasyInputMessageContentUnion1InputVideo(inputVideo ResponseInputVideo) OpenResponsesEasyInputMessageContentUnion1 {
	typ := OpenResponsesEasyInputMessageContentUnion1TypeInputVideo

	typStr := ResponseInputVideoType(typ)
	inputVideo.Type = typStr

	return OpenResponsesEasyInputMessageContentUnion1{
		ResponseInputVideo: &inputVideo,
		Type:               typ,
	}
}

func (u *OpenResponsesEasyInputMessageContentUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "input_text":
		responseInputText := new(ResponseInputText)
		if err := utils.UnmarshalJSON(data, &responseInputText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_text) type ResponseInputText within OpenResponsesEasyInputMessageContentUnion1: %w", string(data), err)
		}

		u.ResponseInputText = responseInputText
		u.Type = OpenResponsesEasyInputMessageContentUnion1TypeInputText
		return nil
	case "input_image":
		openResponsesEasyInputMessageContentInputImage := new(OpenResponsesEasyInputMessageContentInputImage)
		if err := utils.UnmarshalJSON(data, &openResponsesEasyInputMessageContentInputImage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_image) type OpenResponsesEasyInputMessageContentInputImage within OpenResponsesEasyInputMessageContentUnion1: %w", string(data), err)
		}

		u.OpenResponsesEasyInputMessageContentInputImage = openResponsesEasyInputMessageContentInputImage
		u.Type = OpenResponsesEasyInputMessageContentUnion1TypeInputImage
		return nil
	case "input_file":
		responseInputFile := new(ResponseInputFile)
		if err := utils.UnmarshalJSON(data, &responseInputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_file) type ResponseInputFile within OpenResponsesEasyInputMessageContentUnion1: %w", string(data), err)
		}

		u.ResponseInputFile = responseInputFile
		u.Type = OpenResponsesEasyInputMessageContentUnion1TypeInputFile
		return nil
	case "input_audio":
		responseInputAudio := new(ResponseInputAudio)
		if err := utils.UnmarshalJSON(data, &responseInputAudio, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_audio) type ResponseInputAudio within OpenResponsesEasyInputMessageContentUnion1: %w", string(data), err)
		}

		u.ResponseInputAudio = responseInputAudio
		u.Type = OpenResponsesEasyInputMessageContentUnion1TypeInputAudio
		return nil
	case "input_video":
		responseInputVideo := new(ResponseInputVideo)
		if err := utils.UnmarshalJSON(data, &responseInputVideo, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_video) type ResponseInputVideo within OpenResponsesEasyInputMessageContentUnion1: %w", string(data), err)
		}

		u.ResponseInputVideo = responseInputVideo
		u.Type = OpenResponsesEasyInputMessageContentUnion1TypeInputVideo
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageContentUnion1", string(data))
}

func (u OpenResponsesEasyInputMessageContentUnion1) MarshalJSON() ([]byte, error) {
	if u.ResponseInputText != nil {
		return utils.MarshalJSON(u.ResponseInputText, "", true)
	}

	if u.OpenResponsesEasyInputMessageContentInputImage != nil {
		return utils.MarshalJSON(u.OpenResponsesEasyInputMessageContentInputImage, "", true)
	}

	if u.ResponseInputFile != nil {
		return utils.MarshalJSON(u.ResponseInputFile, "", true)
	}

	if u.ResponseInputAudio != nil {
		return utils.MarshalJSON(u.ResponseInputAudio, "", true)
	}

	if u.ResponseInputVideo != nil {
		return utils.MarshalJSON(u.ResponseInputVideo, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesEasyInputMessageContentUnion1: all fields are null")
}

type OpenResponsesEasyInputMessageContentUnion2Type string

const (
	OpenResponsesEasyInputMessageContentUnion2TypeArrayOfOpenResponsesEasyInputMessageContentUnion1 OpenResponsesEasyInputMessageContentUnion2Type = "arrayOfOpenResponsesEasyInputMessageContentUnion1"
	OpenResponsesEasyInputMessageContentUnion2TypeStr                                               OpenResponsesEasyInputMessageContentUnion2Type = "str"
)

type OpenResponsesEasyInputMessageContentUnion2 struct {
	ArrayOfOpenResponsesEasyInputMessageContentUnion1 []OpenResponsesEasyInputMessageContentUnion1 `queryParam:"inline" union:"member"`
	Str                                               *string                                      `queryParam:"inline" union:"member"`

	Type OpenResponsesEasyInputMessageContentUnion2Type
}

func CreateOpenResponsesEasyInputMessageContentUnion2ArrayOfOpenResponsesEasyInputMessageContentUnion1(arrayOfOpenResponsesEasyInputMessageContentUnion1 []OpenResponsesEasyInputMessageContentUnion1) OpenResponsesEasyInputMessageContentUnion2 {
	typ := OpenResponsesEasyInputMessageContentUnion2TypeArrayOfOpenResponsesEasyInputMessageContentUnion1

	return OpenResponsesEasyInputMessageContentUnion2{
		ArrayOfOpenResponsesEasyInputMessageContentUnion1: arrayOfOpenResponsesEasyInputMessageContentUnion1,
		Type: typ,
	}
}

func CreateOpenResponsesEasyInputMessageContentUnion2Str(str string) OpenResponsesEasyInputMessageContentUnion2 {
	typ := OpenResponsesEasyInputMessageContentUnion2TypeStr

	return OpenResponsesEasyInputMessageContentUnion2{
		Str:  &str,
		Type: typ,
	}
}

func (u *OpenResponsesEasyInputMessageContentUnion2) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOfOpenResponsesEasyInputMessageContentUnion1 []OpenResponsesEasyInputMessageContentUnion1 = []OpenResponsesEasyInputMessageContentUnion1{}
	if err := utils.UnmarshalJSON(data, &arrayOfOpenResponsesEasyInputMessageContentUnion1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesEasyInputMessageContentUnion2TypeArrayOfOpenResponsesEasyInputMessageContentUnion1,
			Value: arrayOfOpenResponsesEasyInputMessageContentUnion1,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesEasyInputMessageContentUnion2TypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageContentUnion2", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageContentUnion2", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesEasyInputMessageContentUnion2Type)
	switch best.Type {
	case OpenResponsesEasyInputMessageContentUnion2TypeArrayOfOpenResponsesEasyInputMessageContentUnion1:
		u.ArrayOfOpenResponsesEasyInputMessageContentUnion1 = best.Value.([]OpenResponsesEasyInputMessageContentUnion1)
		return nil
	case OpenResponsesEasyInputMessageContentUnion2TypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesEasyInputMessageContentUnion2", string(data))
}

func (u OpenResponsesEasyInputMessageContentUnion2) MarshalJSON() ([]byte, error) {
	if u.ArrayOfOpenResponsesEasyInputMessageContentUnion1 != nil {
		return utils.MarshalJSON(u.ArrayOfOpenResponsesEasyInputMessageContentUnion1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesEasyInputMessageContentUnion2: all fields are null")
}

type OpenResponsesEasyInputMessage struct {
	Type    *OpenResponsesEasyInputMessageTypeMessage  `json:"type,omitzero"`
	Role    OpenResponsesEasyInputMessageRoleUnion     `json:"role"`
	Content OpenResponsesEasyInputMessageContentUnion2 `json:"content"`
}

func (o OpenResponsesEasyInputMessage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesEasyInputMessage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesEasyInputMessage) GetType() *OpenResponsesEasyInputMessageTypeMessage {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OpenResponsesEasyInputMessage) GetRole() OpenResponsesEasyInputMessageRoleUnion {
	if o == nil {
		return OpenResponsesEasyInputMessageRoleUnion{}
	}
	return o.Role
}

func (o *OpenResponsesEasyInputMessage) GetContent() OpenResponsesEasyInputMessageContentUnion2 {
	if o == nil {
		return OpenResponsesEasyInputMessageContentUnion2{}
	}
	return o.Content
}
