// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type ChatGenerationParamsDataCollection string

const (
	ChatGenerationParamsDataCollectionDeny  ChatGenerationParamsDataCollection = "deny"
	ChatGenerationParamsDataCollectionAllow ChatGenerationParamsDataCollection = "allow"
)

func (e ChatGenerationParamsDataCollection) ToPointer() *ChatGenerationParamsDataCollection {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ChatGenerationParamsDataCollection) IsExact() bool {
	if e != nil {
		switch *e {
		case "deny", "allow":
			return true
		}
	}
	return false
}

type Quantizations string

const (
	QuantizationsInt4    Quantizations = "int4"
	QuantizationsInt8    Quantizations = "int8"
	QuantizationsFp4     Quantizations = "fp4"
	QuantizationsFp6     Quantizations = "fp6"
	QuantizationsFp8     Quantizations = "fp8"
	QuantizationsFp16    Quantizations = "fp16"
	QuantizationsBf16    Quantizations = "bf16"
	QuantizationsFp32    Quantizations = "fp32"
	QuantizationsUnknown Quantizations = "unknown"
)

func (e Quantizations) ToPointer() *Quantizations {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Quantizations) IsExact() bool {
	if e != nil {
		switch *e {
		case "int4", "int8", "fp4", "fp6", "fp8", "fp16", "bf16", "fp32", "unknown":
			return true
		}
	}
	return false
}

// ChatGenerationParamsMaxPrice - The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
type ChatGenerationParamsMaxPrice struct {
	Prompt     any `json:"prompt,omitzero"`
	Completion any `json:"completion,omitzero"`
	Image      any `json:"image,omitzero"`
	Audio      any `json:"audio,omitzero"`
	Request    any `json:"request,omitzero"`
}

func (c *ChatGenerationParamsMaxPrice) GetPrompt() any {
	if c == nil {
		return nil
	}
	return c.Prompt
}

func (c *ChatGenerationParamsMaxPrice) GetCompletion() any {
	if c == nil {
		return nil
	}
	return c.Completion
}

func (c *ChatGenerationParamsMaxPrice) GetImage() any {
	if c == nil {
		return nil
	}
	return c.Image
}

func (c *ChatGenerationParamsMaxPrice) GetAudio() any {
	if c == nil {
		return nil
	}
	return c.Audio
}

func (c *ChatGenerationParamsMaxPrice) GetRequest() any {
	if c == nil {
		return nil
	}
	return c.Request
}

type ChatGenerationParamsPreferredMinThroughput struct {
	P50 optionalnullable.OptionalNullable[float64] `json:"p50,omitzero"`
	P75 optionalnullable.OptionalNullable[float64] `json:"p75,omitzero"`
	P90 optionalnullable.OptionalNullable[float64] `json:"p90,omitzero"`
	P99 optionalnullable.OptionalNullable[float64] `json:"p99,omitzero"`
}

func (c ChatGenerationParamsPreferredMinThroughput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPreferredMinThroughput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPreferredMinThroughput) GetP50() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P50
}

func (c *ChatGenerationParamsPreferredMinThroughput) GetP75() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P75
}

func (c *ChatGenerationParamsPreferredMinThroughput) GetP90() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P90
}

func (c *ChatGenerationParamsPreferredMinThroughput) GetP99() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P99
}

type ChatGenerationParamsPreferredMinThroughputUnionType string

const (
	ChatGenerationParamsPreferredMinThroughputUnionTypeNumber                                     ChatGenerationParamsPreferredMinThroughputUnionType = "number"
	ChatGenerationParamsPreferredMinThroughputUnionTypeChatGenerationParamsPreferredMinThroughput ChatGenerationParamsPreferredMinThroughputUnionType = "ChatGenerationParams_preferred_min_throughput"
)

type ChatGenerationParamsPreferredMinThroughputUnion struct {
	Number                                     *float64                                    `queryParam:"inline" union:"member"`
	ChatGenerationParamsPreferredMinThroughput *ChatGenerationParamsPreferredMinThroughput `queryParam:"inline" union:"member"`

	Type ChatGenerationParamsPreferredMinThroughputUnionType
}

func CreateChatGenerationParamsPreferredMinThroughputUnionNumber(number float64) ChatGenerationParamsPreferredMinThroughputUnion {
	typ := ChatGenerationParamsPreferredMinThroughputUnionTypeNumber

	return ChatGenerationParamsPreferredMinThroughputUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateChatGenerationParamsPreferredMinThroughputUnionChatGenerationParamsPreferredMinThroughput(chatGenerationParamsPreferredMinThroughput ChatGenerationParamsPreferredMinThroughput) ChatGenerationParamsPreferredMinThroughputUnion {
	typ := ChatGenerationParamsPreferredMinThroughputUnionTypeChatGenerationParamsPreferredMinThroughput

	return ChatGenerationParamsPreferredMinThroughputUnion{
		ChatGenerationParamsPreferredMinThroughput: &chatGenerationParamsPreferredMinThroughput,
		Type: typ,
	}
}

func (u *ChatGenerationParamsPreferredMinThroughputUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsPreferredMinThroughputUnionTypeNumber,
			Value: &number,
		})
	}

	var chatGenerationParamsPreferredMinThroughput ChatGenerationParamsPreferredMinThroughput = ChatGenerationParamsPreferredMinThroughput{}
	if err := utils.UnmarshalJSON(data, &chatGenerationParamsPreferredMinThroughput, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsPreferredMinThroughputUnionTypeChatGenerationParamsPreferredMinThroughput,
			Value: &chatGenerationParamsPreferredMinThroughput,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPreferredMinThroughputUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPreferredMinThroughputUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ChatGenerationParamsPreferredMinThroughputUnionType)
	switch best.Type {
	case ChatGenerationParamsPreferredMinThroughputUnionTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case ChatGenerationParamsPreferredMinThroughputUnionTypeChatGenerationParamsPreferredMinThroughput:
		u.ChatGenerationParamsPreferredMinThroughput = best.Value.(*ChatGenerationParamsPreferredMinThroughput)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPreferredMinThroughputUnion", string(data))
}

func (u ChatGenerationParamsPreferredMinThroughputUnion) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.ChatGenerationParamsPreferredMinThroughput != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPreferredMinThroughput, "", true)
	}

	return nil, errors.New("could not marshal union type ChatGenerationParamsPreferredMinThroughputUnion: all fields are null")
}

type ChatGenerationParamsPreferredMaxLatency struct {
	P50 optionalnullable.OptionalNullable[float64] `json:"p50,omitzero"`
	P75 optionalnullable.OptionalNullable[float64] `json:"p75,omitzero"`
	P90 optionalnullable.OptionalNullable[float64] `json:"p90,omitzero"`
	P99 optionalnullable.OptionalNullable[float64] `json:"p99,omitzero"`
}

func (c ChatGenerationParamsPreferredMaxLatency) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPreferredMaxLatency) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPreferredMaxLatency) GetP50() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P50
}

func (c *ChatGenerationParamsPreferredMaxLatency) GetP75() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P75
}

func (c *ChatGenerationParamsPreferredMaxLatency) GetP90() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P90
}

func (c *ChatGenerationParamsPreferredMaxLatency) GetP99() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.P99
}

type ChatGenerationParamsPreferredMaxLatencyUnionType string

const (
	ChatGenerationParamsPreferredMaxLatencyUnionTypeNumber                                  ChatGenerationParamsPreferredMaxLatencyUnionType = "number"
	ChatGenerationParamsPreferredMaxLatencyUnionTypeChatGenerationParamsPreferredMaxLatency ChatGenerationParamsPreferredMaxLatencyUnionType = "ChatGenerationParams_preferred_max_latency"
)

type ChatGenerationParamsPreferredMaxLatencyUnion struct {
	Number                                  *float64                                 `queryParam:"inline" union:"member"`
	ChatGenerationParamsPreferredMaxLatency *ChatGenerationParamsPreferredMaxLatency `queryParam:"inline" union:"member"`

	Type ChatGenerationParamsPreferredMaxLatencyUnionType
}

func CreateChatGenerationParamsPreferredMaxLatencyUnionNumber(number float64) ChatGenerationParamsPreferredMaxLatencyUnion {
	typ := ChatGenerationParamsPreferredMaxLatencyUnionTypeNumber

	return ChatGenerationParamsPreferredMaxLatencyUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateChatGenerationParamsPreferredMaxLatencyUnionChatGenerationParamsPreferredMaxLatency(chatGenerationParamsPreferredMaxLatency ChatGenerationParamsPreferredMaxLatency) ChatGenerationParamsPreferredMaxLatencyUnion {
	typ := ChatGenerationParamsPreferredMaxLatencyUnionTypeChatGenerationParamsPreferredMaxLatency

	return ChatGenerationParamsPreferredMaxLatencyUnion{
		ChatGenerationParamsPreferredMaxLatency: &chatGenerationParamsPreferredMaxLatency,
		Type:                                    typ,
	}
}

func (u *ChatGenerationParamsPreferredMaxLatencyUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsPreferredMaxLatencyUnionTypeNumber,
			Value: &number,
		})
	}

	var chatGenerationParamsPreferredMaxLatency ChatGenerationParamsPreferredMaxLatency = ChatGenerationParamsPreferredMaxLatency{}
	if err := utils.UnmarshalJSON(data, &chatGenerationParamsPreferredMaxLatency, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsPreferredMaxLatencyUnionTypeChatGenerationParamsPreferredMaxLatency,
			Value: &chatGenerationParamsPreferredMaxLatency,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPreferredMaxLatencyUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPreferredMaxLatencyUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ChatGenerationParamsPreferredMaxLatencyUnionType)
	switch best.Type {
	case ChatGenerationParamsPreferredMaxLatencyUnionTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case ChatGenerationParamsPreferredMaxLatencyUnionTypeChatGenerationParamsPreferredMaxLatency:
		u.ChatGenerationParamsPreferredMaxLatency = best.Value.(*ChatGenerationParamsPreferredMaxLatency)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPreferredMaxLatencyUnion", string(data))
}

func (u ChatGenerationParamsPreferredMaxLatencyUnion) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.ChatGenerationParamsPreferredMaxLatency != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPreferredMaxLatency, "", true)
	}

	return nil, errors.New("could not marshal union type ChatGenerationParamsPreferredMaxLatencyUnion: all fields are null")
}

type ChatGenerationParamsProvider struct {
	// Whether to allow backup providers to serve requests
	// - true: (default) when the primary provider (or your custom providers in "order") is unavailable, use the next best provider.
	// - false: use only the primary/custom provider, and return the upstream error if it's unavailable.
	//
	AllowFallbacks optionalnullable.OptionalNullable[bool] `json:"allow_fallbacks,omitzero"`
	// Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest.
	RequireParameters optionalnullable.OptionalNullable[bool] `json:"require_parameters,omitzero"`
	// Data collection setting. If no available model provider meets the requirement, your request will return an error.
	// - allow: (default) allow providers which store user data non-transiently and may train on it
	//
	// - deny: use only providers which do not collect user data.
	DataCollection         optionalnullable.OptionalNullable[ChatGenerationParamsDataCollection] `json:"data_collection,omitzero"`
	Zdr                    optionalnullable.OptionalNullable[bool]                               `json:"zdr,omitzero"`
	EnforceDistillableText optionalnullable.OptionalNullable[bool]                               `json:"enforce_distillable_text,omitzero"`
	// An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message.
	Order optionalnullable.OptionalNullable[[]Schema0] `json:"order,omitzero"`
	// List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request.
	Only optionalnullable.OptionalNullable[[]Schema0] `json:"only,omitzero"`
	// List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request.
	Ignore optionalnullable.OptionalNullable[[]Schema0] `json:"ignore,omitzero"`
	// A list of quantization levels to filter the provider by.
	Quantizations optionalnullable.OptionalNullable[[]Quantizations] `json:"quantizations,omitzero"`
	// The sorting strategy to use for this request, if "order" is not specified. When set, no load balancing is performed.
	Sort optionalnullable.OptionalNullable[ProviderSortUnion] `json:"sort,omitzero"`
	// The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion.
	MaxPrice *ChatGenerationParamsMaxPrice `json:"max_price,omitzero"`
	// Preferred minimum throughput (in tokens per second). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints below the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
	PreferredMinThroughput optionalnullable.OptionalNullable[ChatGenerationParamsPreferredMinThroughputUnion] `json:"preferred_min_throughput,omitzero"`
	// Preferred maximum latency (in seconds). Can be a number (applies to p50) or an object with percentile-specific cutoffs. Endpoints above the threshold(s) may still be used, but are deprioritized in routing. When using fallback models, this may cause a fallback model to be used instead of the primary model if it meets the threshold.
	PreferredMaxLatency optionalnullable.OptionalNullable[ChatGenerationParamsPreferredMaxLatencyUnion] `json:"preferred_max_latency,omitzero"`
}

func (c ChatGenerationParamsProvider) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsProvider) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsProvider) GetAllowFallbacks() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.AllowFallbacks
}

func (c *ChatGenerationParamsProvider) GetRequireParameters() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.RequireParameters
}

func (c *ChatGenerationParamsProvider) GetDataCollection() optionalnullable.OptionalNullable[ChatGenerationParamsDataCollection] {
	if c == nil {
		return nil
	}
	return c.DataCollection
}

func (c *ChatGenerationParamsProvider) GetZdr() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.Zdr
}

func (c *ChatGenerationParamsProvider) GetEnforceDistillableText() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.EnforceDistillableText
}

func (c *ChatGenerationParamsProvider) GetOrder() optionalnullable.OptionalNullable[[]Schema0] {
	if c == nil {
		return nil
	}
	return c.Order
}

func (c *ChatGenerationParamsProvider) GetOnly() optionalnullable.OptionalNullable[[]Schema0] {
	if c == nil {
		return nil
	}
	return c.Only
}

func (c *ChatGenerationParamsProvider) GetIgnore() optionalnullable.OptionalNullable[[]Schema0] {
	if c == nil {
		return nil
	}
	return c.Ignore
}

func (c *ChatGenerationParamsProvider) GetQuantizations() optionalnullable.OptionalNullable[[]Quantizations] {
	if c == nil {
		return nil
	}
	return c.Quantizations
}

func (c *ChatGenerationParamsProvider) GetSort() optionalnullable.OptionalNullable[ProviderSortUnion] {
	if c == nil {
		return nil
	}
	return c.Sort
}

func (c *ChatGenerationParamsProvider) GetMaxPrice() *ChatGenerationParamsMaxPrice {
	if c == nil {
		return nil
	}
	return c.MaxPrice
}

func (c *ChatGenerationParamsProvider) GetPreferredMinThroughput() optionalnullable.OptionalNullable[ChatGenerationParamsPreferredMinThroughputUnion] {
	if c == nil {
		return nil
	}
	return c.PreferredMinThroughput
}

func (c *ChatGenerationParamsProvider) GetPreferredMaxLatency() optionalnullable.OptionalNullable[ChatGenerationParamsPreferredMaxLatencyUnion] {
	if c == nil {
		return nil
	}
	return c.PreferredMaxLatency
}

type ChatGenerationParamsPluginResponseHealing struct {
	id      string `const:"response-healing" json:"id"`
	Enabled *bool  `json:"enabled,omitzero"`
}

func (c ChatGenerationParamsPluginResponseHealing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPluginResponseHealing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPluginResponseHealing) GetID() string {
	return "response-healing"
}

func (c *ChatGenerationParamsPluginResponseHealing) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

type PdfEngine string

const (
	PdfEngineMistralOcr PdfEngine = "mistral-ocr"
	PdfEnginePdfText    PdfEngine = "pdf-text"
	PdfEngineNative     PdfEngine = "native"
)

func (e PdfEngine) ToPointer() *PdfEngine {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *PdfEngine) IsExact() bool {
	if e != nil {
		switch *e {
		case "mistral-ocr", "pdf-text", "native":
			return true
		}
	}
	return false
}

type Pdf struct {
	Engine *PdfEngine `json:"engine,omitzero"`
}

func (p Pdf) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Pdf) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *Pdf) GetEngine() *PdfEngine {
	if p == nil {
		return nil
	}
	return p.Engine
}

type ChatGenerationParamsPluginFileParser struct {
	id      string `const:"file-parser" json:"id"`
	Enabled *bool  `json:"enabled,omitzero"`
	Pdf     *Pdf   `json:"pdf,omitzero"`
}

func (c ChatGenerationParamsPluginFileParser) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPluginFileParser) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPluginFileParser) GetID() string {
	return "file-parser"
}

func (c *ChatGenerationParamsPluginFileParser) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ChatGenerationParamsPluginFileParser) GetPdf() *Pdf {
	if c == nil {
		return nil
	}
	return c.Pdf
}

type Engine string

const (
	EngineNative Engine = "native"
	EngineExa    Engine = "exa"
)

func (e Engine) ToPointer() *Engine {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Engine) IsExact() bool {
	if e != nil {
		switch *e {
		case "native", "exa":
			return true
		}
	}
	return false
}

type ChatGenerationParamsPluginWeb struct {
	id           string   `const:"web" json:"id"`
	Enabled      *bool    `json:"enabled,omitzero"`
	MaxResults   *float64 `json:"max_results,omitzero"`
	SearchPrompt *string  `json:"search_prompt,omitzero"`
	Engine       *Engine  `json:"engine,omitzero"`
}

func (c ChatGenerationParamsPluginWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPluginWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPluginWeb) GetID() string {
	return "web"
}

func (c *ChatGenerationParamsPluginWeb) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ChatGenerationParamsPluginWeb) GetMaxResults() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxResults
}

func (c *ChatGenerationParamsPluginWeb) GetSearchPrompt() *string {
	if c == nil {
		return nil
	}
	return c.SearchPrompt
}

func (c *ChatGenerationParamsPluginWeb) GetEngine() *Engine {
	if c == nil {
		return nil
	}
	return c.Engine
}

type ChatGenerationParamsPluginModeration struct {
	id string `const:"moderation" json:"id"`
}

func (c ChatGenerationParamsPluginModeration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPluginModeration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPluginModeration) GetID() string {
	return "moderation"
}

type ChatGenerationParamsPluginAutoRouter struct {
	id            string   `const:"auto-router" json:"id"`
	Enabled       *bool    `json:"enabled,omitzero"`
	AllowedModels []string `json:"allowed_models,omitzero"`
}

func (c ChatGenerationParamsPluginAutoRouter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsPluginAutoRouter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsPluginAutoRouter) GetID() string {
	return "auto-router"
}

func (c *ChatGenerationParamsPluginAutoRouter) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ChatGenerationParamsPluginAutoRouter) GetAllowedModels() []string {
	if c == nil {
		return nil
	}
	return c.AllowedModels
}

type ChatGenerationParamsPluginUnionType string

const (
	ChatGenerationParamsPluginUnionTypeAutoRouter      ChatGenerationParamsPluginUnionType = "auto-router"
	ChatGenerationParamsPluginUnionTypeModeration      ChatGenerationParamsPluginUnionType = "moderation"
	ChatGenerationParamsPluginUnionTypeWeb             ChatGenerationParamsPluginUnionType = "web"
	ChatGenerationParamsPluginUnionTypeFileParser      ChatGenerationParamsPluginUnionType = "file-parser"
	ChatGenerationParamsPluginUnionTypeResponseHealing ChatGenerationParamsPluginUnionType = "response-healing"
)

type ChatGenerationParamsPluginUnion struct {
	ChatGenerationParamsPluginAutoRouter      *ChatGenerationParamsPluginAutoRouter      `queryParam:"inline" union:"member"`
	ChatGenerationParamsPluginModeration      *ChatGenerationParamsPluginModeration      `queryParam:"inline" union:"member"`
	ChatGenerationParamsPluginWeb             *ChatGenerationParamsPluginWeb             `queryParam:"inline" union:"member"`
	ChatGenerationParamsPluginFileParser      *ChatGenerationParamsPluginFileParser      `queryParam:"inline" union:"member"`
	ChatGenerationParamsPluginResponseHealing *ChatGenerationParamsPluginResponseHealing `queryParam:"inline" union:"member"`

	Type ChatGenerationParamsPluginUnionType
}

func CreateChatGenerationParamsPluginUnionAutoRouter(autoRouter ChatGenerationParamsPluginAutoRouter) ChatGenerationParamsPluginUnion {
	typ := ChatGenerationParamsPluginUnionTypeAutoRouter

	return ChatGenerationParamsPluginUnion{
		ChatGenerationParamsPluginAutoRouter: &autoRouter,
		Type:                                 typ,
	}
}

func CreateChatGenerationParamsPluginUnionModeration(moderation ChatGenerationParamsPluginModeration) ChatGenerationParamsPluginUnion {
	typ := ChatGenerationParamsPluginUnionTypeModeration

	return ChatGenerationParamsPluginUnion{
		ChatGenerationParamsPluginModeration: &moderation,
		Type:                                 typ,
	}
}

func CreateChatGenerationParamsPluginUnionWeb(web ChatGenerationParamsPluginWeb) ChatGenerationParamsPluginUnion {
	typ := ChatGenerationParamsPluginUnionTypeWeb

	return ChatGenerationParamsPluginUnion{
		ChatGenerationParamsPluginWeb: &web,
		Type:                          typ,
	}
}

func CreateChatGenerationParamsPluginUnionFileParser(fileParser ChatGenerationParamsPluginFileParser) ChatGenerationParamsPluginUnion {
	typ := ChatGenerationParamsPluginUnionTypeFileParser

	return ChatGenerationParamsPluginUnion{
		ChatGenerationParamsPluginFileParser: &fileParser,
		Type:                                 typ,
	}
}

func CreateChatGenerationParamsPluginUnionResponseHealing(responseHealing ChatGenerationParamsPluginResponseHealing) ChatGenerationParamsPluginUnion {
	typ := ChatGenerationParamsPluginUnionTypeResponseHealing

	return ChatGenerationParamsPluginUnion{
		ChatGenerationParamsPluginResponseHealing: &responseHealing,
		Type: typ,
	}
}

func (u *ChatGenerationParamsPluginUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		ID string `json:"id"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.ID {
	case "auto-router":
		chatGenerationParamsPluginAutoRouter := new(ChatGenerationParamsPluginAutoRouter)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsPluginAutoRouter, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == auto-router) type ChatGenerationParamsPluginAutoRouter within ChatGenerationParamsPluginUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsPluginAutoRouter = chatGenerationParamsPluginAutoRouter
		u.Type = ChatGenerationParamsPluginUnionTypeAutoRouter
		return nil
	case "moderation":
		chatGenerationParamsPluginModeration := new(ChatGenerationParamsPluginModeration)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsPluginModeration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == moderation) type ChatGenerationParamsPluginModeration within ChatGenerationParamsPluginUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsPluginModeration = chatGenerationParamsPluginModeration
		u.Type = ChatGenerationParamsPluginUnionTypeModeration
		return nil
	case "web":
		chatGenerationParamsPluginWeb := new(ChatGenerationParamsPluginWeb)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsPluginWeb, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == web) type ChatGenerationParamsPluginWeb within ChatGenerationParamsPluginUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsPluginWeb = chatGenerationParamsPluginWeb
		u.Type = ChatGenerationParamsPluginUnionTypeWeb
		return nil
	case "file-parser":
		chatGenerationParamsPluginFileParser := new(ChatGenerationParamsPluginFileParser)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsPluginFileParser, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == file-parser) type ChatGenerationParamsPluginFileParser within ChatGenerationParamsPluginUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsPluginFileParser = chatGenerationParamsPluginFileParser
		u.Type = ChatGenerationParamsPluginUnionTypeFileParser
		return nil
	case "response-healing":
		chatGenerationParamsPluginResponseHealing := new(ChatGenerationParamsPluginResponseHealing)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsPluginResponseHealing, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ID == response-healing) type ChatGenerationParamsPluginResponseHealing within ChatGenerationParamsPluginUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsPluginResponseHealing = chatGenerationParamsPluginResponseHealing
		u.Type = ChatGenerationParamsPluginUnionTypeResponseHealing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsPluginUnion", string(data))
}

func (u ChatGenerationParamsPluginUnion) MarshalJSON() ([]byte, error) {
	if u.ChatGenerationParamsPluginAutoRouter != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPluginAutoRouter, "", true)
	}

	if u.ChatGenerationParamsPluginModeration != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPluginModeration, "", true)
	}

	if u.ChatGenerationParamsPluginWeb != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPluginWeb, "", true)
	}

	if u.ChatGenerationParamsPluginFileParser != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPluginFileParser, "", true)
	}

	if u.ChatGenerationParamsPluginResponseHealing != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsPluginResponseHealing, "", true)
	}

	return nil, errors.New("could not marshal union type ChatGenerationParamsPluginUnion: all fields are null")
}

type Route string

const (
	RouteFallback Route = "fallback"
	RouteSort     Route = "sort"
)

func (e Route) ToPointer() *Route {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Route) IsExact() bool {
	if e != nil {
		switch *e {
		case "fallback", "sort":
			return true
		}
	}
	return false
}

type Effort string

const (
	EffortXhigh   Effort = "xhigh"
	EffortHigh    Effort = "high"
	EffortMedium  Effort = "medium"
	EffortLow     Effort = "low"
	EffortMinimal Effort = "minimal"
	EffortNone    Effort = "none"
)

func (e Effort) ToPointer() *Effort {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Effort) IsExact() bool {
	if e != nil {
		switch *e {
		case "xhigh", "high", "medium", "low", "minimal", "none":
			return true
		}
	}
	return false
}

type Reasoning struct {
	Effort  optionalnullable.OptionalNullable[Effort]                    `json:"effort,omitzero"`
	Summary optionalnullable.OptionalNullable[ReasoningSummaryVerbosity] `json:"summary,omitzero"`
}

func (r *Reasoning) GetEffort() optionalnullable.OptionalNullable[Effort] {
	if r == nil {
		return nil
	}
	return r.Effort
}

func (r *Reasoning) GetSummary() optionalnullable.OptionalNullable[ReasoningSummaryVerbosity] {
	if r == nil {
		return nil
	}
	return r.Summary
}

type ChatGenerationParamsResponseFormatPython struct {
	type_ string `const:"python" json:"type"`
}

func (c ChatGenerationParamsResponseFormatPython) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsResponseFormatPython) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsResponseFormatPython) GetType() string {
	return "python"
}

type ChatGenerationParamsResponseFormatJSONObject struct {
	type_ string `const:"json_object" json:"type"`
}

func (c ChatGenerationParamsResponseFormatJSONObject) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsResponseFormatJSONObject) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsResponseFormatJSONObject) GetType() string {
	return "json_object"
}

type ChatGenerationParamsResponseFormatText struct {
	type_ string `const:"text" json:"type"`
}

func (c ChatGenerationParamsResponseFormatText) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParamsResponseFormatText) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParamsResponseFormatText) GetType() string {
	return "text"
}

type ChatGenerationParamsResponseFormatUnionType string

const (
	ChatGenerationParamsResponseFormatUnionTypeText       ChatGenerationParamsResponseFormatUnionType = "text"
	ChatGenerationParamsResponseFormatUnionTypeJSONObject ChatGenerationParamsResponseFormatUnionType = "json_object"
	ChatGenerationParamsResponseFormatUnionTypeJSONSchema ChatGenerationParamsResponseFormatUnionType = "json_schema"
	ChatGenerationParamsResponseFormatUnionTypeGrammar    ChatGenerationParamsResponseFormatUnionType = "grammar"
	ChatGenerationParamsResponseFormatUnionTypePython     ChatGenerationParamsResponseFormatUnionType = "python"
)

type ChatGenerationParamsResponseFormatUnion struct {
	ChatGenerationParamsResponseFormatText       *ChatGenerationParamsResponseFormatText       `queryParam:"inline" union:"member"`
	ChatGenerationParamsResponseFormatJSONObject *ChatGenerationParamsResponseFormatJSONObject `queryParam:"inline" union:"member"`
	ResponseFormatJSONSchema                     *ResponseFormatJSONSchema                     `queryParam:"inline" union:"member"`
	ResponseFormatTextGrammar                    *ResponseFormatTextGrammar                    `queryParam:"inline" union:"member"`
	ChatGenerationParamsResponseFormatPython     *ChatGenerationParamsResponseFormatPython     `queryParam:"inline" union:"member"`

	Type ChatGenerationParamsResponseFormatUnionType
}

func CreateChatGenerationParamsResponseFormatUnionText(text ChatGenerationParamsResponseFormatText) ChatGenerationParamsResponseFormatUnion {
	typ := ChatGenerationParamsResponseFormatUnionTypeText

	return ChatGenerationParamsResponseFormatUnion{
		ChatGenerationParamsResponseFormatText: &text,
		Type:                                   typ,
	}
}

func CreateChatGenerationParamsResponseFormatUnionJSONObject(jsonObject ChatGenerationParamsResponseFormatJSONObject) ChatGenerationParamsResponseFormatUnion {
	typ := ChatGenerationParamsResponseFormatUnionTypeJSONObject

	return ChatGenerationParamsResponseFormatUnion{
		ChatGenerationParamsResponseFormatJSONObject: &jsonObject,
		Type: typ,
	}
}

func CreateChatGenerationParamsResponseFormatUnionJSONSchema(jsonSchema ResponseFormatJSONSchema) ChatGenerationParamsResponseFormatUnion {
	typ := ChatGenerationParamsResponseFormatUnionTypeJSONSchema

	return ChatGenerationParamsResponseFormatUnion{
		ResponseFormatJSONSchema: &jsonSchema,
		Type:                     typ,
	}
}

func CreateChatGenerationParamsResponseFormatUnionGrammar(grammar ResponseFormatTextGrammar) ChatGenerationParamsResponseFormatUnion {
	typ := ChatGenerationParamsResponseFormatUnionTypeGrammar

	return ChatGenerationParamsResponseFormatUnion{
		ResponseFormatTextGrammar: &grammar,
		Type:                      typ,
	}
}

func CreateChatGenerationParamsResponseFormatUnionPython(python ChatGenerationParamsResponseFormatPython) ChatGenerationParamsResponseFormatUnion {
	typ := ChatGenerationParamsResponseFormatUnionTypePython

	return ChatGenerationParamsResponseFormatUnion{
		ChatGenerationParamsResponseFormatPython: &python,
		Type:                                     typ,
	}
}

func (u *ChatGenerationParamsResponseFormatUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "text":
		chatGenerationParamsResponseFormatText := new(ChatGenerationParamsResponseFormatText)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsResponseFormatText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == text) type ChatGenerationParamsResponseFormatText within ChatGenerationParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsResponseFormatText = chatGenerationParamsResponseFormatText
		u.Type = ChatGenerationParamsResponseFormatUnionTypeText
		return nil
	case "json_object":
		chatGenerationParamsResponseFormatJSONObject := new(ChatGenerationParamsResponseFormatJSONObject)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsResponseFormatJSONObject, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == json_object) type ChatGenerationParamsResponseFormatJSONObject within ChatGenerationParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsResponseFormatJSONObject = chatGenerationParamsResponseFormatJSONObject
		u.Type = ChatGenerationParamsResponseFormatUnionTypeJSONObject
		return nil
	case "json_schema":
		responseFormatJSONSchema := new(ResponseFormatJSONSchema)
		if err := utils.UnmarshalJSON(data, &responseFormatJSONSchema, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == json_schema) type ResponseFormatJSONSchema within ChatGenerationParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ResponseFormatJSONSchema = responseFormatJSONSchema
		u.Type = ChatGenerationParamsResponseFormatUnionTypeJSONSchema
		return nil
	case "grammar":
		responseFormatTextGrammar := new(ResponseFormatTextGrammar)
		if err := utils.UnmarshalJSON(data, &responseFormatTextGrammar, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == grammar) type ResponseFormatTextGrammar within ChatGenerationParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ResponseFormatTextGrammar = responseFormatTextGrammar
		u.Type = ChatGenerationParamsResponseFormatUnionTypeGrammar
		return nil
	case "python":
		chatGenerationParamsResponseFormatPython := new(ChatGenerationParamsResponseFormatPython)
		if err := utils.UnmarshalJSON(data, &chatGenerationParamsResponseFormatPython, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == python) type ChatGenerationParamsResponseFormatPython within ChatGenerationParamsResponseFormatUnion: %w", string(data), err)
		}

		u.ChatGenerationParamsResponseFormatPython = chatGenerationParamsResponseFormatPython
		u.Type = ChatGenerationParamsResponseFormatUnionTypePython
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsResponseFormatUnion", string(data))
}

func (u ChatGenerationParamsResponseFormatUnion) MarshalJSON() ([]byte, error) {
	if u.ChatGenerationParamsResponseFormatText != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsResponseFormatText, "", true)
	}

	if u.ChatGenerationParamsResponseFormatJSONObject != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsResponseFormatJSONObject, "", true)
	}

	if u.ResponseFormatJSONSchema != nil {
		return utils.MarshalJSON(u.ResponseFormatJSONSchema, "", true)
	}

	if u.ResponseFormatTextGrammar != nil {
		return utils.MarshalJSON(u.ResponseFormatTextGrammar, "", true)
	}

	if u.ChatGenerationParamsResponseFormatPython != nil {
		return utils.MarshalJSON(u.ChatGenerationParamsResponseFormatPython, "", true)
	}

	return nil, errors.New("could not marshal union type ChatGenerationParamsResponseFormatUnion: all fields are null")
}

type ChatGenerationParamsStopType string

const (
	ChatGenerationParamsStopTypeStr        ChatGenerationParamsStopType = "str"
	ChatGenerationParamsStopTypeArrayOfStr ChatGenerationParamsStopType = "arrayOfStr"
)

type ChatGenerationParamsStop struct {
	Str        *string  `queryParam:"inline" union:"member"`
	ArrayOfStr []string `queryParam:"inline" union:"member"`

	Type ChatGenerationParamsStopType
}

func CreateChatGenerationParamsStopStr(str string) ChatGenerationParamsStop {
	typ := ChatGenerationParamsStopTypeStr

	return ChatGenerationParamsStop{
		Str:  &str,
		Type: typ,
	}
}

func CreateChatGenerationParamsStopArrayOfStr(arrayOfStr []string) ChatGenerationParamsStop {
	typ := ChatGenerationParamsStopTypeArrayOfStr

	return ChatGenerationParamsStop{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *ChatGenerationParamsStop) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsStopTypeStr,
			Value: &str,
		})
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsStopTypeArrayOfStr,
			Value: arrayOfStr,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsStop", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsStop", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ChatGenerationParamsStopType)
	switch best.Type {
	case ChatGenerationParamsStopTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ChatGenerationParamsStopTypeArrayOfStr:
		u.ArrayOfStr = best.Value.([]string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsStop", string(data))
}

func (u ChatGenerationParamsStop) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type ChatGenerationParamsStop: all fields are null")
}

type Debug struct {
	EchoUpstreamBody *bool `json:"echo_upstream_body,omitzero"`
}

func (d *Debug) GetEchoUpstreamBody() *bool {
	if d == nil {
		return nil
	}
	return d.EchoUpstreamBody
}

type ChatGenerationParamsImageConfigType string

const (
	ChatGenerationParamsImageConfigTypeStr    ChatGenerationParamsImageConfigType = "str"
	ChatGenerationParamsImageConfigTypeNumber ChatGenerationParamsImageConfigType = "number"
)

type ChatGenerationParamsImageConfig struct {
	Str    *string  `queryParam:"inline" union:"member"`
	Number *float64 `queryParam:"inline" union:"member"`

	Type ChatGenerationParamsImageConfigType
}

func CreateChatGenerationParamsImageConfigStr(str string) ChatGenerationParamsImageConfig {
	typ := ChatGenerationParamsImageConfigTypeStr

	return ChatGenerationParamsImageConfig{
		Str:  &str,
		Type: typ,
	}
}

func CreateChatGenerationParamsImageConfigNumber(number float64) ChatGenerationParamsImageConfig {
	typ := ChatGenerationParamsImageConfigTypeNumber

	return ChatGenerationParamsImageConfig{
		Number: &number,
		Type:   typ,
	}
}

func (u *ChatGenerationParamsImageConfig) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsImageConfigTypeStr,
			Value: &str,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ChatGenerationParamsImageConfigTypeNumber,
			Value: &number,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsImageConfig", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsImageConfig", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ChatGenerationParamsImageConfigType)
	switch best.Type {
	case ChatGenerationParamsImageConfigTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ChatGenerationParamsImageConfigTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ChatGenerationParamsImageConfig", string(data))
}

func (u ChatGenerationParamsImageConfig) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type ChatGenerationParamsImageConfig: all fields are null")
}

type Modality string

const (
	ModalityText  Modality = "text"
	ModalityImage Modality = "image"
)

func (e Modality) ToPointer() *Modality {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *Modality) IsExact() bool {
	if e != nil {
		switch *e {
		case "text", "image":
			return true
		}
	}
	return false
}

type ChatGenerationParams struct {
	// When multiple model providers are available, optionally indicate your routing preference.
	Provider optionalnullable.OptionalNullable[ChatGenerationParamsProvider] `json:"provider,omitzero"`
	// Plugins you want to enable for this request, including their settings.
	Plugins []ChatGenerationParamsPluginUnion        `json:"plugins,omitzero"`
	Route   optionalnullable.OptionalNullable[Route] `json:"route,omitzero"`
	User    *string                                  `json:"user,omitzero"`
	// A unique identifier for grouping related requests (e.g., a conversation or agent workflow) for observability. If provided in both the request body and the x-session-id header, the body value takes precedence. Maximum of 128 characters.
	SessionID           *string                                                     `json:"session_id,omitzero"`
	Messages            []Message                                                   `json:"messages"`
	Model               *string                                                     `json:"model,omitzero"`
	Models              []string                                                    `json:"models,omitzero"`
	FrequencyPenalty    optionalnullable.OptionalNullable[float64]                  `json:"frequency_penalty,omitzero"`
	LogitBias           optionalnullable.OptionalNullable[map[string]float64]       `json:"logit_bias,omitzero"`
	Logprobs            optionalnullable.OptionalNullable[bool]                     `json:"logprobs,omitzero"`
	TopLogprobs         optionalnullable.OptionalNullable[float64]                  `json:"top_logprobs,omitzero"`
	MaxCompletionTokens optionalnullable.OptionalNullable[float64]                  `json:"max_completion_tokens,omitzero"`
	MaxTokens           optionalnullable.OptionalNullable[float64]                  `json:"max_tokens,omitzero"`
	Metadata            map[string]string                                           `json:"metadata,omitzero"`
	PresencePenalty     optionalnullable.OptionalNullable[float64]                  `json:"presence_penalty,omitzero"`
	Reasoning           *Reasoning                                                  `json:"reasoning,omitzero"`
	ResponseFormat      *ChatGenerationParamsResponseFormatUnion                    `json:"response_format,omitzero"`
	Seed                optionalnullable.OptionalNullable[int64]                    `json:"seed,omitzero"`
	Stop                optionalnullable.OptionalNullable[ChatGenerationParamsStop] `json:"stop,omitzero"`
	Stream              *bool                                                       `default:"false" json:"stream"`
	StreamOptions       optionalnullable.OptionalNullable[ChatStreamOptions]        `json:"stream_options,omitzero"`
	Temperature         optionalnullable.OptionalNullable[float64]                  `json:"temperature,omitzero"`
	ToolChoice          any                                                         `json:"tool_choice,omitzero"`
	Tools               []ToolDefinitionJSON                                        `json:"tools,omitzero"`
	TopP                optionalnullable.OptionalNullable[float64]                  `json:"top_p,omitzero"`
	Debug               *Debug                                                      `json:"debug,omitzero"`
	ImageConfig         map[string]ChatGenerationParamsImageConfig                  `json:"image_config,omitzero"`
	Modalities          []Modality                                                  `json:"modalities,omitzero"`
}

func (c ChatGenerationParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChatGenerationParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChatGenerationParams) GetProvider() optionalnullable.OptionalNullable[ChatGenerationParamsProvider] {
	if c == nil {
		return nil
	}
	return c.Provider
}

func (c *ChatGenerationParams) GetPlugins() []ChatGenerationParamsPluginUnion {
	if c == nil {
		return nil
	}
	return c.Plugins
}

func (c *ChatGenerationParams) GetRoute() optionalnullable.OptionalNullable[Route] {
	if c == nil {
		return nil
	}
	return c.Route
}

func (c *ChatGenerationParams) GetUser() *string {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *ChatGenerationParams) GetSessionID() *string {
	if c == nil {
		return nil
	}
	return c.SessionID
}

func (c *ChatGenerationParams) GetMessages() []Message {
	if c == nil {
		return []Message{}
	}
	return c.Messages
}

func (c *ChatGenerationParams) GetModel() *string {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *ChatGenerationParams) GetModels() []string {
	if c == nil {
		return nil
	}
	return c.Models
}

func (c *ChatGenerationParams) GetFrequencyPenalty() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.FrequencyPenalty
}

func (c *ChatGenerationParams) GetLogitBias() optionalnullable.OptionalNullable[map[string]float64] {
	if c == nil {
		return nil
	}
	return c.LogitBias
}

func (c *ChatGenerationParams) GetLogprobs() optionalnullable.OptionalNullable[bool] {
	if c == nil {
		return nil
	}
	return c.Logprobs
}

func (c *ChatGenerationParams) GetTopLogprobs() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.TopLogprobs
}

func (c *ChatGenerationParams) GetMaxCompletionTokens() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.MaxCompletionTokens
}

func (c *ChatGenerationParams) GetMaxTokens() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.MaxTokens
}

func (c *ChatGenerationParams) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ChatGenerationParams) GetPresencePenalty() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.PresencePenalty
}

func (c *ChatGenerationParams) GetReasoning() *Reasoning {
	if c == nil {
		return nil
	}
	return c.Reasoning
}

func (c *ChatGenerationParams) GetResponseFormat() *ChatGenerationParamsResponseFormatUnion {
	if c == nil {
		return nil
	}
	return c.ResponseFormat
}

func (c *ChatGenerationParams) GetResponseFormatText() *ChatGenerationParamsResponseFormatText {
	if v := c.GetResponseFormat(); v != nil {
		return v.ChatGenerationParamsResponseFormatText
	}
	return nil
}

func (c *ChatGenerationParams) GetResponseFormatJSONObject() *ChatGenerationParamsResponseFormatJSONObject {
	if v := c.GetResponseFormat(); v != nil {
		return v.ChatGenerationParamsResponseFormatJSONObject
	}
	return nil
}

func (c *ChatGenerationParams) GetResponseFormatJSONSchema() *ResponseFormatJSONSchema {
	if v := c.GetResponseFormat(); v != nil {
		return v.ResponseFormatJSONSchema
	}
	return nil
}

func (c *ChatGenerationParams) GetResponseFormatGrammar() *ResponseFormatTextGrammar {
	if v := c.GetResponseFormat(); v != nil {
		return v.ResponseFormatTextGrammar
	}
	return nil
}

func (c *ChatGenerationParams) GetResponseFormatPython() *ChatGenerationParamsResponseFormatPython {
	if v := c.GetResponseFormat(); v != nil {
		return v.ChatGenerationParamsResponseFormatPython
	}
	return nil
}

func (c *ChatGenerationParams) GetSeed() optionalnullable.OptionalNullable[int64] {
	if c == nil {
		return nil
	}
	return c.Seed
}

func (c *ChatGenerationParams) GetStop() optionalnullable.OptionalNullable[ChatGenerationParamsStop] {
	if c == nil {
		return nil
	}
	return c.Stop
}

func (c *ChatGenerationParams) GetStream() *bool {
	if c == nil {
		return nil
	}
	return c.Stream
}

func (c *ChatGenerationParams) GetStreamOptions() optionalnullable.OptionalNullable[ChatStreamOptions] {
	if c == nil {
		return nil
	}
	return c.StreamOptions
}

func (c *ChatGenerationParams) GetTemperature() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.Temperature
}

func (c *ChatGenerationParams) GetToolChoice() any {
	if c == nil {
		return nil
	}
	return c.ToolChoice
}

func (c *ChatGenerationParams) GetTools() []ToolDefinitionJSON {
	if c == nil {
		return nil
	}
	return c.Tools
}

func (c *ChatGenerationParams) GetTopP() optionalnullable.OptionalNullable[float64] {
	if c == nil {
		return nil
	}
	return c.TopP
}

func (c *ChatGenerationParams) GetDebug() *Debug {
	if c == nil {
		return nil
	}
	return c.Debug
}

func (c *ChatGenerationParams) GetImageConfig() map[string]ChatGenerationParamsImageConfig {
	if c == nil {
		return nil
	}
	return c.ImageConfig
}

func (c *ChatGenerationParams) GetModalities() []Modality {
	if c == nil {
		return nil
	}
	return c.Modalities
}
