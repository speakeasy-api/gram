// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
)

type OpenResponsesInput1Type string

const (
	OpenResponsesInput1TypeOpenResponsesReasoning            OpenResponsesInput1Type = "OpenResponsesReasoning"
	OpenResponsesInput1TypeOpenResponsesEasyInputMessage     OpenResponsesInput1Type = "OpenResponsesEasyInputMessage"
	OpenResponsesInput1TypeOpenResponsesInputMessageItem     OpenResponsesInput1Type = "OpenResponsesInputMessageItem"
	OpenResponsesInput1TypeOpenResponsesFunctionToolCall     OpenResponsesInput1Type = "OpenResponsesFunctionToolCall"
	OpenResponsesInput1TypeOpenResponsesFunctionCallOutput   OpenResponsesInput1Type = "OpenResponsesFunctionCallOutput"
	OpenResponsesInput1TypeResponsesOutputMessage            OpenResponsesInput1Type = "ResponsesOutputMessage"
	OpenResponsesInput1TypeResponsesOutputItemReasoning      OpenResponsesInput1Type = "ResponsesOutputItemReasoning"
	OpenResponsesInput1TypeResponsesOutputItemFunctionCall   OpenResponsesInput1Type = "ResponsesOutputItemFunctionCall"
	OpenResponsesInput1TypeResponsesWebSearchCallOutput      OpenResponsesInput1Type = "ResponsesWebSearchCallOutput"
	OpenResponsesInput1TypeResponsesOutputItemFileSearchCall OpenResponsesInput1Type = "ResponsesOutputItemFileSearchCall"
	OpenResponsesInput1TypeResponsesImageGenerationCall      OpenResponsesInput1Type = "ResponsesImageGenerationCall"
)

type OpenResponsesInput1 struct {
	OpenResponsesReasoning            *OpenResponsesReasoning            `queryParam:"inline" union:"member"`
	OpenResponsesEasyInputMessage     *OpenResponsesEasyInputMessage     `queryParam:"inline" union:"member"`
	OpenResponsesInputMessageItem     *OpenResponsesInputMessageItem     `queryParam:"inline" union:"member"`
	OpenResponsesFunctionToolCall     *OpenResponsesFunctionToolCall     `queryParam:"inline" union:"member"`
	OpenResponsesFunctionCallOutput   *OpenResponsesFunctionCallOutput   `queryParam:"inline" union:"member"`
	ResponsesOutputMessage            *ResponsesOutputMessage            `queryParam:"inline" union:"member"`
	ResponsesOutputItemReasoning      *ResponsesOutputItemReasoning      `queryParam:"inline" union:"member"`
	ResponsesOutputItemFunctionCall   *ResponsesOutputItemFunctionCall   `queryParam:"inline" union:"member"`
	ResponsesWebSearchCallOutput      *ResponsesWebSearchCallOutput      `queryParam:"inline" union:"member"`
	ResponsesOutputItemFileSearchCall *ResponsesOutputItemFileSearchCall `queryParam:"inline" union:"member"`
	ResponsesImageGenerationCall      *ResponsesImageGenerationCall      `queryParam:"inline" union:"member"`

	Type OpenResponsesInput1Type
}

func CreateOpenResponsesInput1OpenResponsesReasoning(openResponsesReasoning OpenResponsesReasoning) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeOpenResponsesReasoning

	return OpenResponsesInput1{
		OpenResponsesReasoning: &openResponsesReasoning,
		Type:                   typ,
	}
}

func CreateOpenResponsesInput1OpenResponsesEasyInputMessage(openResponsesEasyInputMessage OpenResponsesEasyInputMessage) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeOpenResponsesEasyInputMessage

	return OpenResponsesInput1{
		OpenResponsesEasyInputMessage: &openResponsesEasyInputMessage,
		Type:                          typ,
	}
}

func CreateOpenResponsesInput1OpenResponsesInputMessageItem(openResponsesInputMessageItem OpenResponsesInputMessageItem) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeOpenResponsesInputMessageItem

	return OpenResponsesInput1{
		OpenResponsesInputMessageItem: &openResponsesInputMessageItem,
		Type:                          typ,
	}
}

func CreateOpenResponsesInput1OpenResponsesFunctionToolCall(openResponsesFunctionToolCall OpenResponsesFunctionToolCall) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeOpenResponsesFunctionToolCall

	return OpenResponsesInput1{
		OpenResponsesFunctionToolCall: &openResponsesFunctionToolCall,
		Type:                          typ,
	}
}

func CreateOpenResponsesInput1OpenResponsesFunctionCallOutput(openResponsesFunctionCallOutput OpenResponsesFunctionCallOutput) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeOpenResponsesFunctionCallOutput

	return OpenResponsesInput1{
		OpenResponsesFunctionCallOutput: &openResponsesFunctionCallOutput,
		Type:                            typ,
	}
}

func CreateOpenResponsesInput1ResponsesOutputMessage(responsesOutputMessage ResponsesOutputMessage) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeResponsesOutputMessage

	return OpenResponsesInput1{
		ResponsesOutputMessage: &responsesOutputMessage,
		Type:                   typ,
	}
}

func CreateOpenResponsesInput1ResponsesOutputItemReasoning(responsesOutputItemReasoning ResponsesOutputItemReasoning) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeResponsesOutputItemReasoning

	return OpenResponsesInput1{
		ResponsesOutputItemReasoning: &responsesOutputItemReasoning,
		Type:                         typ,
	}
}

func CreateOpenResponsesInput1ResponsesOutputItemFunctionCall(responsesOutputItemFunctionCall ResponsesOutputItemFunctionCall) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeResponsesOutputItemFunctionCall

	return OpenResponsesInput1{
		ResponsesOutputItemFunctionCall: &responsesOutputItemFunctionCall,
		Type:                            typ,
	}
}

func CreateOpenResponsesInput1ResponsesWebSearchCallOutput(responsesWebSearchCallOutput ResponsesWebSearchCallOutput) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeResponsesWebSearchCallOutput

	return OpenResponsesInput1{
		ResponsesWebSearchCallOutput: &responsesWebSearchCallOutput,
		Type:                         typ,
	}
}

func CreateOpenResponsesInput1ResponsesOutputItemFileSearchCall(responsesOutputItemFileSearchCall ResponsesOutputItemFileSearchCall) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeResponsesOutputItemFileSearchCall

	return OpenResponsesInput1{
		ResponsesOutputItemFileSearchCall: &responsesOutputItemFileSearchCall,
		Type:                              typ,
	}
}

func CreateOpenResponsesInput1ResponsesImageGenerationCall(responsesImageGenerationCall ResponsesImageGenerationCall) OpenResponsesInput1 {
	typ := OpenResponsesInput1TypeResponsesImageGenerationCall

	return OpenResponsesInput1{
		ResponsesImageGenerationCall: &responsesImageGenerationCall,
		Type:                         typ,
	}
}

func (u *OpenResponsesInput1) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openResponsesReasoning OpenResponsesReasoning = OpenResponsesReasoning{}
	if err := utils.UnmarshalJSON(data, &openResponsesReasoning, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeOpenResponsesReasoning,
			Value: &openResponsesReasoning,
		})
	}

	var openResponsesEasyInputMessage OpenResponsesEasyInputMessage = OpenResponsesEasyInputMessage{}
	if err := utils.UnmarshalJSON(data, &openResponsesEasyInputMessage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeOpenResponsesEasyInputMessage,
			Value: &openResponsesEasyInputMessage,
		})
	}

	var openResponsesInputMessageItem OpenResponsesInputMessageItem = OpenResponsesInputMessageItem{}
	if err := utils.UnmarshalJSON(data, &openResponsesInputMessageItem, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeOpenResponsesInputMessageItem,
			Value: &openResponsesInputMessageItem,
		})
	}

	var openResponsesFunctionToolCall OpenResponsesFunctionToolCall = OpenResponsesFunctionToolCall{}
	if err := utils.UnmarshalJSON(data, &openResponsesFunctionToolCall, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeOpenResponsesFunctionToolCall,
			Value: &openResponsesFunctionToolCall,
		})
	}

	var openResponsesFunctionCallOutput OpenResponsesFunctionCallOutput = OpenResponsesFunctionCallOutput{}
	if err := utils.UnmarshalJSON(data, &openResponsesFunctionCallOutput, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeOpenResponsesFunctionCallOutput,
			Value: &openResponsesFunctionCallOutput,
		})
	}

	var responsesOutputMessage ResponsesOutputMessage = ResponsesOutputMessage{}
	if err := utils.UnmarshalJSON(data, &responsesOutputMessage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeResponsesOutputMessage,
			Value: &responsesOutputMessage,
		})
	}

	var responsesOutputItemReasoning ResponsesOutputItemReasoning = ResponsesOutputItemReasoning{}
	if err := utils.UnmarshalJSON(data, &responsesOutputItemReasoning, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeResponsesOutputItemReasoning,
			Value: &responsesOutputItemReasoning,
		})
	}

	var responsesOutputItemFunctionCall ResponsesOutputItemFunctionCall = ResponsesOutputItemFunctionCall{}
	if err := utils.UnmarshalJSON(data, &responsesOutputItemFunctionCall, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeResponsesOutputItemFunctionCall,
			Value: &responsesOutputItemFunctionCall,
		})
	}

	var responsesWebSearchCallOutput ResponsesWebSearchCallOutput = ResponsesWebSearchCallOutput{}
	if err := utils.UnmarshalJSON(data, &responsesWebSearchCallOutput, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeResponsesWebSearchCallOutput,
			Value: &responsesWebSearchCallOutput,
		})
	}

	var responsesOutputItemFileSearchCall ResponsesOutputItemFileSearchCall = ResponsesOutputItemFileSearchCall{}
	if err := utils.UnmarshalJSON(data, &responsesOutputItemFileSearchCall, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeResponsesOutputItemFileSearchCall,
			Value: &responsesOutputItemFileSearchCall,
		})
	}

	var responsesImageGenerationCall ResponsesImageGenerationCall = ResponsesImageGenerationCall{}
	if err := utils.UnmarshalJSON(data, &responsesImageGenerationCall, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInput1TypeResponsesImageGenerationCall,
			Value: &responsesImageGenerationCall,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInput1", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInput1", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesInput1Type)
	switch best.Type {
	case OpenResponsesInput1TypeOpenResponsesReasoning:
		u.OpenResponsesReasoning = best.Value.(*OpenResponsesReasoning)
		return nil
	case OpenResponsesInput1TypeOpenResponsesEasyInputMessage:
		u.OpenResponsesEasyInputMessage = best.Value.(*OpenResponsesEasyInputMessage)
		return nil
	case OpenResponsesInput1TypeOpenResponsesInputMessageItem:
		u.OpenResponsesInputMessageItem = best.Value.(*OpenResponsesInputMessageItem)
		return nil
	case OpenResponsesInput1TypeOpenResponsesFunctionToolCall:
		u.OpenResponsesFunctionToolCall = best.Value.(*OpenResponsesFunctionToolCall)
		return nil
	case OpenResponsesInput1TypeOpenResponsesFunctionCallOutput:
		u.OpenResponsesFunctionCallOutput = best.Value.(*OpenResponsesFunctionCallOutput)
		return nil
	case OpenResponsesInput1TypeResponsesOutputMessage:
		u.ResponsesOutputMessage = best.Value.(*ResponsesOutputMessage)
		return nil
	case OpenResponsesInput1TypeResponsesOutputItemReasoning:
		u.ResponsesOutputItemReasoning = best.Value.(*ResponsesOutputItemReasoning)
		return nil
	case OpenResponsesInput1TypeResponsesOutputItemFunctionCall:
		u.ResponsesOutputItemFunctionCall = best.Value.(*ResponsesOutputItemFunctionCall)
		return nil
	case OpenResponsesInput1TypeResponsesWebSearchCallOutput:
		u.ResponsesWebSearchCallOutput = best.Value.(*ResponsesWebSearchCallOutput)
		return nil
	case OpenResponsesInput1TypeResponsesOutputItemFileSearchCall:
		u.ResponsesOutputItemFileSearchCall = best.Value.(*ResponsesOutputItemFileSearchCall)
		return nil
	case OpenResponsesInput1TypeResponsesImageGenerationCall:
		u.ResponsesImageGenerationCall = best.Value.(*ResponsesImageGenerationCall)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInput1", string(data))
}

func (u OpenResponsesInput1) MarshalJSON() ([]byte, error) {
	if u.OpenResponsesReasoning != nil {
		return utils.MarshalJSON(u.OpenResponsesReasoning, "", true)
	}

	if u.OpenResponsesEasyInputMessage != nil {
		return utils.MarshalJSON(u.OpenResponsesEasyInputMessage, "", true)
	}

	if u.OpenResponsesInputMessageItem != nil {
		return utils.MarshalJSON(u.OpenResponsesInputMessageItem, "", true)
	}

	if u.OpenResponsesFunctionToolCall != nil {
		return utils.MarshalJSON(u.OpenResponsesFunctionToolCall, "", true)
	}

	if u.OpenResponsesFunctionCallOutput != nil {
		return utils.MarshalJSON(u.OpenResponsesFunctionCallOutput, "", true)
	}

	if u.ResponsesOutputMessage != nil {
		return utils.MarshalJSON(u.ResponsesOutputMessage, "", true)
	}

	if u.ResponsesOutputItemReasoning != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemReasoning, "", true)
	}

	if u.ResponsesOutputItemFunctionCall != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemFunctionCall, "", true)
	}

	if u.ResponsesWebSearchCallOutput != nil {
		return utils.MarshalJSON(u.ResponsesWebSearchCallOutput, "", true)
	}

	if u.ResponsesOutputItemFileSearchCall != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemFileSearchCall, "", true)
	}

	if u.ResponsesImageGenerationCall != nil {
		return utils.MarshalJSON(u.ResponsesImageGenerationCall, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesInput1: all fields are null")
}

type OpenResponsesInputType string

const (
	OpenResponsesInputTypeStr                        OpenResponsesInputType = "str"
	OpenResponsesInputTypeArrayOfOpenResponsesInput1 OpenResponsesInputType = "arrayOfOpenResponsesInput1"
)

// OpenResponsesInput - Input for a response request - can be a string or array of items
type OpenResponsesInput struct {
	Str                        *string               `queryParam:"inline" union:"member"`
	ArrayOfOpenResponsesInput1 []OpenResponsesInput1 `queryParam:"inline" union:"member"`

	Type OpenResponsesInputType
}

func CreateOpenResponsesInputStr(str string) OpenResponsesInput {
	typ := OpenResponsesInputTypeStr

	return OpenResponsesInput{
		Str:  &str,
		Type: typ,
	}
}

func CreateOpenResponsesInputArrayOfOpenResponsesInput1(arrayOfOpenResponsesInput1 []OpenResponsesInput1) OpenResponsesInput {
	typ := OpenResponsesInputTypeArrayOfOpenResponsesInput1

	return OpenResponsesInput{
		ArrayOfOpenResponsesInput1: arrayOfOpenResponsesInput1,
		Type:                       typ,
	}
}

func (u *OpenResponsesInput) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInputTypeStr,
			Value: &str,
		})
	}

	var arrayOfOpenResponsesInput1 []OpenResponsesInput1 = []OpenResponsesInput1{}
	if err := utils.UnmarshalJSON(data, &arrayOfOpenResponsesInput1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInputTypeArrayOfOpenResponsesInput1,
			Value: arrayOfOpenResponsesInput1,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInput", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInput", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesInputType)
	switch best.Type {
	case OpenResponsesInputTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case OpenResponsesInputTypeArrayOfOpenResponsesInput1:
		u.ArrayOfOpenResponsesInput1 = best.Value.([]OpenResponsesInput1)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInput", string(data))
}

func (u OpenResponsesInput) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfOpenResponsesInput1 != nil {
		return utils.MarshalJSON(u.ArrayOfOpenResponsesInput1, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesInput: all fields are null")
}
