// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type OpenResponsesInputMessageItemTypeMessage string

const (
	OpenResponsesInputMessageItemTypeMessageMessage OpenResponsesInputMessageItemTypeMessage = "message"
)

func (e OpenResponsesInputMessageItemTypeMessage) ToPointer() *OpenResponsesInputMessageItemTypeMessage {
	return &e
}
func (e *OpenResponsesInputMessageItemTypeMessage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "message":
		*e = OpenResponsesInputMessageItemTypeMessage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesInputMessageItemTypeMessage: %v", v)
	}
}

type OpenResponsesInputMessageItemRoleDeveloper string

const (
	OpenResponsesInputMessageItemRoleDeveloperDeveloper OpenResponsesInputMessageItemRoleDeveloper = "developer"
)

func (e OpenResponsesInputMessageItemRoleDeveloper) ToPointer() *OpenResponsesInputMessageItemRoleDeveloper {
	return &e
}
func (e *OpenResponsesInputMessageItemRoleDeveloper) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "developer":
		*e = OpenResponsesInputMessageItemRoleDeveloper(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesInputMessageItemRoleDeveloper: %v", v)
	}
}

type OpenResponsesInputMessageItemRoleSystem string

const (
	OpenResponsesInputMessageItemRoleSystemSystem OpenResponsesInputMessageItemRoleSystem = "system"
)

func (e OpenResponsesInputMessageItemRoleSystem) ToPointer() *OpenResponsesInputMessageItemRoleSystem {
	return &e
}
func (e *OpenResponsesInputMessageItemRoleSystem) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system":
		*e = OpenResponsesInputMessageItemRoleSystem(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesInputMessageItemRoleSystem: %v", v)
	}
}

type OpenResponsesInputMessageItemRoleUser string

const (
	OpenResponsesInputMessageItemRoleUserUser OpenResponsesInputMessageItemRoleUser = "user"
)

func (e OpenResponsesInputMessageItemRoleUser) ToPointer() *OpenResponsesInputMessageItemRoleUser {
	return &e
}
func (e *OpenResponsesInputMessageItemRoleUser) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = OpenResponsesInputMessageItemRoleUser(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesInputMessageItemRoleUser: %v", v)
	}
}

type OpenResponsesInputMessageItemRoleUnionType string

const (
	OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleUser      OpenResponsesInputMessageItemRoleUnionType = "OpenResponsesInputMessageItem_role_User"
	OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleSystem    OpenResponsesInputMessageItemRoleUnionType = "OpenResponsesInputMessageItem_role_System"
	OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleDeveloper OpenResponsesInputMessageItemRoleUnionType = "OpenResponsesInputMessageItem_role_Developer"
)

type OpenResponsesInputMessageItemRoleUnion struct {
	OpenResponsesInputMessageItemRoleUser      *OpenResponsesInputMessageItemRoleUser      `queryParam:"inline" union:"member"`
	OpenResponsesInputMessageItemRoleSystem    *OpenResponsesInputMessageItemRoleSystem    `queryParam:"inline" union:"member"`
	OpenResponsesInputMessageItemRoleDeveloper *OpenResponsesInputMessageItemRoleDeveloper `queryParam:"inline" union:"member"`

	Type OpenResponsesInputMessageItemRoleUnionType
}

func CreateOpenResponsesInputMessageItemRoleUnionOpenResponsesInputMessageItemRoleUser(openResponsesInputMessageItemRoleUser OpenResponsesInputMessageItemRoleUser) OpenResponsesInputMessageItemRoleUnion {
	typ := OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleUser

	return OpenResponsesInputMessageItemRoleUnion{
		OpenResponsesInputMessageItemRoleUser: &openResponsesInputMessageItemRoleUser,
		Type:                                  typ,
	}
}

func CreateOpenResponsesInputMessageItemRoleUnionOpenResponsesInputMessageItemRoleSystem(openResponsesInputMessageItemRoleSystem OpenResponsesInputMessageItemRoleSystem) OpenResponsesInputMessageItemRoleUnion {
	typ := OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleSystem

	return OpenResponsesInputMessageItemRoleUnion{
		OpenResponsesInputMessageItemRoleSystem: &openResponsesInputMessageItemRoleSystem,
		Type:                                    typ,
	}
}

func CreateOpenResponsesInputMessageItemRoleUnionOpenResponsesInputMessageItemRoleDeveloper(openResponsesInputMessageItemRoleDeveloper OpenResponsesInputMessageItemRoleDeveloper) OpenResponsesInputMessageItemRoleUnion {
	typ := OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleDeveloper

	return OpenResponsesInputMessageItemRoleUnion{
		OpenResponsesInputMessageItemRoleDeveloper: &openResponsesInputMessageItemRoleDeveloper,
		Type: typ,
	}
}

func (u *OpenResponsesInputMessageItemRoleUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openResponsesInputMessageItemRoleUser OpenResponsesInputMessageItemRoleUser = OpenResponsesInputMessageItemRoleUser("")
	if err := utils.UnmarshalJSON(data, &openResponsesInputMessageItemRoleUser, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleUser,
			Value: &openResponsesInputMessageItemRoleUser,
		})
	}

	var openResponsesInputMessageItemRoleSystem OpenResponsesInputMessageItemRoleSystem = OpenResponsesInputMessageItemRoleSystem("")
	if err := utils.UnmarshalJSON(data, &openResponsesInputMessageItemRoleSystem, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleSystem,
			Value: &openResponsesInputMessageItemRoleSystem,
		})
	}

	var openResponsesInputMessageItemRoleDeveloper OpenResponsesInputMessageItemRoleDeveloper = OpenResponsesInputMessageItemRoleDeveloper("")
	if err := utils.UnmarshalJSON(data, &openResponsesInputMessageItemRoleDeveloper, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleDeveloper,
			Value: &openResponsesInputMessageItemRoleDeveloper,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInputMessageItemRoleUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInputMessageItemRoleUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesInputMessageItemRoleUnionType)
	switch best.Type {
	case OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleUser:
		u.OpenResponsesInputMessageItemRoleUser = best.Value.(*OpenResponsesInputMessageItemRoleUser)
		return nil
	case OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleSystem:
		u.OpenResponsesInputMessageItemRoleSystem = best.Value.(*OpenResponsesInputMessageItemRoleSystem)
		return nil
	case OpenResponsesInputMessageItemRoleUnionTypeOpenResponsesInputMessageItemRoleDeveloper:
		u.OpenResponsesInputMessageItemRoleDeveloper = best.Value.(*OpenResponsesInputMessageItemRoleDeveloper)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInputMessageItemRoleUnion", string(data))
}

func (u OpenResponsesInputMessageItemRoleUnion) MarshalJSON() ([]byte, error) {
	if u.OpenResponsesInputMessageItemRoleUser != nil {
		return utils.MarshalJSON(u.OpenResponsesInputMessageItemRoleUser, "", true)
	}

	if u.OpenResponsesInputMessageItemRoleSystem != nil {
		return utils.MarshalJSON(u.OpenResponsesInputMessageItemRoleSystem, "", true)
	}

	if u.OpenResponsesInputMessageItemRoleDeveloper != nil {
		return utils.MarshalJSON(u.OpenResponsesInputMessageItemRoleDeveloper, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesInputMessageItemRoleUnion: all fields are null")
}

type OpenResponsesInputMessageItemContentType string

const (
	OpenResponsesInputMessageItemContentTypeInputImage OpenResponsesInputMessageItemContentType = "input_image"
)

func (e OpenResponsesInputMessageItemContentType) ToPointer() *OpenResponsesInputMessageItemContentType {
	return &e
}
func (e *OpenResponsesInputMessageItemContentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "input_image":
		*e = OpenResponsesInputMessageItemContentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesInputMessageItemContentType: %v", v)
	}
}

type OpenResponsesInputMessageItemDetail string

const (
	OpenResponsesInputMessageItemDetailAuto OpenResponsesInputMessageItemDetail = "auto"
	OpenResponsesInputMessageItemDetailHigh OpenResponsesInputMessageItemDetail = "high"
	OpenResponsesInputMessageItemDetailLow  OpenResponsesInputMessageItemDetail = "low"
)

func (e OpenResponsesInputMessageItemDetail) ToPointer() *OpenResponsesInputMessageItemDetail {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *OpenResponsesInputMessageItemDetail) IsExact() bool {
	if e != nil {
		switch *e {
		case "auto", "high", "low":
			return true
		}
	}
	return false
}

// OpenResponsesInputMessageItemContentInputImage - Image input content item
type OpenResponsesInputMessageItemContentInputImage struct {
	Type     OpenResponsesInputMessageItemContentType  `json:"type"`
	Detail   OpenResponsesInputMessageItemDetail       `json:"detail"`
	ImageURL optionalnullable.OptionalNullable[string] `json:"image_url,omitzero"`
}

func (o OpenResponsesInputMessageItemContentInputImage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesInputMessageItemContentInputImage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesInputMessageItemContentInputImage) GetType() OpenResponsesInputMessageItemContentType {
	if o == nil {
		return OpenResponsesInputMessageItemContentType("")
	}
	return o.Type
}

func (o *OpenResponsesInputMessageItemContentInputImage) GetDetail() OpenResponsesInputMessageItemDetail {
	if o == nil {
		return OpenResponsesInputMessageItemDetail("")
	}
	return o.Detail
}

func (o *OpenResponsesInputMessageItemContentInputImage) GetImageURL() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.ImageURL
}

type OpenResponsesInputMessageItemContentUnionType string

const (
	OpenResponsesInputMessageItemContentUnionTypeInputText  OpenResponsesInputMessageItemContentUnionType = "input_text"
	OpenResponsesInputMessageItemContentUnionTypeInputImage OpenResponsesInputMessageItemContentUnionType = "input_image"
	OpenResponsesInputMessageItemContentUnionTypeInputFile  OpenResponsesInputMessageItemContentUnionType = "input_file"
	OpenResponsesInputMessageItemContentUnionTypeInputAudio OpenResponsesInputMessageItemContentUnionType = "input_audio"
	OpenResponsesInputMessageItemContentUnionTypeInputVideo OpenResponsesInputMessageItemContentUnionType = "input_video"
)

type OpenResponsesInputMessageItemContentUnion struct {
	ResponseInputText                              *ResponseInputText                              `queryParam:"inline" union:"member"`
	OpenResponsesInputMessageItemContentInputImage *OpenResponsesInputMessageItemContentInputImage `queryParam:"inline" union:"member"`
	ResponseInputFile                              *ResponseInputFile                              `queryParam:"inline" union:"member"`
	ResponseInputAudio                             *ResponseInputAudio                             `queryParam:"inline" union:"member"`
	ResponseInputVideo                             *ResponseInputVideo                             `queryParam:"inline" union:"member"`

	Type OpenResponsesInputMessageItemContentUnionType
}

func CreateOpenResponsesInputMessageItemContentUnionInputText(inputText ResponseInputText) OpenResponsesInputMessageItemContentUnion {
	typ := OpenResponsesInputMessageItemContentUnionTypeInputText

	typStr := ResponseInputTextType(typ)
	inputText.Type = typStr

	return OpenResponsesInputMessageItemContentUnion{
		ResponseInputText: &inputText,
		Type:              typ,
	}
}

func CreateOpenResponsesInputMessageItemContentUnionInputImage(inputImage OpenResponsesInputMessageItemContentInputImage) OpenResponsesInputMessageItemContentUnion {
	typ := OpenResponsesInputMessageItemContentUnionTypeInputImage

	typStr := OpenResponsesInputMessageItemContentType(typ)
	inputImage.Type = typStr

	return OpenResponsesInputMessageItemContentUnion{
		OpenResponsesInputMessageItemContentInputImage: &inputImage,
		Type: typ,
	}
}

func CreateOpenResponsesInputMessageItemContentUnionInputFile(inputFile ResponseInputFile) OpenResponsesInputMessageItemContentUnion {
	typ := OpenResponsesInputMessageItemContentUnionTypeInputFile

	typStr := ResponseInputFileType(typ)
	inputFile.Type = typStr

	return OpenResponsesInputMessageItemContentUnion{
		ResponseInputFile: &inputFile,
		Type:              typ,
	}
}

func CreateOpenResponsesInputMessageItemContentUnionInputAudio(inputAudio ResponseInputAudio) OpenResponsesInputMessageItemContentUnion {
	typ := OpenResponsesInputMessageItemContentUnionTypeInputAudio

	typStr := ResponseInputAudioType(typ)
	inputAudio.Type = typStr

	return OpenResponsesInputMessageItemContentUnion{
		ResponseInputAudio: &inputAudio,
		Type:               typ,
	}
}

func CreateOpenResponsesInputMessageItemContentUnionInputVideo(inputVideo ResponseInputVideo) OpenResponsesInputMessageItemContentUnion {
	typ := OpenResponsesInputMessageItemContentUnionTypeInputVideo

	typStr := ResponseInputVideoType(typ)
	inputVideo.Type = typStr

	return OpenResponsesInputMessageItemContentUnion{
		ResponseInputVideo: &inputVideo,
		Type:               typ,
	}
}

func (u *OpenResponsesInputMessageItemContentUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "input_text":
		responseInputText := new(ResponseInputText)
		if err := utils.UnmarshalJSON(data, &responseInputText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_text) type ResponseInputText within OpenResponsesInputMessageItemContentUnion: %w", string(data), err)
		}

		u.ResponseInputText = responseInputText
		u.Type = OpenResponsesInputMessageItemContentUnionTypeInputText
		return nil
	case "input_image":
		openResponsesInputMessageItemContentInputImage := new(OpenResponsesInputMessageItemContentInputImage)
		if err := utils.UnmarshalJSON(data, &openResponsesInputMessageItemContentInputImage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_image) type OpenResponsesInputMessageItemContentInputImage within OpenResponsesInputMessageItemContentUnion: %w", string(data), err)
		}

		u.OpenResponsesInputMessageItemContentInputImage = openResponsesInputMessageItemContentInputImage
		u.Type = OpenResponsesInputMessageItemContentUnionTypeInputImage
		return nil
	case "input_file":
		responseInputFile := new(ResponseInputFile)
		if err := utils.UnmarshalJSON(data, &responseInputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_file) type ResponseInputFile within OpenResponsesInputMessageItemContentUnion: %w", string(data), err)
		}

		u.ResponseInputFile = responseInputFile
		u.Type = OpenResponsesInputMessageItemContentUnionTypeInputFile
		return nil
	case "input_audio":
		responseInputAudio := new(ResponseInputAudio)
		if err := utils.UnmarshalJSON(data, &responseInputAudio, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_audio) type ResponseInputAudio within OpenResponsesInputMessageItemContentUnion: %w", string(data), err)
		}

		u.ResponseInputAudio = responseInputAudio
		u.Type = OpenResponsesInputMessageItemContentUnionTypeInputAudio
		return nil
	case "input_video":
		responseInputVideo := new(ResponseInputVideo)
		if err := utils.UnmarshalJSON(data, &responseInputVideo, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_video) type ResponseInputVideo within OpenResponsesInputMessageItemContentUnion: %w", string(data), err)
		}

		u.ResponseInputVideo = responseInputVideo
		u.Type = OpenResponsesInputMessageItemContentUnionTypeInputVideo
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesInputMessageItemContentUnion", string(data))
}

func (u OpenResponsesInputMessageItemContentUnion) MarshalJSON() ([]byte, error) {
	if u.ResponseInputText != nil {
		return utils.MarshalJSON(u.ResponseInputText, "", true)
	}

	if u.OpenResponsesInputMessageItemContentInputImage != nil {
		return utils.MarshalJSON(u.OpenResponsesInputMessageItemContentInputImage, "", true)
	}

	if u.ResponseInputFile != nil {
		return utils.MarshalJSON(u.ResponseInputFile, "", true)
	}

	if u.ResponseInputAudio != nil {
		return utils.MarshalJSON(u.ResponseInputAudio, "", true)
	}

	if u.ResponseInputVideo != nil {
		return utils.MarshalJSON(u.ResponseInputVideo, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesInputMessageItemContentUnion: all fields are null")
}

type OpenResponsesInputMessageItem struct {
	ID      *string                                     `json:"id,omitzero"`
	Type    *OpenResponsesInputMessageItemTypeMessage   `json:"type,omitzero"`
	Role    OpenResponsesInputMessageItemRoleUnion      `json:"role"`
	Content []OpenResponsesInputMessageItemContentUnion `json:"content"`
}

func (o OpenResponsesInputMessageItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesInputMessageItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesInputMessageItem) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OpenResponsesInputMessageItem) GetType() *OpenResponsesInputMessageItemTypeMessage {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OpenResponsesInputMessageItem) GetRole() OpenResponsesInputMessageItemRoleUnion {
	if o == nil {
		return OpenResponsesInputMessageItemRoleUnion{}
	}
	return o.Role
}

func (o *OpenResponsesInputMessageItem) GetContent() []OpenResponsesInputMessageItemContentUnion {
	if o == nil {
		return []OpenResponsesInputMessageItemContentUnion{}
	}
	return o.Content
}
