// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type OpenResponsesReasoningType string

const (
	OpenResponsesReasoningTypeReasoning OpenResponsesReasoningType = "reasoning"
)

func (e OpenResponsesReasoningType) ToPointer() *OpenResponsesReasoningType {
	return &e
}
func (e *OpenResponsesReasoningType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "reasoning":
		*e = OpenResponsesReasoningType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesReasoningType: %v", v)
	}
}

type OpenResponsesReasoningStatusInProgress string

const (
	OpenResponsesReasoningStatusInProgressInProgress OpenResponsesReasoningStatusInProgress = "in_progress"
)

func (e OpenResponsesReasoningStatusInProgress) ToPointer() *OpenResponsesReasoningStatusInProgress {
	return &e
}
func (e *OpenResponsesReasoningStatusInProgress) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "in_progress":
		*e = OpenResponsesReasoningStatusInProgress(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesReasoningStatusInProgress: %v", v)
	}
}

type OpenResponsesReasoningStatusIncomplete string

const (
	OpenResponsesReasoningStatusIncompleteIncomplete OpenResponsesReasoningStatusIncomplete = "incomplete"
)

func (e OpenResponsesReasoningStatusIncomplete) ToPointer() *OpenResponsesReasoningStatusIncomplete {
	return &e
}
func (e *OpenResponsesReasoningStatusIncomplete) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incomplete":
		*e = OpenResponsesReasoningStatusIncomplete(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesReasoningStatusIncomplete: %v", v)
	}
}

type OpenResponsesReasoningStatusCompleted string

const (
	OpenResponsesReasoningStatusCompletedCompleted OpenResponsesReasoningStatusCompleted = "completed"
)

func (e OpenResponsesReasoningStatusCompleted) ToPointer() *OpenResponsesReasoningStatusCompleted {
	return &e
}
func (e *OpenResponsesReasoningStatusCompleted) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "completed":
		*e = OpenResponsesReasoningStatusCompleted(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenResponsesReasoningStatusCompleted: %v", v)
	}
}

type OpenResponsesReasoningStatusUnionType string

const (
	OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusCompleted  OpenResponsesReasoningStatusUnionType = "OpenResponsesReasoning_status_Completed"
	OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusIncomplete OpenResponsesReasoningStatusUnionType = "OpenResponsesReasoning_status_Incomplete"
	OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusInProgress OpenResponsesReasoningStatusUnionType = "OpenResponsesReasoning_status_InProgress"
)

type OpenResponsesReasoningStatusUnion struct {
	OpenResponsesReasoningStatusCompleted  *OpenResponsesReasoningStatusCompleted  `queryParam:"inline" union:"member"`
	OpenResponsesReasoningStatusIncomplete *OpenResponsesReasoningStatusIncomplete `queryParam:"inline" union:"member"`
	OpenResponsesReasoningStatusInProgress *OpenResponsesReasoningStatusInProgress `queryParam:"inline" union:"member"`

	Type OpenResponsesReasoningStatusUnionType
}

func CreateOpenResponsesReasoningStatusUnionOpenResponsesReasoningStatusCompleted(openResponsesReasoningStatusCompleted OpenResponsesReasoningStatusCompleted) OpenResponsesReasoningStatusUnion {
	typ := OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusCompleted

	return OpenResponsesReasoningStatusUnion{
		OpenResponsesReasoningStatusCompleted: &openResponsesReasoningStatusCompleted,
		Type:                                  typ,
	}
}

func CreateOpenResponsesReasoningStatusUnionOpenResponsesReasoningStatusIncomplete(openResponsesReasoningStatusIncomplete OpenResponsesReasoningStatusIncomplete) OpenResponsesReasoningStatusUnion {
	typ := OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusIncomplete

	return OpenResponsesReasoningStatusUnion{
		OpenResponsesReasoningStatusIncomplete: &openResponsesReasoningStatusIncomplete,
		Type:                                   typ,
	}
}

func CreateOpenResponsesReasoningStatusUnionOpenResponsesReasoningStatusInProgress(openResponsesReasoningStatusInProgress OpenResponsesReasoningStatusInProgress) OpenResponsesReasoningStatusUnion {
	typ := OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusInProgress

	return OpenResponsesReasoningStatusUnion{
		OpenResponsesReasoningStatusInProgress: &openResponsesReasoningStatusInProgress,
		Type:                                   typ,
	}
}

func (u *OpenResponsesReasoningStatusUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openResponsesReasoningStatusCompleted OpenResponsesReasoningStatusCompleted = OpenResponsesReasoningStatusCompleted("")
	if err := utils.UnmarshalJSON(data, &openResponsesReasoningStatusCompleted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusCompleted,
			Value: &openResponsesReasoningStatusCompleted,
		})
	}

	var openResponsesReasoningStatusIncomplete OpenResponsesReasoningStatusIncomplete = OpenResponsesReasoningStatusIncomplete("")
	if err := utils.UnmarshalJSON(data, &openResponsesReasoningStatusIncomplete, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusIncomplete,
			Value: &openResponsesReasoningStatusIncomplete,
		})
	}

	var openResponsesReasoningStatusInProgress OpenResponsesReasoningStatusInProgress = OpenResponsesReasoningStatusInProgress("")
	if err := utils.UnmarshalJSON(data, &openResponsesReasoningStatusInProgress, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusInProgress,
			Value: &openResponsesReasoningStatusInProgress,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesReasoningStatusUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesReasoningStatusUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenResponsesReasoningStatusUnionType)
	switch best.Type {
	case OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusCompleted:
		u.OpenResponsesReasoningStatusCompleted = best.Value.(*OpenResponsesReasoningStatusCompleted)
		return nil
	case OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusIncomplete:
		u.OpenResponsesReasoningStatusIncomplete = best.Value.(*OpenResponsesReasoningStatusIncomplete)
		return nil
	case OpenResponsesReasoningStatusUnionTypeOpenResponsesReasoningStatusInProgress:
		u.OpenResponsesReasoningStatusInProgress = best.Value.(*OpenResponsesReasoningStatusInProgress)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenResponsesReasoningStatusUnion", string(data))
}

func (u OpenResponsesReasoningStatusUnion) MarshalJSON() ([]byte, error) {
	if u.OpenResponsesReasoningStatusCompleted != nil {
		return utils.MarshalJSON(u.OpenResponsesReasoningStatusCompleted, "", true)
	}

	if u.OpenResponsesReasoningStatusIncomplete != nil {
		return utils.MarshalJSON(u.OpenResponsesReasoningStatusIncomplete, "", true)
	}

	if u.OpenResponsesReasoningStatusInProgress != nil {
		return utils.MarshalJSON(u.OpenResponsesReasoningStatusInProgress, "", true)
	}

	return nil, errors.New("could not marshal union type OpenResponsesReasoningStatusUnion: all fields are null")
}

type OpenResponsesReasoningFormat string

const (
	OpenResponsesReasoningFormatUnknown                OpenResponsesReasoningFormat = "unknown"
	OpenResponsesReasoningFormatOpenaiResponsesV1      OpenResponsesReasoningFormat = "openai-responses-v1"
	OpenResponsesReasoningFormatAzureOpenaiResponsesV1 OpenResponsesReasoningFormat = "azure-openai-responses-v1"
	OpenResponsesReasoningFormatXaiResponsesV1         OpenResponsesReasoningFormat = "xai-responses-v1"
	OpenResponsesReasoningFormatAnthropicClaudeV1      OpenResponsesReasoningFormat = "anthropic-claude-v1"
	OpenResponsesReasoningFormatGoogleGeminiV1         OpenResponsesReasoningFormat = "google-gemini-v1"
)

func (e OpenResponsesReasoningFormat) ToPointer() *OpenResponsesReasoningFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *OpenResponsesReasoningFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "unknown", "openai-responses-v1", "azure-openai-responses-v1", "xai-responses-v1", "anthropic-claude-v1", "google-gemini-v1":
			return true
		}
	}
	return false
}

// OpenResponsesReasoning - Reasoning output item with signature and format extensions
type OpenResponsesReasoning struct {
	Type             OpenResponsesReasoningType                                      `json:"type"`
	ID               string                                                          `json:"id"`
	Content          []ReasoningTextContent                                          `json:"content,omitzero"`
	Summary          []ReasoningSummaryText                                          `json:"summary"`
	EncryptedContent optionalnullable.OptionalNullable[string]                       `json:"encrypted_content,omitzero"`
	Status           *OpenResponsesReasoningStatusUnion                              `json:"status,omitzero"`
	Signature        optionalnullable.OptionalNullable[string]                       `json:"signature,omitzero"`
	Format           optionalnullable.OptionalNullable[OpenResponsesReasoningFormat] `json:"format,omitzero"`
}

func (o OpenResponsesReasoning) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenResponsesReasoning) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenResponsesReasoning) GetType() OpenResponsesReasoningType {
	if o == nil {
		return OpenResponsesReasoningType("")
	}
	return o.Type
}

func (o *OpenResponsesReasoning) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *OpenResponsesReasoning) GetContent() []ReasoningTextContent {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *OpenResponsesReasoning) GetSummary() []ReasoningSummaryText {
	if o == nil {
		return []ReasoningSummaryText{}
	}
	return o.Summary
}

func (o *OpenResponsesReasoning) GetEncryptedContent() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.EncryptedContent
}

func (o *OpenResponsesReasoning) GetStatus() *OpenResponsesReasoningStatusUnion {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *OpenResponsesReasoning) GetSignature() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.Signature
}

func (o *OpenResponsesReasoning) GetFormat() optionalnullable.OptionalNullable[OpenResponsesReasoningFormat] {
	if o == nil {
		return nil
	}
	return o.Format
}
