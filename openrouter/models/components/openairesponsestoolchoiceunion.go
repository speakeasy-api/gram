// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
)

type OpenAIResponsesToolChoiceTypeWebSearchPreview string

const (
	OpenAIResponsesToolChoiceTypeWebSearchPreviewWebSearchPreview OpenAIResponsesToolChoiceTypeWebSearchPreview = "web_search_preview"
)

func (e OpenAIResponsesToolChoiceTypeWebSearchPreview) ToPointer() *OpenAIResponsesToolChoiceTypeWebSearchPreview {
	return &e
}
func (e *OpenAIResponsesToolChoiceTypeWebSearchPreview) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "web_search_preview":
		*e = OpenAIResponsesToolChoiceTypeWebSearchPreview(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesToolChoiceTypeWebSearchPreview: %v", v)
	}
}

type OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 string

const (
	OpenAIResponsesToolChoiceTypeWebSearchPreview20250311WebSearchPreview20250311 OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 = "web_search_preview_2025_03_11"
)

func (e OpenAIResponsesToolChoiceTypeWebSearchPreview20250311) ToPointer() *OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 {
	return &e
}
func (e *OpenAIResponsesToolChoiceTypeWebSearchPreview20250311) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "web_search_preview_2025_03_11":
		*e = OpenAIResponsesToolChoiceTypeWebSearchPreview20250311(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesToolChoiceTypeWebSearchPreview20250311: %v", v)
	}
}

type TypeType string

const (
	TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview20250311 TypeType = "OpenAIResponsesToolChoice_type_WebSearchPreview20250311"
	TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview         TypeType = "OpenAIResponsesToolChoice_type_WebSearchPreview"
)

type Type struct {
	OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 *OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 `queryParam:"inline" union:"member"`
	OpenAIResponsesToolChoiceTypeWebSearchPreview         *OpenAIResponsesToolChoiceTypeWebSearchPreview         `queryParam:"inline" union:"member"`

	Type TypeType
}

func CreateTypeOpenAIResponsesToolChoiceTypeWebSearchPreview20250311(openAIResponsesToolChoiceTypeWebSearchPreview20250311 OpenAIResponsesToolChoiceTypeWebSearchPreview20250311) Type {
	typ := TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview20250311

	return Type{
		OpenAIResponsesToolChoiceTypeWebSearchPreview20250311: &openAIResponsesToolChoiceTypeWebSearchPreview20250311,
		Type: typ,
	}
}

func CreateTypeOpenAIResponsesToolChoiceTypeWebSearchPreview(openAIResponsesToolChoiceTypeWebSearchPreview OpenAIResponsesToolChoiceTypeWebSearchPreview) Type {
	typ := TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview

	return Type{
		OpenAIResponsesToolChoiceTypeWebSearchPreview: &openAIResponsesToolChoiceTypeWebSearchPreview,
		Type: typ,
	}
}

func (u *Type) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openAIResponsesToolChoiceTypeWebSearchPreview20250311 OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 = OpenAIResponsesToolChoiceTypeWebSearchPreview20250311("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoiceTypeWebSearchPreview20250311, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview20250311,
			Value: &openAIResponsesToolChoiceTypeWebSearchPreview20250311,
		})
	}

	var openAIResponsesToolChoiceTypeWebSearchPreview OpenAIResponsesToolChoiceTypeWebSearchPreview = OpenAIResponsesToolChoiceTypeWebSearchPreview("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoiceTypeWebSearchPreview, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview,
			Value: &openAIResponsesToolChoiceTypeWebSearchPreview,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Type", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Type", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(TypeType)
	switch best.Type {
	case TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview20250311:
		u.OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 = best.Value.(*OpenAIResponsesToolChoiceTypeWebSearchPreview20250311)
		return nil
	case TypeTypeOpenAIResponsesToolChoiceTypeWebSearchPreview:
		u.OpenAIResponsesToolChoiceTypeWebSearchPreview = best.Value.(*OpenAIResponsesToolChoiceTypeWebSearchPreview)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Type", string(data))
}

func (u Type) MarshalJSON() ([]byte, error) {
	if u.OpenAIResponsesToolChoiceTypeWebSearchPreview20250311 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoiceTypeWebSearchPreview20250311, "", true)
	}

	if u.OpenAIResponsesToolChoiceTypeWebSearchPreview != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoiceTypeWebSearchPreview, "", true)
	}

	return nil, errors.New("could not marshal union type Type: all fields are null")
}

type OpenAIResponsesToolChoice struct {
	Type Type `json:"type"`
}

func (o OpenAIResponsesToolChoice) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenAIResponsesToolChoice) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenAIResponsesToolChoice) GetType() Type {
	if o == nil {
		return Type{}
	}
	return o.Type
}

type OpenAIResponsesToolChoiceTypeFunction string

const (
	OpenAIResponsesToolChoiceTypeFunctionFunction OpenAIResponsesToolChoiceTypeFunction = "function"
)

func (e OpenAIResponsesToolChoiceTypeFunction) ToPointer() *OpenAIResponsesToolChoiceTypeFunction {
	return &e
}
func (e *OpenAIResponsesToolChoiceTypeFunction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "function":
		*e = OpenAIResponsesToolChoiceTypeFunction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesToolChoiceTypeFunction: %v", v)
	}
}

type OpenAIResponsesToolChoiceFunction struct {
	Type OpenAIResponsesToolChoiceTypeFunction `json:"type"`
	Name string                                `json:"name"`
}

func (o OpenAIResponsesToolChoiceFunction) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenAIResponsesToolChoiceFunction) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenAIResponsesToolChoiceFunction) GetType() OpenAIResponsesToolChoiceTypeFunction {
	if o == nil {
		return OpenAIResponsesToolChoiceTypeFunction("")
	}
	return o.Type
}

func (o *OpenAIResponsesToolChoiceFunction) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

type OpenAIResponsesToolChoiceRequired string

const (
	OpenAIResponsesToolChoiceRequiredRequired OpenAIResponsesToolChoiceRequired = "required"
)

func (e OpenAIResponsesToolChoiceRequired) ToPointer() *OpenAIResponsesToolChoiceRequired {
	return &e
}
func (e *OpenAIResponsesToolChoiceRequired) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = OpenAIResponsesToolChoiceRequired(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesToolChoiceRequired: %v", v)
	}
}

type OpenAIResponsesToolChoiceNone string

const (
	OpenAIResponsesToolChoiceNoneNone OpenAIResponsesToolChoiceNone = "none"
)

func (e OpenAIResponsesToolChoiceNone) ToPointer() *OpenAIResponsesToolChoiceNone {
	return &e
}
func (e *OpenAIResponsesToolChoiceNone) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = OpenAIResponsesToolChoiceNone(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesToolChoiceNone: %v", v)
	}
}

type OpenAIResponsesToolChoiceAuto string

const (
	OpenAIResponsesToolChoiceAutoAuto OpenAIResponsesToolChoiceAuto = "auto"
)

func (e OpenAIResponsesToolChoiceAuto) ToPointer() *OpenAIResponsesToolChoiceAuto {
	return &e
}
func (e *OpenAIResponsesToolChoiceAuto) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		*e = OpenAIResponsesToolChoiceAuto(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesToolChoiceAuto: %v", v)
	}
}

type OpenAIResponsesToolChoiceUnionType string

const (
	OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceAuto     OpenAIResponsesToolChoiceUnionType = "OpenAIResponsesToolChoice_Auto"
	OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceNone     OpenAIResponsesToolChoiceUnionType = "OpenAIResponsesToolChoice_None"
	OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceRequired OpenAIResponsesToolChoiceUnionType = "OpenAIResponsesToolChoice_Required"
	OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceFunction OpenAIResponsesToolChoiceUnionType = "OpenAIResponsesToolChoice_Function"
	OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoice         OpenAIResponsesToolChoiceUnionType = "OpenAIResponsesToolChoice"
)

type OpenAIResponsesToolChoiceUnion struct {
	OpenAIResponsesToolChoiceAuto     *OpenAIResponsesToolChoiceAuto     `queryParam:"inline" union:"member"`
	OpenAIResponsesToolChoiceNone     *OpenAIResponsesToolChoiceNone     `queryParam:"inline" union:"member"`
	OpenAIResponsesToolChoiceRequired *OpenAIResponsesToolChoiceRequired `queryParam:"inline" union:"member"`
	OpenAIResponsesToolChoiceFunction *OpenAIResponsesToolChoiceFunction `queryParam:"inline" union:"member"`
	OpenAIResponsesToolChoice         *OpenAIResponsesToolChoice         `queryParam:"inline" union:"member"`

	Type OpenAIResponsesToolChoiceUnionType
}

func CreateOpenAIResponsesToolChoiceUnionOpenAIResponsesToolChoiceAuto(openAIResponsesToolChoiceAuto OpenAIResponsesToolChoiceAuto) OpenAIResponsesToolChoiceUnion {
	typ := OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceAuto

	return OpenAIResponsesToolChoiceUnion{
		OpenAIResponsesToolChoiceAuto: &openAIResponsesToolChoiceAuto,
		Type:                          typ,
	}
}

func CreateOpenAIResponsesToolChoiceUnionOpenAIResponsesToolChoiceNone(openAIResponsesToolChoiceNone OpenAIResponsesToolChoiceNone) OpenAIResponsesToolChoiceUnion {
	typ := OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceNone

	return OpenAIResponsesToolChoiceUnion{
		OpenAIResponsesToolChoiceNone: &openAIResponsesToolChoiceNone,
		Type:                          typ,
	}
}

func CreateOpenAIResponsesToolChoiceUnionOpenAIResponsesToolChoiceRequired(openAIResponsesToolChoiceRequired OpenAIResponsesToolChoiceRequired) OpenAIResponsesToolChoiceUnion {
	typ := OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceRequired

	return OpenAIResponsesToolChoiceUnion{
		OpenAIResponsesToolChoiceRequired: &openAIResponsesToolChoiceRequired,
		Type:                              typ,
	}
}

func CreateOpenAIResponsesToolChoiceUnionOpenAIResponsesToolChoiceFunction(openAIResponsesToolChoiceFunction OpenAIResponsesToolChoiceFunction) OpenAIResponsesToolChoiceUnion {
	typ := OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceFunction

	return OpenAIResponsesToolChoiceUnion{
		OpenAIResponsesToolChoiceFunction: &openAIResponsesToolChoiceFunction,
		Type:                              typ,
	}
}

func CreateOpenAIResponsesToolChoiceUnionOpenAIResponsesToolChoice(openAIResponsesToolChoice OpenAIResponsesToolChoice) OpenAIResponsesToolChoiceUnion {
	typ := OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoice

	return OpenAIResponsesToolChoiceUnion{
		OpenAIResponsesToolChoice: &openAIResponsesToolChoice,
		Type:                      typ,
	}
}

func (u *OpenAIResponsesToolChoiceUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openAIResponsesToolChoiceAuto OpenAIResponsesToolChoiceAuto = OpenAIResponsesToolChoiceAuto("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoiceAuto, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceAuto,
			Value: &openAIResponsesToolChoiceAuto,
		})
	}

	var openAIResponsesToolChoiceNone OpenAIResponsesToolChoiceNone = OpenAIResponsesToolChoiceNone("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoiceNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceNone,
			Value: &openAIResponsesToolChoiceNone,
		})
	}

	var openAIResponsesToolChoiceRequired OpenAIResponsesToolChoiceRequired = OpenAIResponsesToolChoiceRequired("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoiceRequired, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceRequired,
			Value: &openAIResponsesToolChoiceRequired,
		})
	}

	var openAIResponsesToolChoiceFunction OpenAIResponsesToolChoiceFunction = OpenAIResponsesToolChoiceFunction{}
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoiceFunction, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceFunction,
			Value: &openAIResponsesToolChoiceFunction,
		})
	}

	var openAIResponsesToolChoice OpenAIResponsesToolChoice = OpenAIResponsesToolChoice{}
	if err := utils.UnmarshalJSON(data, &openAIResponsesToolChoice, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoice,
			Value: &openAIResponsesToolChoice,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesToolChoiceUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesToolChoiceUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenAIResponsesToolChoiceUnionType)
	switch best.Type {
	case OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceAuto:
		u.OpenAIResponsesToolChoiceAuto = best.Value.(*OpenAIResponsesToolChoiceAuto)
		return nil
	case OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceNone:
		u.OpenAIResponsesToolChoiceNone = best.Value.(*OpenAIResponsesToolChoiceNone)
		return nil
	case OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceRequired:
		u.OpenAIResponsesToolChoiceRequired = best.Value.(*OpenAIResponsesToolChoiceRequired)
		return nil
	case OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoiceFunction:
		u.OpenAIResponsesToolChoiceFunction = best.Value.(*OpenAIResponsesToolChoiceFunction)
		return nil
	case OpenAIResponsesToolChoiceUnionTypeOpenAIResponsesToolChoice:
		u.OpenAIResponsesToolChoice = best.Value.(*OpenAIResponsesToolChoice)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesToolChoiceUnion", string(data))
}

func (u OpenAIResponsesToolChoiceUnion) MarshalJSON() ([]byte, error) {
	if u.OpenAIResponsesToolChoiceAuto != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoiceAuto, "", true)
	}

	if u.OpenAIResponsesToolChoiceNone != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoiceNone, "", true)
	}

	if u.OpenAIResponsesToolChoiceRequired != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoiceRequired, "", true)
	}

	if u.OpenAIResponsesToolChoiceFunction != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoiceFunction, "", true)
	}

	if u.OpenAIResponsesToolChoice != nil {
		return utils.MarshalJSON(u.OpenAIResponsesToolChoice, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesToolChoiceUnion: all fields are null")
}
