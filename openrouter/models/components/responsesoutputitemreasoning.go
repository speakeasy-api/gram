// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type ResponsesOutputItemReasoningType string

const (
	ResponsesOutputItemReasoningTypeReasoning ResponsesOutputItemReasoningType = "reasoning"
)

func (e ResponsesOutputItemReasoningType) ToPointer() *ResponsesOutputItemReasoningType {
	return &e
}
func (e *ResponsesOutputItemReasoningType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "reasoning":
		*e = ResponsesOutputItemReasoningType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponsesOutputItemReasoningType: %v", v)
	}
}

type ResponsesOutputItemReasoningStatusInProgress string

const (
	ResponsesOutputItemReasoningStatusInProgressInProgress ResponsesOutputItemReasoningStatusInProgress = "in_progress"
)

func (e ResponsesOutputItemReasoningStatusInProgress) ToPointer() *ResponsesOutputItemReasoningStatusInProgress {
	return &e
}
func (e *ResponsesOutputItemReasoningStatusInProgress) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "in_progress":
		*e = ResponsesOutputItemReasoningStatusInProgress(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponsesOutputItemReasoningStatusInProgress: %v", v)
	}
}

type ResponsesOutputItemReasoningStatusIncomplete string

const (
	ResponsesOutputItemReasoningStatusIncompleteIncomplete ResponsesOutputItemReasoningStatusIncomplete = "incomplete"
)

func (e ResponsesOutputItemReasoningStatusIncomplete) ToPointer() *ResponsesOutputItemReasoningStatusIncomplete {
	return &e
}
func (e *ResponsesOutputItemReasoningStatusIncomplete) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incomplete":
		*e = ResponsesOutputItemReasoningStatusIncomplete(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponsesOutputItemReasoningStatusIncomplete: %v", v)
	}
}

type ResponsesOutputItemReasoningStatusCompleted string

const (
	ResponsesOutputItemReasoningStatusCompletedCompleted ResponsesOutputItemReasoningStatusCompleted = "completed"
)

func (e ResponsesOutputItemReasoningStatusCompleted) ToPointer() *ResponsesOutputItemReasoningStatusCompleted {
	return &e
}
func (e *ResponsesOutputItemReasoningStatusCompleted) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "completed":
		*e = ResponsesOutputItemReasoningStatusCompleted(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponsesOutputItemReasoningStatusCompleted: %v", v)
	}
}

type ResponsesOutputItemReasoningStatusUnionType string

const (
	ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusCompleted  ResponsesOutputItemReasoningStatusUnionType = "ResponsesOutputItemReasoning_status_Completed"
	ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusIncomplete ResponsesOutputItemReasoningStatusUnionType = "ResponsesOutputItemReasoning_status_Incomplete"
	ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusInProgress ResponsesOutputItemReasoningStatusUnionType = "ResponsesOutputItemReasoning_status_InProgress"
)

type ResponsesOutputItemReasoningStatusUnion struct {
	ResponsesOutputItemReasoningStatusCompleted  *ResponsesOutputItemReasoningStatusCompleted  `queryParam:"inline" union:"member"`
	ResponsesOutputItemReasoningStatusIncomplete *ResponsesOutputItemReasoningStatusIncomplete `queryParam:"inline" union:"member"`
	ResponsesOutputItemReasoningStatusInProgress *ResponsesOutputItemReasoningStatusInProgress `queryParam:"inline" union:"member"`

	Type ResponsesOutputItemReasoningStatusUnionType
}

func CreateResponsesOutputItemReasoningStatusUnionResponsesOutputItemReasoningStatusCompleted(responsesOutputItemReasoningStatusCompleted ResponsesOutputItemReasoningStatusCompleted) ResponsesOutputItemReasoningStatusUnion {
	typ := ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusCompleted

	return ResponsesOutputItemReasoningStatusUnion{
		ResponsesOutputItemReasoningStatusCompleted: &responsesOutputItemReasoningStatusCompleted,
		Type: typ,
	}
}

func CreateResponsesOutputItemReasoningStatusUnionResponsesOutputItemReasoningStatusIncomplete(responsesOutputItemReasoningStatusIncomplete ResponsesOutputItemReasoningStatusIncomplete) ResponsesOutputItemReasoningStatusUnion {
	typ := ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusIncomplete

	return ResponsesOutputItemReasoningStatusUnion{
		ResponsesOutputItemReasoningStatusIncomplete: &responsesOutputItemReasoningStatusIncomplete,
		Type: typ,
	}
}

func CreateResponsesOutputItemReasoningStatusUnionResponsesOutputItemReasoningStatusInProgress(responsesOutputItemReasoningStatusInProgress ResponsesOutputItemReasoningStatusInProgress) ResponsesOutputItemReasoningStatusUnion {
	typ := ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusInProgress

	return ResponsesOutputItemReasoningStatusUnion{
		ResponsesOutputItemReasoningStatusInProgress: &responsesOutputItemReasoningStatusInProgress,
		Type: typ,
	}
}

func (u *ResponsesOutputItemReasoningStatusUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var responsesOutputItemReasoningStatusCompleted ResponsesOutputItemReasoningStatusCompleted = ResponsesOutputItemReasoningStatusCompleted("")
	if err := utils.UnmarshalJSON(data, &responsesOutputItemReasoningStatusCompleted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusCompleted,
			Value: &responsesOutputItemReasoningStatusCompleted,
		})
	}

	var responsesOutputItemReasoningStatusIncomplete ResponsesOutputItemReasoningStatusIncomplete = ResponsesOutputItemReasoningStatusIncomplete("")
	if err := utils.UnmarshalJSON(data, &responsesOutputItemReasoningStatusIncomplete, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusIncomplete,
			Value: &responsesOutputItemReasoningStatusIncomplete,
		})
	}

	var responsesOutputItemReasoningStatusInProgress ResponsesOutputItemReasoningStatusInProgress = ResponsesOutputItemReasoningStatusInProgress("")
	if err := utils.UnmarshalJSON(data, &responsesOutputItemReasoningStatusInProgress, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusInProgress,
			Value: &responsesOutputItemReasoningStatusInProgress,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ResponsesOutputItemReasoningStatusUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ResponsesOutputItemReasoningStatusUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ResponsesOutputItemReasoningStatusUnionType)
	switch best.Type {
	case ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusCompleted:
		u.ResponsesOutputItemReasoningStatusCompleted = best.Value.(*ResponsesOutputItemReasoningStatusCompleted)
		return nil
	case ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusIncomplete:
		u.ResponsesOutputItemReasoningStatusIncomplete = best.Value.(*ResponsesOutputItemReasoningStatusIncomplete)
		return nil
	case ResponsesOutputItemReasoningStatusUnionTypeResponsesOutputItemReasoningStatusInProgress:
		u.ResponsesOutputItemReasoningStatusInProgress = best.Value.(*ResponsesOutputItemReasoningStatusInProgress)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ResponsesOutputItemReasoningStatusUnion", string(data))
}

func (u ResponsesOutputItemReasoningStatusUnion) MarshalJSON() ([]byte, error) {
	if u.ResponsesOutputItemReasoningStatusCompleted != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemReasoningStatusCompleted, "", true)
	}

	if u.ResponsesOutputItemReasoningStatusIncomplete != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemReasoningStatusIncomplete, "", true)
	}

	if u.ResponsesOutputItemReasoningStatusInProgress != nil {
		return utils.MarshalJSON(u.ResponsesOutputItemReasoningStatusInProgress, "", true)
	}

	return nil, errors.New("could not marshal union type ResponsesOutputItemReasoningStatusUnion: all fields are null")
}

// ResponsesOutputItemReasoningFormat - The format of the reasoning content
type ResponsesOutputItemReasoningFormat string

const (
	ResponsesOutputItemReasoningFormatUnknown                ResponsesOutputItemReasoningFormat = "unknown"
	ResponsesOutputItemReasoningFormatOpenaiResponsesV1      ResponsesOutputItemReasoningFormat = "openai-responses-v1"
	ResponsesOutputItemReasoningFormatAzureOpenaiResponsesV1 ResponsesOutputItemReasoningFormat = "azure-openai-responses-v1"
	ResponsesOutputItemReasoningFormatXaiResponsesV1         ResponsesOutputItemReasoningFormat = "xai-responses-v1"
	ResponsesOutputItemReasoningFormatAnthropicClaudeV1      ResponsesOutputItemReasoningFormat = "anthropic-claude-v1"
	ResponsesOutputItemReasoningFormatGoogleGeminiV1         ResponsesOutputItemReasoningFormat = "google-gemini-v1"
)

func (e ResponsesOutputItemReasoningFormat) ToPointer() *ResponsesOutputItemReasoningFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *ResponsesOutputItemReasoningFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "unknown", "openai-responses-v1", "azure-openai-responses-v1", "xai-responses-v1", "anthropic-claude-v1", "google-gemini-v1":
			return true
		}
	}
	return false
}

// ResponsesOutputItemReasoning - An output item containing reasoning
type ResponsesOutputItemReasoning struct {
	Type             ResponsesOutputItemReasoningType          `json:"type"`
	ID               string                                    `json:"id"`
	Content          []ReasoningTextContent                    `json:"content,omitzero"`
	Summary          []ReasoningSummaryText                    `json:"summary"`
	EncryptedContent optionalnullable.OptionalNullable[string] `json:"encrypted_content,omitzero"`
	Status           *ResponsesOutputItemReasoningStatusUnion  `json:"status,omitzero"`
	// A signature for the reasoning content, used for verification
	Signature optionalnullable.OptionalNullable[string] `json:"signature,omitzero"`
	// The format of the reasoning content
	Format optionalnullable.OptionalNullable[ResponsesOutputItemReasoningFormat] `json:"format,omitzero"`
}

func (r ResponsesOutputItemReasoning) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ResponsesOutputItemReasoning) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ResponsesOutputItemReasoning) GetType() ResponsesOutputItemReasoningType {
	if r == nil {
		return ResponsesOutputItemReasoningType("")
	}
	return r.Type
}

func (r *ResponsesOutputItemReasoning) GetID() string {
	if r == nil {
		return ""
	}
	return r.ID
}

func (r *ResponsesOutputItemReasoning) GetContent() []ReasoningTextContent {
	if r == nil {
		return nil
	}
	return r.Content
}

func (r *ResponsesOutputItemReasoning) GetSummary() []ReasoningSummaryText {
	if r == nil {
		return []ReasoningSummaryText{}
	}
	return r.Summary
}

func (r *ResponsesOutputItemReasoning) GetEncryptedContent() optionalnullable.OptionalNullable[string] {
	if r == nil {
		return nil
	}
	return r.EncryptedContent
}

func (r *ResponsesOutputItemReasoning) GetStatus() *ResponsesOutputItemReasoningStatusUnion {
	if r == nil {
		return nil
	}
	return r.Status
}

func (r *ResponsesOutputItemReasoning) GetSignature() optionalnullable.OptionalNullable[string] {
	if r == nil {
		return nil
	}
	return r.Signature
}

func (r *ResponsesOutputItemReasoning) GetFormat() optionalnullable.OptionalNullable[ResponsesOutputItemReasoningFormat] {
	if r == nil {
		return nil
	}
	return r.Format
}
