// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/optionalnullable"
)

type OpenAIResponsesInputTypeFunctionCall string

const (
	OpenAIResponsesInputTypeFunctionCallFunctionCall OpenAIResponsesInputTypeFunctionCall = "function_call"
)

func (e OpenAIResponsesInputTypeFunctionCall) ToPointer() *OpenAIResponsesInputTypeFunctionCall {
	return &e
}
func (e *OpenAIResponsesInputTypeFunctionCall) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "function_call":
		*e = OpenAIResponsesInputTypeFunctionCall(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputTypeFunctionCall: %v", v)
	}
}

type OpenAIResponsesInputFunctionCall struct {
	Type      OpenAIResponsesInputTypeFunctionCall              `json:"type"`
	CallID    string                                            `json:"call_id"`
	Name      string                                            `json:"name"`
	Arguments string                                            `json:"arguments"`
	ID        *string                                           `json:"id,omitzero"`
	Status    optionalnullable.OptionalNullable[ToolCallStatus] `json:"status,omitzero"`
}

func (o OpenAIResponsesInputFunctionCall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenAIResponsesInputFunctionCall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenAIResponsesInputFunctionCall) GetType() OpenAIResponsesInputTypeFunctionCall {
	if o == nil {
		return OpenAIResponsesInputTypeFunctionCall("")
	}
	return o.Type
}

func (o *OpenAIResponsesInputFunctionCall) GetCallID() string {
	if o == nil {
		return ""
	}
	return o.CallID
}

func (o *OpenAIResponsesInputFunctionCall) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *OpenAIResponsesInputFunctionCall) GetArguments() string {
	if o == nil {
		return ""
	}
	return o.Arguments
}

func (o *OpenAIResponsesInputFunctionCall) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OpenAIResponsesInputFunctionCall) GetStatus() optionalnullable.OptionalNullable[ToolCallStatus] {
	if o == nil {
		return nil
	}
	return o.Status
}

type OpenAIResponsesInputTypeFunctionCallOutput string

const (
	OpenAIResponsesInputTypeFunctionCallOutputFunctionCallOutput OpenAIResponsesInputTypeFunctionCallOutput = "function_call_output"
)

func (e OpenAIResponsesInputTypeFunctionCallOutput) ToPointer() *OpenAIResponsesInputTypeFunctionCallOutput {
	return &e
}
func (e *OpenAIResponsesInputTypeFunctionCallOutput) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "function_call_output":
		*e = OpenAIResponsesInputTypeFunctionCallOutput(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputTypeFunctionCallOutput: %v", v)
	}
}

type OpenAIResponsesInputFunctionCallOutput struct {
	Type   OpenAIResponsesInputTypeFunctionCallOutput        `json:"type"`
	ID     optionalnullable.OptionalNullable[string]         `json:"id,omitzero"`
	CallID string                                            `json:"call_id"`
	Output string                                            `json:"output"`
	Status optionalnullable.OptionalNullable[ToolCallStatus] `json:"status,omitzero"`
}

func (o OpenAIResponsesInputFunctionCallOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenAIResponsesInputFunctionCallOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenAIResponsesInputFunctionCallOutput) GetType() OpenAIResponsesInputTypeFunctionCallOutput {
	if o == nil {
		return OpenAIResponsesInputTypeFunctionCallOutput("")
	}
	return o.Type
}

func (o *OpenAIResponsesInputFunctionCallOutput) GetID() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OpenAIResponsesInputFunctionCallOutput) GetCallID() string {
	if o == nil {
		return ""
	}
	return o.CallID
}

func (o *OpenAIResponsesInputFunctionCallOutput) GetOutput() string {
	if o == nil {
		return ""
	}
	return o.Output
}

func (o *OpenAIResponsesInputFunctionCallOutput) GetStatus() optionalnullable.OptionalNullable[ToolCallStatus] {
	if o == nil {
		return nil
	}
	return o.Status
}

type OpenAIResponsesInputTypeMessage2 string

const (
	OpenAIResponsesInputTypeMessage2Message OpenAIResponsesInputTypeMessage2 = "message"
)

func (e OpenAIResponsesInputTypeMessage2) ToPointer() *OpenAIResponsesInputTypeMessage2 {
	return &e
}
func (e *OpenAIResponsesInputTypeMessage2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "message":
		*e = OpenAIResponsesInputTypeMessage2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputTypeMessage2: %v", v)
	}
}

type OpenAIResponsesInputRoleDeveloper2 string

const (
	OpenAIResponsesInputRoleDeveloper2Developer OpenAIResponsesInputRoleDeveloper2 = "developer"
)

func (e OpenAIResponsesInputRoleDeveloper2) ToPointer() *OpenAIResponsesInputRoleDeveloper2 {
	return &e
}
func (e *OpenAIResponsesInputRoleDeveloper2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "developer":
		*e = OpenAIResponsesInputRoleDeveloper2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleDeveloper2: %v", v)
	}
}

type OpenAIResponsesInputRoleSystem2 string

const (
	OpenAIResponsesInputRoleSystem2System OpenAIResponsesInputRoleSystem2 = "system"
)

func (e OpenAIResponsesInputRoleSystem2) ToPointer() *OpenAIResponsesInputRoleSystem2 {
	return &e
}
func (e *OpenAIResponsesInputRoleSystem2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system":
		*e = OpenAIResponsesInputRoleSystem2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleSystem2: %v", v)
	}
}

type OpenAIResponsesInputRoleUser2 string

const (
	OpenAIResponsesInputRoleUser2User OpenAIResponsesInputRoleUser2 = "user"
)

func (e OpenAIResponsesInputRoleUser2) ToPointer() *OpenAIResponsesInputRoleUser2 {
	return &e
}
func (e *OpenAIResponsesInputRoleUser2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = OpenAIResponsesInputRoleUser2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleUser2: %v", v)
	}
}

type OpenAIResponsesInputRoleUnion2Type string

const (
	OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleUser2      OpenAIResponsesInputRoleUnion2Type = "OpenAIResponsesInput_role_User_2"
	OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleSystem2    OpenAIResponsesInputRoleUnion2Type = "OpenAIResponsesInput_role_System_2"
	OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleDeveloper2 OpenAIResponsesInputRoleUnion2Type = "OpenAIResponsesInput_role_Developer_2"
)

type OpenAIResponsesInputRoleUnion2 struct {
	OpenAIResponsesInputRoleUser2      *OpenAIResponsesInputRoleUser2      `queryParam:"inline" union:"member"`
	OpenAIResponsesInputRoleSystem2    *OpenAIResponsesInputRoleSystem2    `queryParam:"inline" union:"member"`
	OpenAIResponsesInputRoleDeveloper2 *OpenAIResponsesInputRoleDeveloper2 `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputRoleUnion2Type
}

func CreateOpenAIResponsesInputRoleUnion2OpenAIResponsesInputRoleUser2(openAIResponsesInputRoleUser2 OpenAIResponsesInputRoleUser2) OpenAIResponsesInputRoleUnion2 {
	typ := OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleUser2

	return OpenAIResponsesInputRoleUnion2{
		OpenAIResponsesInputRoleUser2: &openAIResponsesInputRoleUser2,
		Type:                          typ,
	}
}

func CreateOpenAIResponsesInputRoleUnion2OpenAIResponsesInputRoleSystem2(openAIResponsesInputRoleSystem2 OpenAIResponsesInputRoleSystem2) OpenAIResponsesInputRoleUnion2 {
	typ := OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleSystem2

	return OpenAIResponsesInputRoleUnion2{
		OpenAIResponsesInputRoleSystem2: &openAIResponsesInputRoleSystem2,
		Type:                            typ,
	}
}

func CreateOpenAIResponsesInputRoleUnion2OpenAIResponsesInputRoleDeveloper2(openAIResponsesInputRoleDeveloper2 OpenAIResponsesInputRoleDeveloper2) OpenAIResponsesInputRoleUnion2 {
	typ := OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleDeveloper2

	return OpenAIResponsesInputRoleUnion2{
		OpenAIResponsesInputRoleDeveloper2: &openAIResponsesInputRoleDeveloper2,
		Type:                               typ,
	}
}

func (u *OpenAIResponsesInputRoleUnion2) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openAIResponsesInputRoleUser2 OpenAIResponsesInputRoleUser2 = OpenAIResponsesInputRoleUser2("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleUser2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleUser2,
			Value: &openAIResponsesInputRoleUser2,
		})
	}

	var openAIResponsesInputRoleSystem2 OpenAIResponsesInputRoleSystem2 = OpenAIResponsesInputRoleSystem2("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleSystem2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleSystem2,
			Value: &openAIResponsesInputRoleSystem2,
		})
	}

	var openAIResponsesInputRoleDeveloper2 OpenAIResponsesInputRoleDeveloper2 = OpenAIResponsesInputRoleDeveloper2("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleDeveloper2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleDeveloper2,
			Value: &openAIResponsesInputRoleDeveloper2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputRoleUnion2", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputRoleUnion2", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenAIResponsesInputRoleUnion2Type)
	switch best.Type {
	case OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleUser2:
		u.OpenAIResponsesInputRoleUser2 = best.Value.(*OpenAIResponsesInputRoleUser2)
		return nil
	case OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleSystem2:
		u.OpenAIResponsesInputRoleSystem2 = best.Value.(*OpenAIResponsesInputRoleSystem2)
		return nil
	case OpenAIResponsesInputRoleUnion2TypeOpenAIResponsesInputRoleDeveloper2:
		u.OpenAIResponsesInputRoleDeveloper2 = best.Value.(*OpenAIResponsesInputRoleDeveloper2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputRoleUnion2", string(data))
}

func (u OpenAIResponsesInputRoleUnion2) MarshalJSON() ([]byte, error) {
	if u.OpenAIResponsesInputRoleUser2 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleUser2, "", true)
	}

	if u.OpenAIResponsesInputRoleSystem2 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleSystem2, "", true)
	}

	if u.OpenAIResponsesInputRoleDeveloper2 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleDeveloper2, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputRoleUnion2: all fields are null")
}

type OpenAIResponsesInputContent3Type string

const (
	OpenAIResponsesInputContent3TypeInputText  OpenAIResponsesInputContent3Type = "input_text"
	OpenAIResponsesInputContent3TypeInputImage OpenAIResponsesInputContent3Type = "input_image"
	OpenAIResponsesInputContent3TypeInputFile  OpenAIResponsesInputContent3Type = "input_file"
	OpenAIResponsesInputContent3TypeInputAudio OpenAIResponsesInputContent3Type = "input_audio"
)

type OpenAIResponsesInputContent3 struct {
	ResponseInputText  *ResponseInputText  `queryParam:"inline" union:"member"`
	ResponseInputImage *ResponseInputImage `queryParam:"inline" union:"member"`
	ResponseInputFile  *ResponseInputFile  `queryParam:"inline" union:"member"`
	ResponseInputAudio *ResponseInputAudio `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputContent3Type
}

func CreateOpenAIResponsesInputContent3InputText(inputText ResponseInputText) OpenAIResponsesInputContent3 {
	typ := OpenAIResponsesInputContent3TypeInputText

	typStr := ResponseInputTextType(typ)
	inputText.Type = typStr

	return OpenAIResponsesInputContent3{
		ResponseInputText: &inputText,
		Type:              typ,
	}
}

func CreateOpenAIResponsesInputContent3InputImage(inputImage ResponseInputImage) OpenAIResponsesInputContent3 {
	typ := OpenAIResponsesInputContent3TypeInputImage

	typStr := ResponseInputImageType(typ)
	inputImage.Type = typStr

	return OpenAIResponsesInputContent3{
		ResponseInputImage: &inputImage,
		Type:               typ,
	}
}

func CreateOpenAIResponsesInputContent3InputFile(inputFile ResponseInputFile) OpenAIResponsesInputContent3 {
	typ := OpenAIResponsesInputContent3TypeInputFile

	typStr := ResponseInputFileType(typ)
	inputFile.Type = typStr

	return OpenAIResponsesInputContent3{
		ResponseInputFile: &inputFile,
		Type:              typ,
	}
}

func CreateOpenAIResponsesInputContent3InputAudio(inputAudio ResponseInputAudio) OpenAIResponsesInputContent3 {
	typ := OpenAIResponsesInputContent3TypeInputAudio

	typStr := ResponseInputAudioType(typ)
	inputAudio.Type = typStr

	return OpenAIResponsesInputContent3{
		ResponseInputAudio: &inputAudio,
		Type:               typ,
	}
}

func (u *OpenAIResponsesInputContent3) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "input_text":
		responseInputText := new(ResponseInputText)
		if err := utils.UnmarshalJSON(data, &responseInputText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_text) type ResponseInputText within OpenAIResponsesInputContent3: %w", string(data), err)
		}

		u.ResponseInputText = responseInputText
		u.Type = OpenAIResponsesInputContent3TypeInputText
		return nil
	case "input_image":
		responseInputImage := new(ResponseInputImage)
		if err := utils.UnmarshalJSON(data, &responseInputImage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_image) type ResponseInputImage within OpenAIResponsesInputContent3: %w", string(data), err)
		}

		u.ResponseInputImage = responseInputImage
		u.Type = OpenAIResponsesInputContent3TypeInputImage
		return nil
	case "input_file":
		responseInputFile := new(ResponseInputFile)
		if err := utils.UnmarshalJSON(data, &responseInputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_file) type ResponseInputFile within OpenAIResponsesInputContent3: %w", string(data), err)
		}

		u.ResponseInputFile = responseInputFile
		u.Type = OpenAIResponsesInputContent3TypeInputFile
		return nil
	case "input_audio":
		responseInputAudio := new(ResponseInputAudio)
		if err := utils.UnmarshalJSON(data, &responseInputAudio, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_audio) type ResponseInputAudio within OpenAIResponsesInputContent3: %w", string(data), err)
		}

		u.ResponseInputAudio = responseInputAudio
		u.Type = OpenAIResponsesInputContent3TypeInputAudio
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputContent3", string(data))
}

func (u OpenAIResponsesInputContent3) MarshalJSON() ([]byte, error) {
	if u.ResponseInputText != nil {
		return utils.MarshalJSON(u.ResponseInputText, "", true)
	}

	if u.ResponseInputImage != nil {
		return utils.MarshalJSON(u.ResponseInputImage, "", true)
	}

	if u.ResponseInputFile != nil {
		return utils.MarshalJSON(u.ResponseInputFile, "", true)
	}

	if u.ResponseInputAudio != nil {
		return utils.MarshalJSON(u.ResponseInputAudio, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputContent3: all fields are null")
}

type OpenAIResponsesInputMessage2 struct {
	ID      string                            `json:"id"`
	Type    *OpenAIResponsesInputTypeMessage2 `json:"type,omitzero"`
	Role    OpenAIResponsesInputRoleUnion2    `json:"role"`
	Content []OpenAIResponsesInputContent3    `json:"content"`
}

func (o OpenAIResponsesInputMessage2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenAIResponsesInputMessage2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenAIResponsesInputMessage2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *OpenAIResponsesInputMessage2) GetType() *OpenAIResponsesInputTypeMessage2 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OpenAIResponsesInputMessage2) GetRole() OpenAIResponsesInputRoleUnion2 {
	if o == nil {
		return OpenAIResponsesInputRoleUnion2{}
	}
	return o.Role
}

func (o *OpenAIResponsesInputMessage2) GetContent() []OpenAIResponsesInputContent3 {
	if o == nil {
		return []OpenAIResponsesInputContent3{}
	}
	return o.Content
}

type OpenAIResponsesInputTypeMessage1 string

const (
	OpenAIResponsesInputTypeMessage1Message OpenAIResponsesInputTypeMessage1 = "message"
)

func (e OpenAIResponsesInputTypeMessage1) ToPointer() *OpenAIResponsesInputTypeMessage1 {
	return &e
}
func (e *OpenAIResponsesInputTypeMessage1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "message":
		*e = OpenAIResponsesInputTypeMessage1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputTypeMessage1: %v", v)
	}
}

type OpenAIResponsesInputRoleDeveloper1 string

const (
	OpenAIResponsesInputRoleDeveloper1Developer OpenAIResponsesInputRoleDeveloper1 = "developer"
)

func (e OpenAIResponsesInputRoleDeveloper1) ToPointer() *OpenAIResponsesInputRoleDeveloper1 {
	return &e
}
func (e *OpenAIResponsesInputRoleDeveloper1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "developer":
		*e = OpenAIResponsesInputRoleDeveloper1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleDeveloper1: %v", v)
	}
}

type OpenAIResponsesInputRoleAssistant string

const (
	OpenAIResponsesInputRoleAssistantAssistant OpenAIResponsesInputRoleAssistant = "assistant"
)

func (e OpenAIResponsesInputRoleAssistant) ToPointer() *OpenAIResponsesInputRoleAssistant {
	return &e
}
func (e *OpenAIResponsesInputRoleAssistant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "assistant":
		*e = OpenAIResponsesInputRoleAssistant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleAssistant: %v", v)
	}
}

type OpenAIResponsesInputRoleSystem1 string

const (
	OpenAIResponsesInputRoleSystem1System OpenAIResponsesInputRoleSystem1 = "system"
)

func (e OpenAIResponsesInputRoleSystem1) ToPointer() *OpenAIResponsesInputRoleSystem1 {
	return &e
}
func (e *OpenAIResponsesInputRoleSystem1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system":
		*e = OpenAIResponsesInputRoleSystem1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleSystem1: %v", v)
	}
}

type OpenAIResponsesInputRoleUser1 string

const (
	OpenAIResponsesInputRoleUser1User OpenAIResponsesInputRoleUser1 = "user"
)

func (e OpenAIResponsesInputRoleUser1) ToPointer() *OpenAIResponsesInputRoleUser1 {
	return &e
}
func (e *OpenAIResponsesInputRoleUser1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = OpenAIResponsesInputRoleUser1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OpenAIResponsesInputRoleUser1: %v", v)
	}
}

type OpenAIResponsesInputRoleUnion1Type string

const (
	OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleUser1      OpenAIResponsesInputRoleUnion1Type = "OpenAIResponsesInput_role_User_1"
	OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleSystem1    OpenAIResponsesInputRoleUnion1Type = "OpenAIResponsesInput_role_System_1"
	OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleAssistant  OpenAIResponsesInputRoleUnion1Type = "OpenAIResponsesInput_role_Assistant"
	OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleDeveloper1 OpenAIResponsesInputRoleUnion1Type = "OpenAIResponsesInput_role_Developer_1"
)

type OpenAIResponsesInputRoleUnion1 struct {
	OpenAIResponsesInputRoleUser1      *OpenAIResponsesInputRoleUser1      `queryParam:"inline" union:"member"`
	OpenAIResponsesInputRoleSystem1    *OpenAIResponsesInputRoleSystem1    `queryParam:"inline" union:"member"`
	OpenAIResponsesInputRoleAssistant  *OpenAIResponsesInputRoleAssistant  `queryParam:"inline" union:"member"`
	OpenAIResponsesInputRoleDeveloper1 *OpenAIResponsesInputRoleDeveloper1 `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputRoleUnion1Type
}

func CreateOpenAIResponsesInputRoleUnion1OpenAIResponsesInputRoleUser1(openAIResponsesInputRoleUser1 OpenAIResponsesInputRoleUser1) OpenAIResponsesInputRoleUnion1 {
	typ := OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleUser1

	return OpenAIResponsesInputRoleUnion1{
		OpenAIResponsesInputRoleUser1: &openAIResponsesInputRoleUser1,
		Type:                          typ,
	}
}

func CreateOpenAIResponsesInputRoleUnion1OpenAIResponsesInputRoleSystem1(openAIResponsesInputRoleSystem1 OpenAIResponsesInputRoleSystem1) OpenAIResponsesInputRoleUnion1 {
	typ := OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleSystem1

	return OpenAIResponsesInputRoleUnion1{
		OpenAIResponsesInputRoleSystem1: &openAIResponsesInputRoleSystem1,
		Type:                            typ,
	}
}

func CreateOpenAIResponsesInputRoleUnion1OpenAIResponsesInputRoleAssistant(openAIResponsesInputRoleAssistant OpenAIResponsesInputRoleAssistant) OpenAIResponsesInputRoleUnion1 {
	typ := OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleAssistant

	return OpenAIResponsesInputRoleUnion1{
		OpenAIResponsesInputRoleAssistant: &openAIResponsesInputRoleAssistant,
		Type:                              typ,
	}
}

func CreateOpenAIResponsesInputRoleUnion1OpenAIResponsesInputRoleDeveloper1(openAIResponsesInputRoleDeveloper1 OpenAIResponsesInputRoleDeveloper1) OpenAIResponsesInputRoleUnion1 {
	typ := OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleDeveloper1

	return OpenAIResponsesInputRoleUnion1{
		OpenAIResponsesInputRoleDeveloper1: &openAIResponsesInputRoleDeveloper1,
		Type:                               typ,
	}
}

func (u *OpenAIResponsesInputRoleUnion1) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openAIResponsesInputRoleUser1 OpenAIResponsesInputRoleUser1 = OpenAIResponsesInputRoleUser1("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleUser1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleUser1,
			Value: &openAIResponsesInputRoleUser1,
		})
	}

	var openAIResponsesInputRoleSystem1 OpenAIResponsesInputRoleSystem1 = OpenAIResponsesInputRoleSystem1("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleSystem1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleSystem1,
			Value: &openAIResponsesInputRoleSystem1,
		})
	}

	var openAIResponsesInputRoleAssistant OpenAIResponsesInputRoleAssistant = OpenAIResponsesInputRoleAssistant("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleAssistant, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleAssistant,
			Value: &openAIResponsesInputRoleAssistant,
		})
	}

	var openAIResponsesInputRoleDeveloper1 OpenAIResponsesInputRoleDeveloper1 = OpenAIResponsesInputRoleDeveloper1("")
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputRoleDeveloper1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleDeveloper1,
			Value: &openAIResponsesInputRoleDeveloper1,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputRoleUnion1", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputRoleUnion1", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenAIResponsesInputRoleUnion1Type)
	switch best.Type {
	case OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleUser1:
		u.OpenAIResponsesInputRoleUser1 = best.Value.(*OpenAIResponsesInputRoleUser1)
		return nil
	case OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleSystem1:
		u.OpenAIResponsesInputRoleSystem1 = best.Value.(*OpenAIResponsesInputRoleSystem1)
		return nil
	case OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleAssistant:
		u.OpenAIResponsesInputRoleAssistant = best.Value.(*OpenAIResponsesInputRoleAssistant)
		return nil
	case OpenAIResponsesInputRoleUnion1TypeOpenAIResponsesInputRoleDeveloper1:
		u.OpenAIResponsesInputRoleDeveloper1 = best.Value.(*OpenAIResponsesInputRoleDeveloper1)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputRoleUnion1", string(data))
}

func (u OpenAIResponsesInputRoleUnion1) MarshalJSON() ([]byte, error) {
	if u.OpenAIResponsesInputRoleUser1 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleUser1, "", true)
	}

	if u.OpenAIResponsesInputRoleSystem1 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleSystem1, "", true)
	}

	if u.OpenAIResponsesInputRoleAssistant != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleAssistant, "", true)
	}

	if u.OpenAIResponsesInputRoleDeveloper1 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputRoleDeveloper1, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputRoleUnion1: all fields are null")
}

type OpenAIResponsesInputContent1Type string

const (
	OpenAIResponsesInputContent1TypeInputText  OpenAIResponsesInputContent1Type = "input_text"
	OpenAIResponsesInputContent1TypeInputImage OpenAIResponsesInputContent1Type = "input_image"
	OpenAIResponsesInputContent1TypeInputFile  OpenAIResponsesInputContent1Type = "input_file"
	OpenAIResponsesInputContent1TypeInputAudio OpenAIResponsesInputContent1Type = "input_audio"
)

type OpenAIResponsesInputContent1 struct {
	ResponseInputText  *ResponseInputText  `queryParam:"inline" union:"member"`
	ResponseInputImage *ResponseInputImage `queryParam:"inline" union:"member"`
	ResponseInputFile  *ResponseInputFile  `queryParam:"inline" union:"member"`
	ResponseInputAudio *ResponseInputAudio `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputContent1Type
}

func CreateOpenAIResponsesInputContent1InputText(inputText ResponseInputText) OpenAIResponsesInputContent1 {
	typ := OpenAIResponsesInputContent1TypeInputText

	typStr := ResponseInputTextType(typ)
	inputText.Type = typStr

	return OpenAIResponsesInputContent1{
		ResponseInputText: &inputText,
		Type:              typ,
	}
}

func CreateOpenAIResponsesInputContent1InputImage(inputImage ResponseInputImage) OpenAIResponsesInputContent1 {
	typ := OpenAIResponsesInputContent1TypeInputImage

	typStr := ResponseInputImageType(typ)
	inputImage.Type = typStr

	return OpenAIResponsesInputContent1{
		ResponseInputImage: &inputImage,
		Type:               typ,
	}
}

func CreateOpenAIResponsesInputContent1InputFile(inputFile ResponseInputFile) OpenAIResponsesInputContent1 {
	typ := OpenAIResponsesInputContent1TypeInputFile

	typStr := ResponseInputFileType(typ)
	inputFile.Type = typStr

	return OpenAIResponsesInputContent1{
		ResponseInputFile: &inputFile,
		Type:              typ,
	}
}

func CreateOpenAIResponsesInputContent1InputAudio(inputAudio ResponseInputAudio) OpenAIResponsesInputContent1 {
	typ := OpenAIResponsesInputContent1TypeInputAudio

	typStr := ResponseInputAudioType(typ)
	inputAudio.Type = typStr

	return OpenAIResponsesInputContent1{
		ResponseInputAudio: &inputAudio,
		Type:               typ,
	}
}

func (u *OpenAIResponsesInputContent1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "input_text":
		responseInputText := new(ResponseInputText)
		if err := utils.UnmarshalJSON(data, &responseInputText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_text) type ResponseInputText within OpenAIResponsesInputContent1: %w", string(data), err)
		}

		u.ResponseInputText = responseInputText
		u.Type = OpenAIResponsesInputContent1TypeInputText
		return nil
	case "input_image":
		responseInputImage := new(ResponseInputImage)
		if err := utils.UnmarshalJSON(data, &responseInputImage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_image) type ResponseInputImage within OpenAIResponsesInputContent1: %w", string(data), err)
		}

		u.ResponseInputImage = responseInputImage
		u.Type = OpenAIResponsesInputContent1TypeInputImage
		return nil
	case "input_file":
		responseInputFile := new(ResponseInputFile)
		if err := utils.UnmarshalJSON(data, &responseInputFile, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_file) type ResponseInputFile within OpenAIResponsesInputContent1: %w", string(data), err)
		}

		u.ResponseInputFile = responseInputFile
		u.Type = OpenAIResponsesInputContent1TypeInputFile
		return nil
	case "input_audio":
		responseInputAudio := new(ResponseInputAudio)
		if err := utils.UnmarshalJSON(data, &responseInputAudio, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == input_audio) type ResponseInputAudio within OpenAIResponsesInputContent1: %w", string(data), err)
		}

		u.ResponseInputAudio = responseInputAudio
		u.Type = OpenAIResponsesInputContent1TypeInputAudio
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputContent1", string(data))
}

func (u OpenAIResponsesInputContent1) MarshalJSON() ([]byte, error) {
	if u.ResponseInputText != nil {
		return utils.MarshalJSON(u.ResponseInputText, "", true)
	}

	if u.ResponseInputImage != nil {
		return utils.MarshalJSON(u.ResponseInputImage, "", true)
	}

	if u.ResponseInputFile != nil {
		return utils.MarshalJSON(u.ResponseInputFile, "", true)
	}

	if u.ResponseInputAudio != nil {
		return utils.MarshalJSON(u.ResponseInputAudio, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputContent1: all fields are null")
}

type OpenAIResponsesInputContent2Type string

const (
	OpenAIResponsesInputContent2TypeArrayOfOpenAIResponsesInputContent1 OpenAIResponsesInputContent2Type = "arrayOfOpenAIResponsesInputContent1"
	OpenAIResponsesInputContent2TypeStr                                 OpenAIResponsesInputContent2Type = "str"
)

type OpenAIResponsesInputContent2 struct {
	ArrayOfOpenAIResponsesInputContent1 []OpenAIResponsesInputContent1 `queryParam:"inline" union:"member"`
	Str                                 *string                        `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputContent2Type
}

func CreateOpenAIResponsesInputContent2ArrayOfOpenAIResponsesInputContent1(arrayOfOpenAIResponsesInputContent1 []OpenAIResponsesInputContent1) OpenAIResponsesInputContent2 {
	typ := OpenAIResponsesInputContent2TypeArrayOfOpenAIResponsesInputContent1

	return OpenAIResponsesInputContent2{
		ArrayOfOpenAIResponsesInputContent1: arrayOfOpenAIResponsesInputContent1,
		Type:                                typ,
	}
}

func CreateOpenAIResponsesInputContent2Str(str string) OpenAIResponsesInputContent2 {
	typ := OpenAIResponsesInputContent2TypeStr

	return OpenAIResponsesInputContent2{
		Str:  &str,
		Type: typ,
	}
}

func (u *OpenAIResponsesInputContent2) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOfOpenAIResponsesInputContent1 []OpenAIResponsesInputContent1 = []OpenAIResponsesInputContent1{}
	if err := utils.UnmarshalJSON(data, &arrayOfOpenAIResponsesInputContent1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputContent2TypeArrayOfOpenAIResponsesInputContent1,
			Value: arrayOfOpenAIResponsesInputContent1,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputContent2TypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputContent2", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputContent2", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenAIResponsesInputContent2Type)
	switch best.Type {
	case OpenAIResponsesInputContent2TypeArrayOfOpenAIResponsesInputContent1:
		u.ArrayOfOpenAIResponsesInputContent1 = best.Value.([]OpenAIResponsesInputContent1)
		return nil
	case OpenAIResponsesInputContent2TypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputContent2", string(data))
}

func (u OpenAIResponsesInputContent2) MarshalJSON() ([]byte, error) {
	if u.ArrayOfOpenAIResponsesInputContent1 != nil {
		return utils.MarshalJSON(u.ArrayOfOpenAIResponsesInputContent1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputContent2: all fields are null")
}

type OpenAIResponsesInputMessage1 struct {
	Type    *OpenAIResponsesInputTypeMessage1 `json:"type,omitzero"`
	Role    OpenAIResponsesInputRoleUnion1    `json:"role"`
	Content OpenAIResponsesInputContent2      `json:"content"`
}

func (o OpenAIResponsesInputMessage1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OpenAIResponsesInputMessage1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OpenAIResponsesInputMessage1) GetType() *OpenAIResponsesInputTypeMessage1 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OpenAIResponsesInputMessage1) GetRole() OpenAIResponsesInputRoleUnion1 {
	if o == nil {
		return OpenAIResponsesInputRoleUnion1{}
	}
	return o.Role
}

func (o *OpenAIResponsesInputMessage1) GetContent() OpenAIResponsesInputContent2 {
	if o == nil {
		return OpenAIResponsesInputContent2{}
	}
	return o.Content
}

type OpenAIResponsesInputUnion1Type string

const (
	OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage1           OpenAIResponsesInputUnion1Type = "OpenAIResponsesInput_Message_1"
	OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage2           OpenAIResponsesInputUnion1Type = "OpenAIResponsesInput_Message_2"
	OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCallOutput OpenAIResponsesInputUnion1Type = "OpenAIResponsesInput_FunctionCallOutput"
	OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCall       OpenAIResponsesInputUnion1Type = "OpenAIResponsesInput_FunctionCall"
	OpenAIResponsesInputUnion1TypeOutputItemImageGenerationCall          OpenAIResponsesInputUnion1Type = "OutputItemImageGenerationCall"
	OpenAIResponsesInputUnion1TypeOutputMessage                          OpenAIResponsesInputUnion1Type = "OutputMessage"
)

type OpenAIResponsesInputUnion1 struct {
	OpenAIResponsesInputMessage1           *OpenAIResponsesInputMessage1           `queryParam:"inline" union:"member"`
	OpenAIResponsesInputMessage2           *OpenAIResponsesInputMessage2           `queryParam:"inline" union:"member"`
	OpenAIResponsesInputFunctionCallOutput *OpenAIResponsesInputFunctionCallOutput `queryParam:"inline" union:"member"`
	OpenAIResponsesInputFunctionCall       *OpenAIResponsesInputFunctionCall       `queryParam:"inline" union:"member"`
	OutputItemImageGenerationCall          *OutputItemImageGenerationCall          `queryParam:"inline" union:"member"`
	OutputMessage                          *OutputMessage                          `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputUnion1Type
}

func CreateOpenAIResponsesInputUnion1OpenAIResponsesInputMessage1(openAIResponsesInputMessage1 OpenAIResponsesInputMessage1) OpenAIResponsesInputUnion1 {
	typ := OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage1

	return OpenAIResponsesInputUnion1{
		OpenAIResponsesInputMessage1: &openAIResponsesInputMessage1,
		Type:                         typ,
	}
}

func CreateOpenAIResponsesInputUnion1OpenAIResponsesInputMessage2(openAIResponsesInputMessage2 OpenAIResponsesInputMessage2) OpenAIResponsesInputUnion1 {
	typ := OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage2

	return OpenAIResponsesInputUnion1{
		OpenAIResponsesInputMessage2: &openAIResponsesInputMessage2,
		Type:                         typ,
	}
}

func CreateOpenAIResponsesInputUnion1OpenAIResponsesInputFunctionCallOutput(openAIResponsesInputFunctionCallOutput OpenAIResponsesInputFunctionCallOutput) OpenAIResponsesInputUnion1 {
	typ := OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCallOutput

	return OpenAIResponsesInputUnion1{
		OpenAIResponsesInputFunctionCallOutput: &openAIResponsesInputFunctionCallOutput,
		Type:                                   typ,
	}
}

func CreateOpenAIResponsesInputUnion1OpenAIResponsesInputFunctionCall(openAIResponsesInputFunctionCall OpenAIResponsesInputFunctionCall) OpenAIResponsesInputUnion1 {
	typ := OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCall

	return OpenAIResponsesInputUnion1{
		OpenAIResponsesInputFunctionCall: &openAIResponsesInputFunctionCall,
		Type:                             typ,
	}
}

func CreateOpenAIResponsesInputUnion1OutputItemImageGenerationCall(outputItemImageGenerationCall OutputItemImageGenerationCall) OpenAIResponsesInputUnion1 {
	typ := OpenAIResponsesInputUnion1TypeOutputItemImageGenerationCall

	return OpenAIResponsesInputUnion1{
		OutputItemImageGenerationCall: &outputItemImageGenerationCall,
		Type:                          typ,
	}
}

func CreateOpenAIResponsesInputUnion1OutputMessage(outputMessage OutputMessage) OpenAIResponsesInputUnion1 {
	typ := OpenAIResponsesInputUnion1TypeOutputMessage

	return OpenAIResponsesInputUnion1{
		OutputMessage: &outputMessage,
		Type:          typ,
	}
}

func (u *OpenAIResponsesInputUnion1) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var openAIResponsesInputMessage1 OpenAIResponsesInputMessage1 = OpenAIResponsesInputMessage1{}
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputMessage1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage1,
			Value: &openAIResponsesInputMessage1,
		})
	}

	var openAIResponsesInputMessage2 OpenAIResponsesInputMessage2 = OpenAIResponsesInputMessage2{}
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputMessage2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage2,
			Value: &openAIResponsesInputMessage2,
		})
	}

	var openAIResponsesInputFunctionCallOutput OpenAIResponsesInputFunctionCallOutput = OpenAIResponsesInputFunctionCallOutput{}
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputFunctionCallOutput, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCallOutput,
			Value: &openAIResponsesInputFunctionCallOutput,
		})
	}

	var openAIResponsesInputFunctionCall OpenAIResponsesInputFunctionCall = OpenAIResponsesInputFunctionCall{}
	if err := utils.UnmarshalJSON(data, &openAIResponsesInputFunctionCall, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCall,
			Value: &openAIResponsesInputFunctionCall,
		})
	}

	var outputItemImageGenerationCall OutputItemImageGenerationCall = OutputItemImageGenerationCall{}
	if err := utils.UnmarshalJSON(data, &outputItemImageGenerationCall, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnion1TypeOutputItemImageGenerationCall,
			Value: &outputItemImageGenerationCall,
		})
	}

	var outputMessage OutputMessage = OutputMessage{}
	if err := utils.UnmarshalJSON(data, &outputMessage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnion1TypeOutputMessage,
			Value: &outputMessage,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputUnion1", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputUnion1", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenAIResponsesInputUnion1Type)
	switch best.Type {
	case OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage1:
		u.OpenAIResponsesInputMessage1 = best.Value.(*OpenAIResponsesInputMessage1)
		return nil
	case OpenAIResponsesInputUnion1TypeOpenAIResponsesInputMessage2:
		u.OpenAIResponsesInputMessage2 = best.Value.(*OpenAIResponsesInputMessage2)
		return nil
	case OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCallOutput:
		u.OpenAIResponsesInputFunctionCallOutput = best.Value.(*OpenAIResponsesInputFunctionCallOutput)
		return nil
	case OpenAIResponsesInputUnion1TypeOpenAIResponsesInputFunctionCall:
		u.OpenAIResponsesInputFunctionCall = best.Value.(*OpenAIResponsesInputFunctionCall)
		return nil
	case OpenAIResponsesInputUnion1TypeOutputItemImageGenerationCall:
		u.OutputItemImageGenerationCall = best.Value.(*OutputItemImageGenerationCall)
		return nil
	case OpenAIResponsesInputUnion1TypeOutputMessage:
		u.OutputMessage = best.Value.(*OutputMessage)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputUnion1", string(data))
}

func (u OpenAIResponsesInputUnion1) MarshalJSON() ([]byte, error) {
	if u.OpenAIResponsesInputMessage1 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputMessage1, "", true)
	}

	if u.OpenAIResponsesInputMessage2 != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputMessage2, "", true)
	}

	if u.OpenAIResponsesInputFunctionCallOutput != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputFunctionCallOutput, "", true)
	}

	if u.OpenAIResponsesInputFunctionCall != nil {
		return utils.MarshalJSON(u.OpenAIResponsesInputFunctionCall, "", true)
	}

	if u.OutputItemImageGenerationCall != nil {
		return utils.MarshalJSON(u.OutputItemImageGenerationCall, "", true)
	}

	if u.OutputMessage != nil {
		return utils.MarshalJSON(u.OutputMessage, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputUnion1: all fields are null")
}

type OpenAIResponsesInputUnionType string

const (
	OpenAIResponsesInputUnionTypeStr                               OpenAIResponsesInputUnionType = "str"
	OpenAIResponsesInputUnionTypeArrayOfOpenAIResponsesInputUnion1 OpenAIResponsesInputUnionType = "arrayOfOpenAIResponsesInputUnion1"
	OpenAIResponsesInputUnionTypeAny                               OpenAIResponsesInputUnionType = "any"
)

type OpenAIResponsesInputUnion struct {
	Str                               *string                      `queryParam:"inline" union:"member"`
	ArrayOfOpenAIResponsesInputUnion1 []OpenAIResponsesInputUnion1 `queryParam:"inline" union:"member"`
	Any                               any                          `queryParam:"inline" union:"member"`

	Type OpenAIResponsesInputUnionType
}

func CreateOpenAIResponsesInputUnionStr(str string) OpenAIResponsesInputUnion {
	typ := OpenAIResponsesInputUnionTypeStr

	return OpenAIResponsesInputUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateOpenAIResponsesInputUnionArrayOfOpenAIResponsesInputUnion1(arrayOfOpenAIResponsesInputUnion1 []OpenAIResponsesInputUnion1) OpenAIResponsesInputUnion {
	typ := OpenAIResponsesInputUnionTypeArrayOfOpenAIResponsesInputUnion1

	return OpenAIResponsesInputUnion{
		ArrayOfOpenAIResponsesInputUnion1: arrayOfOpenAIResponsesInputUnion1,
		Type:                              typ,
	}
}

func CreateOpenAIResponsesInputUnionAny(anyT any) OpenAIResponsesInputUnion {
	typ := OpenAIResponsesInputUnionTypeAny

	return OpenAIResponsesInputUnion{
		Any:  anyT,
		Type: typ,
	}
}

func (u *OpenAIResponsesInputUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnionTypeStr,
			Value: &str,
		})
	}

	var arrayOfOpenAIResponsesInputUnion1 []OpenAIResponsesInputUnion1 = []OpenAIResponsesInputUnion1{}
	if err := utils.UnmarshalJSON(data, &arrayOfOpenAIResponsesInputUnion1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnionTypeArrayOfOpenAIResponsesInputUnion1,
			Value: arrayOfOpenAIResponsesInputUnion1,
		})
	}

	var anyVar any = nil
	if err := utils.UnmarshalJSON(data, &anyVar, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OpenAIResponsesInputUnionTypeAny,
			Value: anyVar,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OpenAIResponsesInputUnionType)
	switch best.Type {
	case OpenAIResponsesInputUnionTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case OpenAIResponsesInputUnionTypeArrayOfOpenAIResponsesInputUnion1:
		u.ArrayOfOpenAIResponsesInputUnion1 = best.Value.([]OpenAIResponsesInputUnion1)
		return nil
	case OpenAIResponsesInputUnionTypeAny:
		u.Any = best.Value.(any)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OpenAIResponsesInputUnion", string(data))
}

func (u OpenAIResponsesInputUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfOpenAIResponsesInputUnion1 != nil {
		return utils.MarshalJSON(u.ArrayOfOpenAIResponsesInputUnion1, "", true)
	}

	if u.Any != nil {
		return utils.MarshalJSON(u.Any, "", true)
	}

	return nil, errors.New("could not marshal union type OpenAIResponsesInputUnion: all fields are null")
}
