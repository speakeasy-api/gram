// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/speakeasy-api/gram/openrouter/internal/utils"
	"github.com/speakeasy-api/gram/openrouter/models/components"
)

type TypeImageURL string

const (
	TypeImageURLImageURL TypeImageURL = "image_url"
)

func (e TypeImageURL) ToPointer() *TypeImageURL {
	return &e
}
func (e *TypeImageURL) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "image_url":
		*e = TypeImageURL(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeImageURL: %v", v)
	}
}

type ImageURL struct {
	URL string `json:"url"`
}

func (i ImageURL) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *ImageURL) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *ImageURL) GetURL() string {
	if i == nil {
		return ""
	}
	return i.URL
}

type ContentImageURL struct {
	Type     TypeImageURL `json:"type"`
	ImageURL ImageURL     `json:"image_url"`
}

func (c ContentImageURL) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentImageURL) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ContentImageURL) GetType() TypeImageURL {
	if c == nil {
		return TypeImageURL("")
	}
	return c.Type
}

func (c *ContentImageURL) GetImageURL() ImageURL {
	if c == nil {
		return ImageURL{}
	}
	return c.ImageURL
}

type TypeText string

const (
	TypeTextText TypeText = "text"
)

func (e TypeText) ToPointer() *TypeText {
	return &e
}
func (e *TypeText) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		*e = TypeText(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeText: %v", v)
	}
}

type ContentText struct {
	Type TypeText `json:"type"`
	Text string   `json:"text"`
}

func (c ContentText) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentText) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ContentText) GetType() TypeText {
	if c == nil {
		return TypeText("")
	}
	return c.Type
}

func (c *ContentText) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

type ContentType string

const (
	ContentTypeText     ContentType = "text"
	ContentTypeImageURL ContentType = "image_url"
)

type Content struct {
	ContentText     *ContentText     `queryParam:"inline" union:"member"`
	ContentImageURL *ContentImageURL `queryParam:"inline" union:"member"`

	Type ContentType
}

func CreateContentText(text ContentText) Content {
	typ := ContentTypeText

	typStr := TypeText(typ)
	text.Type = typStr

	return Content{
		ContentText: &text,
		Type:        typ,
	}
}

func CreateContentImageURL(imageURL ContentImageURL) Content {
	typ := ContentTypeImageURL

	typStr := TypeImageURL(typ)
	imageURL.Type = typStr

	return Content{
		ContentImageURL: &imageURL,
		Type:            typ,
	}
}

func (u *Content) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "text":
		contentText := new(ContentText)
		if err := utils.UnmarshalJSON(data, &contentText, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == text) type ContentText within Content: %w", string(data), err)
		}

		u.ContentText = contentText
		u.Type = ContentTypeText
		return nil
	case "image_url":
		contentImageURL := new(ContentImageURL)
		if err := utils.UnmarshalJSON(data, &contentImageURL, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == image_url) type ContentImageURL within Content: %w", string(data), err)
		}

		u.ContentImageURL = contentImageURL
		u.Type = ContentTypeImageURL
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Content", string(data))
}

func (u Content) MarshalJSON() ([]byte, error) {
	if u.ContentText != nil {
		return utils.MarshalJSON(u.ContentText, "", true)
	}

	if u.ContentImageURL != nil {
		return utils.MarshalJSON(u.ContentImageURL, "", true)
	}

	return nil, errors.New("could not marshal union type Content: all fields are null")
}

type Input struct {
	Content []Content `json:"content"`
}

func (i Input) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *Input) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *Input) GetContent() []Content {
	if i == nil {
		return []Content{}
	}
	return i.Content
}

type InputUnionType string

const (
	InputUnionTypeStr                  InputUnionType = "str"
	InputUnionTypeArrayOfStr           InputUnionType = "arrayOfStr"
	InputUnionTypeArrayOfNumber        InputUnionType = "arrayOfNumber"
	InputUnionTypeArrayOfArrayOfNumber InputUnionType = "arrayOfArrayOfNumber"
	InputUnionTypeArrayOfInput         InputUnionType = "arrayOfInput"
)

type InputUnion struct {
	Str                  *string     `queryParam:"inline" union:"member"`
	ArrayOfStr           []string    `queryParam:"inline" union:"member"`
	ArrayOfNumber        []float64   `queryParam:"inline" union:"member"`
	ArrayOfArrayOfNumber [][]float64 `queryParam:"inline" union:"member"`
	ArrayOfInput         []Input     `queryParam:"inline" union:"member"`

	Type InputUnionType
}

func CreateInputUnionStr(str string) InputUnion {
	typ := InputUnionTypeStr

	return InputUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateInputUnionArrayOfStr(arrayOfStr []string) InputUnion {
	typ := InputUnionTypeArrayOfStr

	return InputUnion{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func CreateInputUnionArrayOfNumber(arrayOfNumber []float64) InputUnion {
	typ := InputUnionTypeArrayOfNumber

	return InputUnion{
		ArrayOfNumber: arrayOfNumber,
		Type:          typ,
	}
}

func CreateInputUnionArrayOfArrayOfNumber(arrayOfArrayOfNumber [][]float64) InputUnion {
	typ := InputUnionTypeArrayOfArrayOfNumber

	return InputUnion{
		ArrayOfArrayOfNumber: arrayOfArrayOfNumber,
		Type:                 typ,
	}
}

func CreateInputUnionArrayOfInput(arrayOfInput []Input) InputUnion {
	typ := InputUnionTypeArrayOfInput

	return InputUnion{
		ArrayOfInput: arrayOfInput,
		Type:         typ,
	}
}

func (u *InputUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputUnionTypeStr,
			Value: &str,
		})
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputUnionTypeArrayOfStr,
			Value: arrayOfStr,
		})
	}

	var arrayOfNumber []float64 = []float64{}
	if err := utils.UnmarshalJSON(data, &arrayOfNumber, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputUnionTypeArrayOfNumber,
			Value: arrayOfNumber,
		})
	}

	var arrayOfArrayOfNumber [][]float64 = [][]float64{}
	if err := utils.UnmarshalJSON(data, &arrayOfArrayOfNumber, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputUnionTypeArrayOfArrayOfNumber,
			Value: arrayOfArrayOfNumber,
		})
	}

	var arrayOfInput []Input = []Input{}
	if err := utils.UnmarshalJSON(data, &arrayOfInput, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputUnionTypeArrayOfInput,
			Value: arrayOfInput,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(InputUnionType)
	switch best.Type {
	case InputUnionTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case InputUnionTypeArrayOfStr:
		u.ArrayOfStr = best.Value.([]string)
		return nil
	case InputUnionTypeArrayOfNumber:
		u.ArrayOfNumber = best.Value.([]float64)
		return nil
	case InputUnionTypeArrayOfArrayOfNumber:
		u.ArrayOfArrayOfNumber = best.Value.([][]float64)
		return nil
	case InputUnionTypeArrayOfInput:
		u.ArrayOfInput = best.Value.([]Input)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputUnion", string(data))
}

func (u InputUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	if u.ArrayOfNumber != nil {
		return utils.MarshalJSON(u.ArrayOfNumber, "", true)
	}

	if u.ArrayOfArrayOfNumber != nil {
		return utils.MarshalJSON(u.ArrayOfArrayOfNumber, "", true)
	}

	if u.ArrayOfInput != nil {
		return utils.MarshalJSON(u.ArrayOfInput, "", true)
	}

	return nil, errors.New("could not marshal union type InputUnion: all fields are null")
}

type EncodingFormat string

const (
	EncodingFormatFloat  EncodingFormat = "float"
	EncodingFormatBase64 EncodingFormat = "base64"
)

func (e EncodingFormat) ToPointer() *EncodingFormat {
	return &e
}

// IsExact returns true if the value matches a known enum value, false otherwise.
func (e *EncodingFormat) IsExact() bool {
	if e != nil {
		switch *e {
		case "float", "base64":
			return true
		}
	}
	return false
}

type CreateEmbeddingsRequest struct {
	Input          InputUnion      `json:"input"`
	Model          string          `json:"model"`
	EncodingFormat *EncodingFormat `json:"encoding_format,omitzero"`
	Dimensions     *int64          `json:"dimensions,omitzero"`
	User           *string         `json:"user,omitzero"`
	// Provider routing preferences for the request.
	Provider  *components.ProviderPreferences `json:"provider,omitzero"`
	InputType *string                         `json:"input_type,omitzero"`
}

func (c CreateEmbeddingsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateEmbeddingsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateEmbeddingsRequest) GetInput() InputUnion {
	if c == nil {
		return InputUnion{}
	}
	return c.Input
}

func (c *CreateEmbeddingsRequest) GetModel() string {
	if c == nil {
		return ""
	}
	return c.Model
}

func (c *CreateEmbeddingsRequest) GetEncodingFormat() *EncodingFormat {
	if c == nil {
		return nil
	}
	return c.EncodingFormat
}

func (c *CreateEmbeddingsRequest) GetDimensions() *int64 {
	if c == nil {
		return nil
	}
	return c.Dimensions
}

func (c *CreateEmbeddingsRequest) GetUser() *string {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *CreateEmbeddingsRequest) GetProvider() *components.ProviderPreferences {
	if c == nil {
		return nil
	}
	return c.Provider
}

func (c *CreateEmbeddingsRequest) GetInputType() *string {
	if c == nil {
		return nil
	}
	return c.InputType
}

type Object string

const (
	ObjectList Object = "list"
)

func (e Object) ToPointer() *Object {
	return &e
}
func (e *Object) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list":
		*e = Object(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Object: %v", v)
	}
}

type ObjectEmbedding string

const (
	ObjectEmbeddingEmbedding ObjectEmbedding = "embedding"
)

func (e ObjectEmbedding) ToPointer() *ObjectEmbedding {
	return &e
}
func (e *ObjectEmbedding) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "embedding":
		*e = ObjectEmbedding(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ObjectEmbedding: %v", v)
	}
}

type EmbeddingType string

const (
	EmbeddingTypeArrayOfNumber EmbeddingType = "arrayOfNumber"
	EmbeddingTypeStr           EmbeddingType = "str"
)

type Embedding struct {
	ArrayOfNumber []float64 `queryParam:"inline" union:"member"`
	Str           *string   `queryParam:"inline" union:"member"`

	Type EmbeddingType
}

func CreateEmbeddingArrayOfNumber(arrayOfNumber []float64) Embedding {
	typ := EmbeddingTypeArrayOfNumber

	return Embedding{
		ArrayOfNumber: arrayOfNumber,
		Type:          typ,
	}
}

func CreateEmbeddingStr(str string) Embedding {
	typ := EmbeddingTypeStr

	return Embedding{
		Str:  &str,
		Type: typ,
	}
}

func (u *Embedding) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOfNumber []float64 = []float64{}
	if err := utils.UnmarshalJSON(data, &arrayOfNumber, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EmbeddingTypeArrayOfNumber,
			Value: arrayOfNumber,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EmbeddingTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Embedding", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Embedding", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(EmbeddingType)
	switch best.Type {
	case EmbeddingTypeArrayOfNumber:
		u.ArrayOfNumber = best.Value.([]float64)
		return nil
	case EmbeddingTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Embedding", string(data))
}

func (u Embedding) MarshalJSON() ([]byte, error) {
	if u.ArrayOfNumber != nil {
		return utils.MarshalJSON(u.ArrayOfNumber, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Embedding: all fields are null")
}

type CreateEmbeddingsData struct {
	Object    ObjectEmbedding `json:"object"`
	Embedding Embedding       `json:"embedding"`
	Index     *float64        `json:"index,omitzero"`
}

func (c *CreateEmbeddingsData) GetObject() ObjectEmbedding {
	if c == nil {
		return ObjectEmbedding("")
	}
	return c.Object
}

func (c *CreateEmbeddingsData) GetEmbedding() Embedding {
	if c == nil {
		return Embedding{}
	}
	return c.Embedding
}

func (c *CreateEmbeddingsData) GetIndex() *float64 {
	if c == nil {
		return nil
	}
	return c.Index
}

type Usage struct {
	PromptTokens float64  `json:"prompt_tokens"`
	TotalTokens  float64  `json:"total_tokens"`
	Cost         *float64 `json:"cost,omitzero"`
}

func (u *Usage) GetPromptTokens() float64 {
	if u == nil {
		return 0.0
	}
	return u.PromptTokens
}

func (u *Usage) GetTotalTokens() float64 {
	if u == nil {
		return 0.0
	}
	return u.TotalTokens
}

func (u *Usage) GetCost() *float64 {
	if u == nil {
		return nil
	}
	return u.Cost
}

// CreateEmbeddingsResponseBody - Embedding response
type CreateEmbeddingsResponseBody struct {
	ID     *string                `json:"id,omitzero"`
	Object Object                 `json:"object"`
	Data   []CreateEmbeddingsData `json:"data"`
	Model  string                 `json:"model"`
	Usage  *Usage                 `json:"usage,omitzero"`
}

func (c CreateEmbeddingsResponseBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateEmbeddingsResponseBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateEmbeddingsResponseBody) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CreateEmbeddingsResponseBody) GetObject() Object {
	if c == nil {
		return Object("")
	}
	return c.Object
}

func (c *CreateEmbeddingsResponseBody) GetData() []CreateEmbeddingsData {
	if c == nil {
		return []CreateEmbeddingsData{}
	}
	return c.Data
}

func (c *CreateEmbeddingsResponseBody) GetModel() string {
	if c == nil {
		return ""
	}
	return c.Model
}

func (c *CreateEmbeddingsResponseBody) GetUsage() *Usage {
	if c == nil {
		return nil
	}
	return c.Usage
}

type CreateEmbeddingsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Embedding response
	Object *CreateEmbeddingsResponseBody
	// Embedding response
	Res *string
}

func (c CreateEmbeddingsResponse) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateEmbeddingsResponse) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateEmbeddingsResponse) GetHTTPMeta() components.HTTPMetadata {
	if c == nil {
		return components.HTTPMetadata{}
	}
	return c.HTTPMeta
}

func (c *CreateEmbeddingsResponse) GetObject() *CreateEmbeddingsResponseBody {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CreateEmbeddingsResponse) GetRes() *string {
	if c == nil {
		return nil
	}
	return c.Res
}
