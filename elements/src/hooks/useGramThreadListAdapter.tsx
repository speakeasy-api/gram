import {
  GramChat,
  GramChatOverview,
  convertGramMessagesToExported,
  convertGramMessagesToUIMessages,
} from '@/lib/messageConverter'
import {
  unstable_RemoteThreadListAdapter as RemoteThreadListAdapter,
  RuntimeAdapterProvider,
  ThreadHistoryAdapter,
  ThreadMessage,
  useAssistantApi,
  type AssistantApi,
} from '@assistant-ui/react'
import { chatGenerateTitle } from '@gram/client/funcs/chatGenerateTitle'
import { chatList } from '@gram/client/funcs/chatList'
import { createAssistantStream, type AssistantStream } from 'assistant-stream'
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
  type PropsWithChildren,
} from 'react'
import { useSdkClient } from './useSdkClient'

/**
 * Prefix used by assistant-ui for local thread IDs that haven't been persisted yet.
 * This is an internal implementation detail of assistant-ui's RemoteThreadListThreadListRuntimeCore.
 * If the library changes this prefix, we only need to update it here.
 */
const LOCAL_THREAD_ID_PREFIX = '__LOCALID_'

/**
 * Checks if a thread ID is a local (unpersisted) thread ID.
 * Local IDs are generated by assistant-ui before the thread is initialized with a remote ID.
 */
export function isLocalThreadId(threadId: string | null | undefined): boolean {
  return !!threadId?.startsWith(LOCAL_THREAD_ID_PREFIX)
}

export interface ThreadListAdapterOptions {
  apiUrl: string
  headers: Record<string, string>
  /** Map to translate local thread IDs to UUIDs (shared with transport) */
  localIdToUuidMap?: Map<string, string>
}

interface ListChatsResponse {
  chats: GramChatOverview[]
}

/**
 * Thread history adapter that loads messages from Gram API.
 * Note: We use `as ThreadHistoryAdapter` cast because the withFormat generic
 * signature doesn't match our concrete implementation, but it works at runtime.
 */
class GramThreadHistoryAdapter {
  private apiUrl: string
  private headers: Record<string, string>
  private store: AssistantApi

  constructor(
    apiUrl: string,
    headers: Record<string, string>,
    store: AssistantApi
  ) {
    this.apiUrl = apiUrl
    this.headers = headers
    this.store = store
  }

  async load() {
    const remoteId = this.store.threadListItem().getState().remoteId
    if (!remoteId) {
      return { messages: [], headId: null }
    }

    try {
      const response = await fetch(
        `${this.apiUrl}/rpc/chat.load?id=${encodeURIComponent(remoteId)}`,
        { headers: this.headers }
      )

      if (!response.ok) {
        console.error('Failed to load chat:', response.status)
        return { messages: [], headId: null }
      }

      const chat = (await response.json()) as GramChat
      return convertGramMessagesToExported(chat.messages)
    } catch (error) {
      console.error('Error loading chat:', error)
      return { messages: [], headId: null }
    }
  }

  async append() {
    // No-op: Gram persists messages server-side during streaming.
  }

  // Required by ThreadHistoryAdapter - wraps adapter with format conversion.
  // The _formatAdapter param is part of the interface but unused since we handle conversion ourselves.
  // Using arrow functions to capture `this` lexically.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  withFormat(_formatAdapter: unknown) {
    return {
      load: async () => {
        const remoteId = this.store.threadListItem().getState().remoteId
        if (!remoteId) {
          return { messages: [], headId: null }
        }

        const response = await fetch(
          `${this.apiUrl}/rpc/chat.load?id=${encodeURIComponent(remoteId)}`,
          { headers: this.headers }
        )

        if (!response.ok) {
          console.error('Failed to load chat (withFormat):', response.status)
          return { messages: [], headId: null }
        }

        const chat = (await response.json()) as GramChat
        return convertGramMessagesToUIMessages(chat.messages)

        // // Filter out system messages (assistant-ui doesn't support them in the import path)
        // const filteredMessages = chat.messages.filter(
        //   (msg) => msg.role !== 'system'
        // )

        // if (filteredMessages.length === 0) {
        //   return { messages: [], headId: null }
        // }

        // // Convert to the format expected by useExternalHistory
        // // It expects UIMessage format with role and parts array
        // let prevId: string | null = null
        // const messages = filteredMessages.map((msg, index) => {
        //   // Generate a fallback ID if missing (required by assistant-ui's MessageRepository)
        //   const messageId = msg.id || `fallback-${index}-${Date.now()}`
        //   const uiMessage = {
        //     parentId: prevId,
        //     message: {
        //       id: messageId,
        //       role: msg.role as 'user' | 'assistant',
        //       parts: [{ type: 'text' as const, text: msg.content || '' }],
        //       createdAt: msg.createdAt ? new Date(msg.createdAt) : new Date(),
        //     },
        //   }
        //   prevId = messageId
        //   return uiMessage
        // })

        // return {
        //   headId: prevId,
        //   messages,
        // }
      },
      append: async () => {
        // No-op
      },
    }
  }
}

/**
 * Hook to create a Gram thread history adapter.
 */
function useGramThreadHistoryAdapter(
  optionsRef: React.RefObject<ThreadListAdapterOptions>
): ThreadHistoryAdapter {
  const store = useAssistantApi()
  const [adapter] = useState(
    () =>
      new GramThreadHistoryAdapter(
        optionsRef.current.apiUrl,
        optionsRef.current.headers,
        store
      )
  )
  // Cast to ThreadHistoryAdapter - the withFormat generic doesn't match but works at runtime
  return adapter as unknown as ThreadHistoryAdapter
}

/**
 * Hook that creates a RemoteThreadListAdapter for the Gram API.
 * This properly handles React component identity for the Provider.
 */
export function useGramThreadListAdapter(
  options: ThreadListAdapterOptions
): RemoteThreadListAdapter {
  const { client, options: sdkOptions } = useSdkClient()
  const optionsRef = useRef(options)
  useEffect(() => {
    optionsRef.current = options
  }, [options])

  // Create stable Provider component using useCallback
  const unstable_Provider = useCallback(function GramHistoryProvider({
    children,
  }: PropsWithChildren) {
    const history = useGramThreadHistoryAdapter(optionsRef)
    const adapters = useMemo(() => ({ history }), [history])
    return (
      <RuntimeAdapterProvider adapters={adapters}>
        {children}
      </RuntimeAdapterProvider>
    )
  }, [])

  // Return adapter with stable methods
  return useMemo(
    () => ({
      unstable_Provider,

      async list() {
        try {
          const response = await chatList(client, undefined, undefined, sdkOptions)

          if (!response.ok || response.error) {
            console.error('Failed to list chats:', response.error)
            return { threads: [] }
          }

          const chats = response.value.chats
          return {
            threads: chats.map((chat) => ({
              remoteId: chat.id,
              externalId: chat.id,
              status: 'regular' as const,
              title: chat.title || 'New Chat',
            })),
          }
        } catch (error) {
          console.error('Error listing chats:', error)
          return { threads: [] }
        }
      },

      async initialize(threadId: string) {
        // For new threads (local IDs), check if sendMessages already created a UUID
        if (isLocalThreadId(threadId)) {
          // Check if transport already generated a UUID for this local ID
          const existingUuid =
            optionsRef.current.localIdToUuidMap?.get(threadId)
          if (existingUuid) {
            return {
              remoteId: existingUuid,
              externalId: existingUuid,
            }
          }
          // Otherwise generate a new one and store it
          const uuid = crypto.randomUUID()
          optionsRef.current.localIdToUuidMap?.set(threadId, uuid)
          return {
            remoteId: uuid,
            externalId: uuid,
          }
        }
        // For existing threads, use the ID as-is
        return {
          remoteId: threadId,
          externalId: threadId,
        }
      },

      async rename() {
        // No-op
      },

      async archive() {
        // No-op
      },

      async unarchive() {
        // No-op
      },

      async delete() {
        // No-op
      },

      async generateTitle(
        remoteId: string,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _messages: readonly ThreadMessage[]
      ): Promise<AssistantStream> {
        // Skip if this is a local ID that hasn't been persisted yet
        if (!remoteId || isLocalThreadId(remoteId)) {
          return createAssistantStream((controller) => {
            controller.close()
          })
        }

        // Title generation happens async server-side via Temporal after first completion.
        // This delay allows the OpenRouter LLM call to complete before we fetch the title.
        const TITLE_GENERATION_DELAY_MS = 2000
        await new Promise((r) => setTimeout(r, TITLE_GENERATION_DELAY_MS))

        try {
          const response = await chatGenerateTitle(client, {
            serveImageForm: { id: remoteId },
          }, undefined, sdkOptions)

          if (response.ok) {
            const title = response.value.title

            if (title) {
              return createAssistantStream((controller) => {
                controller.appendText(title)
                controller.close()
              })
            }
          }
        } catch (error) {
          console.error('Error fetching title:', error)
        }

        // If title fetch failed or got placeholder, return empty stream (keeps existing title)
        return createAssistantStream((controller) => {
          controller.close()
        })
      },

      async fetch(threadId: string) {
        // Skip if this is a local ID that hasn't been persisted yet
        if (!threadId || isLocalThreadId(threadId)) {
          return {
            remoteId: threadId,
            status: 'regular' as const,
          }
        }

        try {
          const response = await fetch(
            `${optionsRef.current.apiUrl}/rpc/chat.load?id=${encodeURIComponent(threadId)}`,
            {
              headers: optionsRef.current.headers,
            }
          )

          if (!response.ok) {
            console.error('Failed to fetch thread:', response.status)
            return {
              remoteId: threadId,
              status: 'regular' as const,
            }
          }

          const chat = await response.json()
          return {
            remoteId: chat.id,
            externalId: chat.id,
            status: 'regular' as const,
            title: chat.title || 'New Chat',
          }
        } catch (error) {
          console.error('Error fetching thread:', error)
          return {
            remoteId: threadId,
            status: 'regular' as const,
          }
        }
      },
    }),
    [unstable_Provider]
  )
}
